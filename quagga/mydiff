diff --git a/Makefile.am b/Makefile.am
index 96da94f..2e449bd 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -2,10 +2,10 @@
 
 SUBDIRS = lib @ZEBRA@ @BGPD@ @RIPD@ @RIPNGD@ @OSPFD@ @OSPF6D@ \
          @ISISD@ @WATCHQUAGGA@ @VTYSH@ @OSPFCLIENT@ doc m4 @pkgsrcdir@ \
-         redhat @SOLARIS@
+         redhat @SOLARIS@ @LDPD@ @RSVPD@
 
-DIST_SUBDIRS = lib zebra bgpd ripd ripngd ospfd ospf6d \
-	  isisd watchquagga vtysh ospfclient doc m4 pkgsrc redhat tests \
+DIST_SUBDIRS = lib zebra bgpd ripd ripngd ospfd ospf6d ldpd rsvpd \
+	  isisd watchquagga vtysh ospfclient ldpd doc m4 pkgsrc redhat tests \
 	  solaris
 
 EXTRA_DIST = aclocal.m4 SERVICES TODO REPORTING-BUGS INSTALL.quagga.txt \
diff --git a/bgpd/bgp_nexthop.c b/bgpd/bgp_nexthop.c
index 4dd5d94..93d8657 100644
--- a/bgpd/bgp_nexthop.c
+++ b/bgpd/bgp_nexthop.c
@@ -118,33 +118,31 @@ bgp_nexthop_same (struct nexthop *next1, struct nexthop *next2)
   if (next1->type != next2->type)
     return 0;
 
-  switch (next1->type)
+  if (CHECK_FLAG (next1->type, ZEBRA_NEXTHOP_IPV4))
     {
-    case ZEBRA_NEXTHOP_IPV4:
       if (! IPV4_ADDR_SAME (&next1->gate.ipv4, &next2->gate.ipv4))
 	return 0;
-      break;
-    case ZEBRA_NEXTHOP_IFINDEX:
-    case ZEBRA_NEXTHOP_IFNAME:
-      if (next1->ifindex != next2->ifindex)
-	return 0;
-      break;
+    }
 #ifdef HAVE_IPV6
-    case ZEBRA_NEXTHOP_IPV6:
-      if (! IPV6_ADDR_SAME (&next1->gate.ipv6, &next2->gate.ipv6))
-	return 0;
-      break;
-    case ZEBRA_NEXTHOP_IPV6_IFINDEX:
-    case ZEBRA_NEXTHOP_IPV6_IFNAME:
-      if (! IPV6_ADDR_SAME (&next1->gate.ipv6, &next2->gate.ipv6))
+  else if (CHECK_FLAG (next1->type, ZEBRA_NEXTHOP_IPV6))
+    {
+      if (!IPV6_ADDR_SAME (&next1->gate.ipv6, &next2->gate.ipv6))
 	return 0;
+    }
+#endif /* HAVE_IPV6 */
+
+  if (CHECK_FLAG (next1->type, ZEBRA_NEXTHOP_IFINDEX))
+    {
       if (next1->ifindex != next2->ifindex)
 	return 0;
-      break;
-#endif /* HAVE_IPV6 */
-    default:
-      /* do nothing */
-      break;
+    }
+  else if (CHECK_FLAG (next1->type, ZEBRA_NEXTHOP_IFNAME))
+    {
+      if (!(next1->ifname && next2->ifname))
+        return 0;
+
+      if (strncmp(next1->ifname, next2->ifname, INTERFACE_NAMSIZ))
+        return 0;
     }
   return 1;
 }
@@ -714,6 +712,7 @@ zlookup_read ()
   int i;
   u_char nexthop_num;
   struct nexthop *nexthop;
+  struct zapi_nexthop znh;
   struct bgp_nexthop_cache *bnc;
 
   s = zlookup->ibuf;
@@ -750,20 +749,27 @@ zlookup_read ()
 	{
 	  nexthop = XMALLOC (MTYPE_NEXTHOP, sizeof (struct nexthop));
 	  memset (nexthop, 0, sizeof (struct nexthop));
-	  nexthop->type = stream_getc (s);
-	  switch (nexthop->type)
+	  zapi_nexthop_read(s, &znh);
+
+	  nexthop->type = znh.type;
+	  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
+	    {
+	      nexthop->gate.ipv4.s_addr = znh.gw.ipv4.s_addr;
+	    }
+	  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
+	    {
+	      assert (0);
+	    }
+
+	  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
+	    {
+	      nexthop->ifindex = znh.intf.index;
+	    }
+	  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
 	    {
-	    case ZEBRA_NEXTHOP_IPV4:
-	      nexthop->gate.ipv4.s_addr = stream_get_ipv4 (s);
-	      break;
-	    case ZEBRA_NEXTHOP_IFINDEX:
-	    case ZEBRA_NEXTHOP_IFNAME:
-	      nexthop->ifindex = stream_getl (s);
-	      break;
-            default:
-              /* do nothing */
-              break;
+	      assert (0);
 	    }
+
 	  bnc_nexthop_add (bnc, nexthop);
 	}
     }
@@ -823,6 +829,7 @@ zlookup_read_ipv6 ()
   int i;
   u_char nexthop_num;
   struct nexthop *nexthop;
+  struct zapi_nexthop znh;
   struct bgp_nexthop_cache *bnc;
 
   s = zlookup->ibuf;
@@ -858,27 +865,29 @@ zlookup_read_ipv6 ()
 
       for (i = 0; i < nexthop_num; i++)
 	{
+	  zapi_nexthop_read(s, &znh);
 	  nexthop = XMALLOC (MTYPE_NEXTHOP, sizeof (struct nexthop));
 	  memset (nexthop, 0, sizeof (struct nexthop));
-	  nexthop->type = stream_getc (s);
-	  switch (nexthop->type)
+	  nexthop->type = znh.type;
+
+	  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
+	    {
+	      assert (0);
+	    }
+	  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
+	    {
+	      nexthop->gate.ipv6 = znh.gw.ipv6;
+	    }
+
+	  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
+	    {
+	      nexthop->ifindex = znh.intf.index;
+	    }
+	  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
 	    {
-	    case ZEBRA_NEXTHOP_IPV6:
-	      stream_get (&nexthop->gate.ipv6, s, 16);
-	      break;
-	    case ZEBRA_NEXTHOP_IPV6_IFINDEX:
-	    case ZEBRA_NEXTHOP_IPV6_IFNAME:
-	      stream_get (&nexthop->gate.ipv6, s, 16);
-	      nexthop->ifindex = stream_getl (s);
-	      break;
-	    case ZEBRA_NEXTHOP_IFINDEX:
-	    case ZEBRA_NEXTHOP_IFNAME:
-	      nexthop->ifindex = stream_getl (s);
-	      break;
-	    default:
-	      /* do nothing */
-	      break;
+	      assert (0);
 	    }
+
 	  bnc_nexthop_add (bnc, nexthop);
 	}
     }
@@ -938,6 +947,8 @@ bgp_import_check (struct prefix *p, u_int32_t *igpmetric,
   u_int32_t metric = 0;
   u_char nexthop_num;
   u_char nexthop_type;
+  struct zapi_nexthop znh;
+  int i;
 
   /* If lookup connection is not available return valid. */
   if (zlookup->sock < 0)
@@ -1007,17 +1018,22 @@ bgp_import_check (struct prefix *p, u_int32_t *igpmetric,
   /* If there is nexthop then this is active route. */
   if (nexthop_num)
     {
-      nexthop.s_addr = 0;
-      nexthop_type = stream_getc (s);
-      if (nexthop_type == ZEBRA_NEXTHOP_IPV4)
+      for (i = 0; i < nexthop_num; i++)
 	{
-	  nexthop.s_addr = stream_get_ipv4 (s);
-	  if (igpnexthop)
-	    *igpnexthop = nexthop;
+	  zapi_nexthop_read(s, &znh);
+	  nexthop_type = znh.type;
+	  if (CHECK_FLAG (nexthop_type, ZEBRA_NEXTHOP_IPV4))
+	    {
+	      nexthop.s_addr = znh.gw.ipv4.s_addr;
+	    }
+	  else if (CHECK_FLAG (nexthop_type, ZEBRA_NEXTHOP_IPV6))
+	    {
+	      assert (0);
+	    }
 	}
-      else
-	*igpnexthop = nexthop;
 
+      if (igpnexthop)
+	*igpnexthop = nexthop;
       return 1;
     }
   else
diff --git a/bgpd/bgp_route.c b/bgpd/bgp_route.c
index 4fbc4ba..f3d82a1 100644
--- a/bgpd/bgp_route.c
+++ b/bgpd/bgp_route.c
@@ -1893,7 +1893,10 @@ bgp_update_rsclient (struct peer *rsclient, afi_t afi, safi_t safi,
 
       /* Update MPLS tag.  */
       if (safi == SAFI_MPLS_VPN)
-        memcpy ((bgp_info_extra_get (ri))->tag, tag, 3);
+        {
+          bgp_info_set_flag (rn, ri, BGP_INFO_MPLS);
+          memcpy ((bgp_info_extra_get (ri))->tag, tag, 3);
+        }
 
       bgp_info_set_flag (rn, ri, BGP_INFO_VALID);
 
@@ -1923,7 +1926,10 @@ bgp_update_rsclient (struct peer *rsclient, afi_t afi, safi_t safi,
 
   /* Update MPLS tag. */
   if (safi == SAFI_MPLS_VPN)
-    memcpy ((bgp_info_extra_get (new))->tag, tag, 3);
+    {
+      bgp_info_set_flag (rn, new, BGP_INFO_MPLS);
+      memcpy ((bgp_info_extra_get (new))->tag, tag, 3);
+    }
 
   bgp_info_set_flag (rn, new, BGP_INFO_VALID);
 
diff --git a/bgpd/bgp_route.h b/bgpd/bgp_route.h
index e598797..c5066a2 100644
--- a/bgpd/bgp_route.h
+++ b/bgpd/bgp_route.h
@@ -76,6 +76,7 @@ struct bgp_info
 #define BGP_INFO_STALE          (1 << 8)
 #define BGP_INFO_REMOVED        (1 << 9)
 #define BGP_INFO_COUNTED	(1 << 10)
+#define BGP_INFO_MPLS		(1 << 11)
 
   /* BGP route type.  This can be static, RIP, OSPF, BGP etc.  */
   u_char type;
diff --git a/bgpd/bgp_zebra.c b/bgpd/bgp_zebra.c
index 0b6ab45..f5a7fdf 100644
--- a/bgpd/bgp_zebra.c
+++ b/bgpd/bgp_zebra.c
@@ -36,6 +36,7 @@ Boston, MA 02111-1307, USA.  */
 #include "bgpd/bgp_nexthop.h"
 #include "bgpd/bgp_zebra.h"
 #include "bgpd/bgp_fsm.h"
+#include "bgpd/bgp_mplsvpn.h"
 #include "bgpd/bgp_debug.h"
 
 /* All information about zebra. */
@@ -230,73 +231,52 @@ bgp_interface_address_delete (int command, struct zclient *zclient,
 static int
 zebra_read_ipv4 (int command, struct zclient *zclient, zebra_size_t length)
 {
-  struct stream *s;
   struct zapi_ipv4 api;
   unsigned long ifindex;
   struct in_addr nexthop;
   struct prefix_ipv4 p;
+  int i;
 
-  s = zclient->ibuf;
-  ifindex = 0;
-  nexthop.s_addr = 0;
-
-  /* Type, flags, message. */
-  api.type = stream_getc (s);
-  api.flags = stream_getc (s);
-  api.message = stream_getc (s);
-
-  /* IPv4 prefix. */
-  memset (&p, 0, sizeof (struct prefix_ipv4));
-  p.family = AF_INET;
-  p.prefixlen = stream_getc (s);
-  stream_get (&p.prefix, s, PSIZE (p.prefixlen));
-
-  /* Nexthop, ifindex, distance, metric. */
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
-    {
-      api.nexthop_num = stream_getc (s);
-      nexthop.s_addr = stream_get_ipv4 (s);
-    }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_IFINDEX))
+  zapi_ipv4_route_read (zclient, length, &api, &p);
+  for (i = 0; i < api.nexthop_num; i++)
     {
-      api.ifindex_num = stream_getc (s);
-      ifindex = stream_getl (s);
-    }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))
-    api.distance = stream_getc (s);
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))
-    api.metric = stream_getl (s);
-  else
-    api.metric = 0;
+      ifindex = 0;
+      nexthop.s_addr = 0;
+      if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IPV4))
+        nexthop.s_addr = api.nexthop[i].gw.ipv4.s_addr;
 
-  if (command == ZEBRA_IPV4_ROUTE_ADD)
-    {
-      if (BGP_DEBUG(zebra, ZEBRA))
-	{
-	  char buf[2][INET_ADDRSTRLEN];
-	  zlog_debug("Zebra rcvd: IPv4 route add %s %s/%d nexthop %s metric %u",
-		     zebra_route_string(api.type),
-		     inet_ntop(AF_INET, &p.prefix, buf[0], sizeof(buf[0])),
-		     p.prefixlen,
-		     inet_ntop(AF_INET, &nexthop, buf[1], sizeof(buf[1])),
-		     api.metric);
-	}
-      bgp_redistribute_add((struct prefix *)&p, &nexthop, api.metric, api.type);
-    }
-  else
-    {
-      if (BGP_DEBUG(zebra, ZEBRA))
-	{
-	  char buf[2][INET_ADDRSTRLEN];
-	  zlog_debug("Zebra rcvd: IPv4 route delete %s %s/%d "
-		     "nexthop %s metric %u",
-		     zebra_route_string(api.type),
-		     inet_ntop(AF_INET, &p.prefix, buf[0], sizeof(buf[0])),
-		     p.prefixlen,
-		     inet_ntop(AF_INET, &nexthop, buf[1], sizeof(buf[1])),
-		     api.metric);
-	}
-      bgp_redistribute_delete((struct prefix *)&p, api.type);
+      if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IFINDEX))
+        ifindex = api.nexthop[i].intf.index;
+
+      if (command == ZEBRA_IPV4_ROUTE_ADD)
+        {
+          if (BGP_DEBUG(zebra, ZEBRA))
+	    {
+	      char buf[2][INET_ADDRSTRLEN];
+	      zlog_debug("Zebra rcvd: IPv4 route add %s %s/%d nexthop %s metric %u",
+		         zebra_route_string(api.type),
+		         inet_ntop(AF_INET, &p.prefix, buf[0], sizeof(buf[0])),
+		         p.prefixlen,
+		         inet_ntop(AF_INET, &nexthop, buf[1], sizeof(buf[1])),
+		         api.metric);
+	    }
+          bgp_redistribute_add((struct prefix *)&p, &nexthop, api.metric, api.type);
+        }
+      else
+        {
+          if (BGP_DEBUG(zebra, ZEBRA))
+	    {
+	      char buf[2][INET_ADDRSTRLEN];
+	      zlog_debug("Zebra rcvd: IPv4 route delete %s %s/%d "
+		         "nexthop %s metric %u",
+		         zebra_route_string(api.type),
+		         inet_ntop(AF_INET, &p.prefix, buf[0], sizeof(buf[0])),
+		         p.prefixlen,
+		         inet_ntop(AF_INET, &nexthop, buf[1], sizeof(buf[1])),
+		         api.metric);
+	    }
+          bgp_redistribute_delete((struct prefix *)&p, api.type);
+        }
     }
 
   return 0;
@@ -307,80 +287,61 @@ zebra_read_ipv4 (int command, struct zclient *zclient, zebra_size_t length)
 static int
 zebra_read_ipv6 (int command, struct zclient *zclient, zebra_size_t length)
 {
-  struct stream *s;
   struct zapi_ipv6 api;
   unsigned long ifindex;
   struct in6_addr nexthop;
   struct prefix_ipv6 p;
+  int i;
 
-  s = zclient->ibuf;
-  ifindex = 0;
-  memset (&nexthop, 0, sizeof (struct in6_addr));
-
-  /* Type, flags, message. */
-  api.type = stream_getc (s);
-  api.flags = stream_getc (s);
-  api.message = stream_getc (s);
-
-  /* IPv6 prefix. */
-  memset (&p, 0, sizeof (struct prefix_ipv6));
-  p.family = AF_INET6;
-  p.prefixlen = stream_getc (s);
-  stream_get (&p.prefix, s, PSIZE (p.prefixlen));
-
-  /* Nexthop, ifindex, distance, metric. */
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
-    {
-      api.nexthop_num = stream_getc (s);
-      stream_get (&nexthop, s, 16);
-    }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_IFINDEX))
-    {
-      api.ifindex_num = stream_getc (s);
-      ifindex = stream_getl (s);
-    }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))
-    api.distance = stream_getc (s);
-  else
-    api.distance = 0;
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))
-    api.metric = stream_getl (s);
-  else
-    api.metric = 0;
+  zapi_ipv6_route_read (zclient, length, &api, &p);
 
   /* Simply ignore link-local address. */
   if (IN6_IS_ADDR_LINKLOCAL (&p.prefix))
     return 0;
 
-  if (command == ZEBRA_IPV6_ROUTE_ADD)
+  for (i = 0; i < api.nexthop_num; i++)
     {
-      if (BGP_DEBUG(zebra, ZEBRA))
-	{
-	  char buf[INET6_ADDRSTRLEN];
-	  zlog_debug("Zebra rcvd: IPv6 route add %s %s/%d metric %u",
-		     zebra_route_string(api.type),
-		     inet_ntop(AF_INET6, &p.prefix, buf, sizeof(buf)),
-		     p.prefixlen, api.metric);
-	}
-      bgp_redistribute_add ((struct prefix *)&p, NULL, api.metric, api.type);
-    }
-  else
-    {
-      if (BGP_DEBUG(zebra, ZEBRA))
-	{
-	  char buf[INET6_ADDRSTRLEN];
-	  zlog_debug("Zebra rcvd: IPv6 route delete %s %s/%d metric %u",
-		     zebra_route_string(api.type),
-		     inet_ntop(AF_INET6, &p.prefix, buf, sizeof(buf)),
-		     p.prefixlen, api.metric);
-	}
-      bgp_redistribute_delete ((struct prefix *) &p, api.type);
+
+      ifindex = 0;
+      memset (&nexthop, 0, sizeof (struct in6_addr));
+
+      if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IPV6))
+        memcpy(&nexthop, &api.nexthop[i].gw.ipv6, 16);
+
+      if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IFINDEX))
+        ifindex = api.nexthop[i].intf.index;
+
+      if (command == ZEBRA_IPV6_ROUTE_ADD)
+        {
+          if (BGP_DEBUG(zebra, ZEBRA))
+	    {
+	      char buf[INET6_ADDRSTRLEN];
+	      zlog_debug("Zebra rcvd: IPv6 route add %s %s/%d metric %u",
+		         zebra_route_string(api.type),
+		         inet_ntop(AF_INET6, &p.prefix, buf, sizeof(buf)),
+		         p.prefixlen, api.metric);
+	    }
+          bgp_redistribute_add ((struct prefix *)&p, NULL, api.metric, api.type);
+        }
+      else
+        {
+          if (BGP_DEBUG(zebra, ZEBRA))
+	    {
+	      char buf[INET6_ADDRSTRLEN];
+	      zlog_debug("Zebra rcvd: IPv6 route delete %s %s/%d metric %u",
+		         zebra_route_string(api.type),
+		         inet_ntop(AF_INET6, &p.prefix, buf, sizeof(buf)),
+		         p.prefixlen, api.metric);
+	    }
+          bgp_redistribute_delete ((struct prefix *) &p, api.type);
+        }
     }
   
   return 0;
 }
 #endif /* HAVE_IPV6 */
 
+
 struct interface *
 if_lookup_by_ipv4 (struct in_addr *addr)
 {
@@ -708,10 +669,19 @@ bgp_zebra_announce (struct prefix *p, struct bgp_info *info, struct bgp *bgp)
 
       api.type = ZEBRA_ROUTE_BGP;
       api.message = 0;
+
       SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
       api.nexthop_num = 1;
-      api.nexthop = &nexthop;
-      api.ifindex_num = 0;
+      api.nexthop[0].type = ZEBRA_NEXTHOP_IPV4;
+      api.nexthop[0].gw.ipv4 = info->attr->nexthop;
+#ifdef HAVE_MPLS
+      if (CHECK_FLAG (info->flags, BGP_INFO_MPLS))
+        {
+          SET_FLAG (api.nexthop[0].type, ZEBRA_NEXTHOP_MPLS);
+          api.nexthop[0].mpls.type = ZEBRA_MPLS_LABEL_GEN;
+          api.nexthop[0].mpls.u.gen = decode_label(info->extra->tag);
+        }
+#endif
       SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);
       api.metric = info->attr->med;
 
@@ -782,12 +752,20 @@ bgp_zebra_announce (struct prefix *p, struct bgp_info *info, struct bgp *bgp)
       api.flags = flags;
       api.type = ZEBRA_ROUTE_BGP;
       api.message = 0;
+
       SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
       api.nexthop_num = 1;
-      api.nexthop = &nexthop;
-      SET_FLAG (api.message, ZAPI_MESSAGE_IFINDEX);
-      api.ifindex_num = 1;
-      api.ifindex = &ifindex;
+      api.nexthop[0].type = ZEBRA_NEXTHOP_IPV6|ZEBRA_NEXTHOP_IFINDEX;
+      memcpy(&api.nexthop[0].gw.ipv6, nexthop, sizeof(*nexthop));
+      api.nexthop[0].intf.index = ifindex;
+#ifdef HAVE_MPLS
+      if (CHECK_FLAG (info->flags, BGP_INFO_MPLS))
+        {
+          SET_FLAG (api.nexthop[0].type, ZEBRA_NEXTHOP_MPLS);
+          api.nexthop[0].mpls.type = ZEBRA_MPLS_LABEL_GEN;
+          api.nexthop[0].mpls.u.gen = decode_label(info->extra->tag);
+        }
+#endif
       SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);
       api.metric = info->attr->med;
 
@@ -842,10 +820,19 @@ bgp_zebra_withdraw (struct prefix *p, struct bgp_info *info)
 
       api.type = ZEBRA_ROUTE_BGP;
       api.message = 0;
+
       SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
       api.nexthop_num = 1;
-      api.nexthop = &nexthop;
-      api.ifindex_num = 0;
+      api.nexthop[0].type = ZEBRA_NEXTHOP_IPV4;
+      api.nexthop[0].gw.ipv4 = info->attr->nexthop;
+#ifdef HAVE_MPLS
+      if (CHECK_FLAG (info->flags, BGP_INFO_MPLS))
+        {
+          SET_FLAG (api.nexthop[0].type, ZEBRA_NEXTHOP_MPLS);
+          api.nexthop[0].mpls.type = ZEBRA_MPLS_LABEL_GEN;
+          api.nexthop[0].mpls.u.gen = decode_label(info->extra->tag);
+        }
+#endif
       SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);
       api.metric = info->attr->med;
 
@@ -897,12 +884,20 @@ bgp_zebra_withdraw (struct prefix *p, struct bgp_info *info)
       api.flags = flags;
       api.type = ZEBRA_ROUTE_BGP;
       api.message = 0;
+
       SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
       api.nexthop_num = 1;
-      api.nexthop = &nexthop;
-      SET_FLAG (api.message, ZAPI_MESSAGE_IFINDEX);
-      api.ifindex_num = 1;
-      api.ifindex = &ifindex;
+      api.nexthop[0].type = ZEBRA_NEXTHOP_IPV6|ZEBRA_NEXTHOP_IFINDEX;
+      memcpy(&api.nexthop[0].gw.ipv6, nexthop, sizeof(*nexthop));
+      api.nexthop[0].intf.index = ifindex;
+#ifdef HAVE_MPLS
+      if (CHECK_FLAG (info->flags, BGP_INFO_MPLS))
+        {
+          SET_FLAG (api.nexthop[0].type, ZEBRA_NEXTHOP_MPLS);
+          api.nexthop[0].mpls.type = ZEBRA_MPLS_LABEL_GEN;
+          api.nexthop[0].mpls.u.gen = decode_label(info->extra->tag);
+        }
+#endif
       SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);
       api.metric = info->attr->med;
 
diff --git a/configure.ac b/configure.ac
index 5744fe0..9b50277 100755
--- a/configure.ac
+++ b/configure.ac
@@ -179,10 +179,16 @@ dnl Packages configuration
 dnl ----------------------
 AC_ARG_ENABLE(vtysh,
 [  --enable-vtysh          include integrated vty shell for Quagga])
+AC_ARG_ENABLE(mpls,
+[  --enable-mpls           turn on MPLS related features and daemons])
 AC_ARG_ENABLE(ipv6,
 [  --disable-ipv6          turn off IPv6 related features and daemons])
 AC_ARG_ENABLE(zebra,
 [  --disable-zebra         do not build zebra daemon])
+AC_ARG_ENABLE(ldpd,
+[  --disable-ldpd          do not build ldpd])
+AC_ARG_ENABLE(rsvpd,
+[  --disable-rsvpd         do not build rsvpd])
 AC_ARG_ENABLE(bgpd,
 [  --disable-bgpd          do not build bgpd])
 AC_ARG_ENABLE(ripd,
@@ -700,7 +706,7 @@ AC_MSG_CHECKING(zebra between kernel interface method)
 if test x"$opsys" = x"gnu-linux"; then
   if test "${enable_netlink}" = "yes";then
     AC_MSG_RESULT(netlink)
-    RT_METHOD=rt_netlink.o
+    RT_METHOD="netlink.o rt_netlink.o"
     AC_DEFINE(HAVE_NETLINK,,netlink)
     netlink=yes
   elif test "${enable_netlink}" = "no"; then
@@ -709,7 +715,7 @@ if test x"$opsys" = x"gnu-linux"; then
     netlink=no
   else
     AC_MSG_RESULT(netlink)
-    RT_METHOD=rt_netlink.o
+    RT_METHOD="netlink.o rt_netlink.o"
     AC_DEFINE(HAVE_NETLINK,,netlink)
     netlink=yes
   fi
@@ -1115,6 +1121,39 @@ QUAGGA_INCLUDES
 #endif
 ])dnl
 
+dnl ----------
+dnl MPLS check
+dnl ----------
+MPLS_METHOD=""
+AC_MSG_CHECKING(whether this OS has MPLS stack)
+AM_CONDITIONAL(MPLS_ENABLED, test "x${enable_mpls}" != "xno")
+if test "${enable_mpls}" = "no"; then
+  enable_ldpd="no"
+  enable_rsvpd="no"
+  AC_MSG_RESULT(disabled)
+else
+  if test "x${enable_mpls}" = "xnull"; then
+    AC_DEFINE(HAVE_MPLS,1,Enable MPLS)
+    MPLS_METHOD="mpls_null.o"
+    AC_MSG_RESULT(MPLS Null)
+  else
+    AC_EGREP_CPP(yes, [
+	#include <linux/mpls.h>
+	#if MPLS_LINUX_VERSION
+	yes
+	#endif],
+	[AC_DEFINE(HAVE_MPLS,1,Enable MPLS)
+	 AC_DEFINE(LINUX_MPLS,1,Linux MPLS)
+	 MPLS_METHOD="mpls_netlink.o"
+	 AC_MSG_RESULT(MPLS Linux)],
+	[enable_ldpd="no"
+	 enable_rsvpd="no"
+	 AC_MSG_RESULT(no)]
+    )
+  fi
+fi
+AC_SUBST(MPLS_METHOD)
+
 dnl --------------------
 dnl Daemon disable check
 dnl --------------------
@@ -1142,6 +1181,18 @@ else
   OSPFD="ospfd"
 fi
 
+if test "${enable_ldpd}" = "no";then
+  LDPD=""
+else
+  LDPD="ldpd"
+fi
+
+if test "${enable_rsvpd}" = "no";then
+  RSVPD=""
+else
+  RSVPD="rsvpd"
+fi
+
 if test "${enable_watchquagga}" = "no";then
   WATCHQUAGGA=""
 else
@@ -1157,7 +1208,6 @@ if test "${enable_opaque_lsa}" = "yes"; then
       OSPFCLIENT="ospfclient"
     fi
   fi
-
 fi
 
 case "${enable_ripngd}" in
@@ -1191,6 +1241,8 @@ fi
 
 AC_SUBST(ZEBRA)
 AC_SUBST(BGPD)
+AC_SUBST(LDPD)
+AC_SUBST(RSVPD)
 AC_SUBST(RIPD)
 AC_SUBST(RIPNGD)
 AC_SUBST(OSPFD)
@@ -1406,6 +1458,8 @@ fi
 AC_DEFINE_UNQUOTED(PATH_ZEBRA_PID, "$quagga_statedir/zebra.pid",zebra PID)
 AC_DEFINE_UNQUOTED(PATH_RIPD_PID, "$quagga_statedir/ripd.pid",ripd PID)
 AC_DEFINE_UNQUOTED(PATH_RIPNGD_PID, "$quagga_statedir/ripngd.pid",ripngd PID)
+AC_DEFINE_UNQUOTED(PATH_LDPD_PID, "$quagga_statedir/ldpd.pid",ldpd PID)
+AC_DEFINE_UNQUOTED(PATH_RSVPD_PID, "$quagga_statedir/rsvpd.pid",rsvpd PID)
 AC_DEFINE_UNQUOTED(PATH_BGPD_PID, "$quagga_statedir/bgpd.pid",bgpd PID)
 AC_DEFINE_UNQUOTED(PATH_OSPFD_PID, "$quagga_statedir/ospfd.pid",ospfd PID)
 AC_DEFINE_UNQUOTED(PATH_OSPF6D_PID, "$quagga_statedir/ospf6d.pid",ospf6d PID)
@@ -1415,6 +1469,8 @@ AC_DEFINE_UNQUOTED(ZEBRA_SERV_PATH, "$quagga_statedir/zserv.api",zebra api socke
 AC_DEFINE_UNQUOTED(ZEBRA_VTYSH_PATH, "$quagga_statedir/zebra.vty",zebra vty socket)
 AC_DEFINE_UNQUOTED(RIP_VTYSH_PATH, "$quagga_statedir/ripd.vty",rip vty socket)
 AC_DEFINE_UNQUOTED(RIPNG_VTYSH_PATH, "$quagga_statedir/ripngd.vty",ripng vty socket)
+AC_DEFINE_UNQUOTED(LDP_VTYSH_PATH, "$quagga_statedir/ldpd.vty",ldpd vty socket)
+AC_DEFINE_UNQUOTED(RSVP_VTYSH_PATH, "$quagga_statedir/rsvpd.vty",rsvpd vty socket)
 AC_DEFINE_UNQUOTED(BGP_VTYSH_PATH, "$quagga_statedir/bgpd.vty",bgpd vty socket)
 AC_DEFINE_UNQUOTED(OSPF_VTYSH_PATH, "$quagga_statedir/ospfd.vty",ospfd vty socket)
 AC_DEFINE_UNQUOTED(OSPF6_VTYSH_PATH, "$quagga_statedir/ospf6d.vty",ospf6d vty socket)
@@ -1442,6 +1498,8 @@ AC_MSG_RESULT($ac_cv_htonl_works)
 
 AC_CONFIG_FILES([Makefile lib/Makefile zebra/Makefile ripd/Makefile 
 	  ripngd/Makefile bgpd/Makefile ospfd/Makefile watchquagga/Makefile
+	  ldpd/Makefile
+	  rsvpd/Makefile
 	  ospf6d/Makefile isisd/Makefile vtysh/Makefile doc/Makefile 
 	  ospfclient/Makefile tests/Makefile m4/Makefile redhat/Makefile
 	  pkgsrc/Makefile
diff --git a/isisd/isis_zebra.c b/isisd/isis_zebra.c
index 9ee5ffc..b9b7859 100644
--- a/isisd/isis_zebra.c
+++ b/isisd/isis_zebra.c
@@ -337,12 +337,10 @@ isis_zebra_route_add_ipv6 (struct prefix *prefix,
 			   struct isis_route_info *route_info)
 {
   struct zapi_ipv6 api;
-  struct in6_addr **nexthop_list;
-  unsigned int *ifindex_list;
   struct isis_nexthop6 *nexthop6;
-  int i, size;
   struct listnode *node;
   struct prefix_ipv6 prefix6;
+  int i;
 
   if (CHECK_FLAG (route_info->flag, ISIS_ROUTE_FLAG_ZEBRA_SYNC))
     return;
@@ -350,35 +348,13 @@ isis_zebra_route_add_ipv6 (struct prefix *prefix,
   api.type = ZEBRA_ROUTE_ISIS;
   api.flags = 0;
   api.message = 0;
-  SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
-  SET_FLAG (api.message, ZAPI_MESSAGE_IFINDEX);
+
   SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);
   api.metric = route_info->cost;
 #if 0
   SET_FLAG (api.message, ZAPI_MESSAGE_DISTANCE);
   api.distance = route_info->depth;
 #endif
-  api.nexthop_num = listcount (route_info->nexthops6);
-  api.ifindex_num = listcount (route_info->nexthops6);
-
-  /* allocate memory for nexthop_list */
-  size = sizeof (struct isis_nexthop6 *) * listcount (route_info->nexthops6);
-  nexthop_list = (struct in6_addr **) XMALLOC (MTYPE_ISIS_TMP, size);
-  if (!nexthop_list)
-    {
-      zlog_err ("isis_zebra_add_route_ipv6: out of memory!");
-      return;
-    }
-
-  /* allocate memory for ifindex_list */
-  size = sizeof (unsigned int) * listcount (route_info->nexthops6);
-  ifindex_list = (unsigned int *) XMALLOC (MTYPE_ISIS_TMP, size);
-  if (!ifindex_list)
-    {
-      zlog_err ("isis_zebra_add_route_ipv6: out of memory!");
-      XFREE (MTYPE_ISIS_TMP, nexthop_list);
-      return;
-    }
 
   /* for each nexthop */
   i = 0;
@@ -386,21 +362,18 @@ isis_zebra_route_add_ipv6 (struct prefix *prefix,
     {
       if (!IN6_IS_ADDR_LINKLOCAL (&nexthop6->ip6) &&
 	  !IN6_IS_ADDR_UNSPECIFIED (&nexthop6->ip6))
-	{
-	  api.nexthop_num--;
-	  api.ifindex_num--;
-	  continue;
-	}
+        continue;
 
-      nexthop_list[i] = &nexthop6->ip6;
-      ifindex_list[i] = nexthop6->ifindex;
+      SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
+      api.nexthop[i].type = ZEBRA_NEXTHOP_IPV6|ZEBRA_NEXTHOP_IFINDEX;
+      memcpy (&api.nexthop[i].gw.ipv6, &nexthop6->ip6, 16);
+      api.nexthop[i].intf.index = nexthop6->ifindex;
       i++;
     }
 
-  api.nexthop = nexthop_list;
-  api.ifindex = ifindex_list;
+  api.nexthop_num = i;
 
-  if (api.nexthop_num && api.ifindex_num)
+  if (api.nexthop_num)
     {
       prefix6.family = AF_INET6;
       prefix6.prefixlen = prefix->prefixlen;
@@ -409,9 +382,6 @@ isis_zebra_route_add_ipv6 (struct prefix *prefix,
       SET_FLAG (route_info->flag, ISIS_ROUTE_FLAG_ZEBRA_SYNC);
     }
 
-  XFREE (MTYPE_ISIS_TMP, nexthop_list);
-  XFREE (MTYPE_ISIS_TMP, ifindex_list);
-
   return;
 }
 
@@ -420,12 +390,10 @@ isis_zebra_route_del_ipv6 (struct prefix *prefix,
 			   struct isis_route_info *route_info)
 {
   struct zapi_ipv6 api;
-  struct in6_addr **nexthop_list;
-  unsigned int *ifindex_list;
   struct isis_nexthop6 *nexthop6;
-  int i, size;
   struct listnode *node;
   struct prefix_ipv6 prefix6;
+  int i;
 
   if (CHECK_FLAG (route_info->flag, ISIS_ROUTE_FLAG_ZEBRA_SYNC))
     return;
@@ -433,29 +401,6 @@ isis_zebra_route_del_ipv6 (struct prefix *prefix,
   api.type = ZEBRA_ROUTE_ISIS;
   api.flags = 0;
   api.message = 0;
-  SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
-  SET_FLAG (api.message, ZAPI_MESSAGE_IFINDEX);
-  api.nexthop_num = listcount (route_info->nexthops6);
-  api.ifindex_num = listcount (route_info->nexthops6);
-
-  /* allocate memory for nexthop_list */
-  size = sizeof (struct isis_nexthop6 *) * listcount (route_info->nexthops6);
-  nexthop_list = (struct in6_addr **) XMALLOC (MTYPE_ISIS_TMP, size);
-  if (!nexthop_list)
-    {
-      zlog_err ("isis_zebra_route_del_ipv6: out of memory!");
-      return;
-    }
-
-  /* allocate memory for ifindex_list */
-  size = sizeof (unsigned int) * listcount (route_info->nexthops6);
-  ifindex_list = (unsigned int *) XMALLOC (MTYPE_ISIS_TMP, size);
-  if (!ifindex_list)
-    {
-      zlog_err ("isis_zebra_route_del_ipv6: out of memory!");
-      XFREE (MTYPE_ISIS_TMP, nexthop_list);
-      return;
-    }
 
   /* for each nexthop */
   i = 0;
@@ -463,21 +408,16 @@ isis_zebra_route_del_ipv6 (struct prefix *prefix,
     {
       if (!IN6_IS_ADDR_LINKLOCAL (&nexthop6->ip6) &&
 	  !IN6_IS_ADDR_UNSPECIFIED (&nexthop6->ip6))
-	{
-	  api.nexthop_num--;
-	  api.ifindex_num--;
-	  continue;
-	}
+	continue;
 
-      nexthop_list[i] = &nexthop6->ip6;
-      ifindex_list[i] = nexthop6->ifindex;
+      SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
+      api.nexthop[i].type = ZEBRA_NEXTHOP_IPV6|ZEBRA_NEXTHOP_IFINDEX;
+      memcpy (&api.nexthop[i].gw.ipv6, &nexthop6->ip6, 16);
+      api.nexthop[i].intf.index = nexthop6->ifindex;
       i++;
     }
 
-  api.nexthop = nexthop_list;
-  api.ifindex = ifindex_list;
-
-  if (api.nexthop_num && api.ifindex_num)
+  if (api.nexthop_num)
     {
       prefix6.family = AF_INET6;
       prefix6.prefixlen = prefix->prefixlen;
@@ -485,9 +425,6 @@ isis_zebra_route_del_ipv6 (struct prefix *prefix,
       zapi_ipv6_route (ZEBRA_IPV6_ROUTE_DELETE, zclient, &prefix6, &api);
       UNSET_FLAG (route_info->flag, ISIS_ROUTE_FLAG_ZEBRA_SYNC);
     }
-
-  XFREE (MTYPE_ISIS_TMP, nexthop_list);
-  XFREE (MTYPE_ISIS_TMP, ifindex_list);
 }
 
 #endif /* HAVE_IPV6 */
@@ -527,45 +464,29 @@ static int
 isis_zebra_read_ipv4 (int command, struct zclient *zclient,
 		      zebra_size_t length)
 {
-  struct stream *stream;
   struct zapi_ipv4 api;
   struct prefix_ipv4 p;
   unsigned long ifindex;
   struct in_addr nexthop;
+  int i;
 
-  stream = zclient->ibuf;
-  memset (&p, 0, sizeof (struct prefix_ipv4));
-  ifindex = 0;
-
-  api.type = stream_getc (stream);
-  api.flags = stream_getc (stream);
-  api.message = stream_getc (stream);
+  zapi_ipv4_route(command, zclient, &p, &api);
 
-  p.family = AF_INET;
-  p.prefixlen = stream_getc (stream);
-  stream_get (&p.prefix, stream, PSIZE (p.prefixlen));
-
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
-    {
-      api.nexthop_num = stream_getc (stream);
-      nexthop.s_addr = stream_get_ipv4 (stream);
-    }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_IFINDEX))
-    {
-      api.ifindex_num = stream_getc (stream);
-      ifindex = stream_getl (stream);
-    }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))
-    api.distance = stream_getc (stream);
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))
-    api.metric = stream_getl (stream);
-  else
-    api.metric = 0;
-
-  if (command == ZEBRA_IPV4_ROUTE_ADD)
+  for (i = 0; i < api.nexthop_num; i++)
     {
-      if (isis->debugs & DEBUG_ZEBRA)
-	zlog_debug ("IPv4 Route add from Z");
+      ifindex = 0;
+      nexthop.s_addr = 0;
+      if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IPV4))
+        nexthop.s_addr = api.nexthop[i].gw.ipv4.s_addr;
+
+      if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IFINDEX))
+        ifindex = api.nexthop[i].intf.index;
+
+      if (command == ZEBRA_IPV4_ROUTE_ADD)
+        {
+          if (isis->debugs & DEBUG_ZEBRA)
+	    zlog_debug ("IPv4 Route add from Z");
+        }
     }
 
   return 0;
@@ -576,6 +497,36 @@ static int
 isis_zebra_read_ipv6 (int command, struct zclient *zclient,
 		      zebra_size_t length)
 {
+  struct zapi_ipv6 api;
+  struct prefix_ipv6 p;
+  unsigned long ifindex;
+  struct in_addr nexthop;
+  int i;
+
+  zapi_ipv6_route(command, zclient, &p, &api);
+
+  /* Simply ignore link-local address. */
+  if (IN6_IS_ADDR_LINKLOCAL (&p.prefix))
+    return 0;
+
+  for (i = 0; i < api.nexthop_num; i++)
+    {
+      ifindex = 0;
+      memset (&nexthop, 0, sizeof (struct in6_addr));
+
+      if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IPV6))
+        memcpy(&nexthop, &api.nexthop[i].gw.ipv6, 16);
+
+      if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IFINDEX))
+        ifindex = api.nexthop[i].intf.index;
+
+      if (command == ZEBRA_IPV6_ROUTE_ADD)
+        {
+          if (isis->debugs & DEBUG_ZEBRA)
+            zlog_debug ("IPv6 Route add from Z");
+        }
+    }
+
   return 0;
 }
 #endif
diff --git a/lib/command.c b/lib/command.c
index f3d96ed..77c3469 100644
--- a/lib/command.c
+++ b/lib/command.c
@@ -2385,9 +2385,15 @@ DEFUN (config_exit,
       vty->node = ENABLE_NODE;
       vty_config_unlock (vty);
       break;
+    case MPLS_LABELSPACE_NODE:
     case INTERFACE_NODE:
+    case TUNNEL_NODE:
+    case MPLS_TUNNEL_NODE:
+    case MPLS_TE_TUNNEL_NODE:
+    case MPLS_TE_TUNNEL_CONF_NODE:
     case ZEBRA_NODE:
     case BGP_NODE:
+    case LDP_NODE:
     case RIP_NODE:
     case RIPNG_NODE:
     case OSPF_NODE:
@@ -2409,6 +2415,9 @@ DEFUN (config_exit,
     case KEYCHAIN_KEY_NODE:
       vty->node = KEYCHAIN_NODE;
       break;
+    case LDP_IF_NODE:
+      vty->node = INTERFACE_NODE;
+      break;
     default:
       break;
     }
@@ -2434,10 +2443,17 @@ DEFUN (config_end,
       /* Nothing to do. */
       break;
     case CONFIG_NODE:
+    case MPLS_LABELSPACE_NODE:
     case INTERFACE_NODE:
+    case TUNNEL_NODE:
+    case MPLS_TUNNEL_NODE:
+    case MPLS_TE_TUNNEL_NODE:
+    case MPLS_TE_TUNNEL_CONF_NODE:
     case ZEBRA_NODE:
     case RIP_NODE:
     case RIPNG_NODE:
+    case LDP_NODE:
+    case LDP_IF_NODE:
     case BGP_NODE:
     case BGP_VPNV4_NODE:
     case BGP_IPV4_NODE:
diff --git a/lib/command.h b/lib/command.h
index a725378..de5e2cf 100644
--- a/lib/command.h
+++ b/lib/command.h
@@ -72,11 +72,18 @@ enum node_type
   AAA_NODE,			/* AAA node. */
   KEYCHAIN_NODE,		/* Key-chain node. */
   KEYCHAIN_KEY_NODE,		/* Key-chain key node. */
+  MPLS_LABELSPACE_NODE,		/* MPLS Labelspace node. */
   INTERFACE_NODE,		/* Interface mode node. */
+  TUNNEL_NODE,			/* Tunnel config node. */
+  MPLS_TUNNEL_NODE,		/* MPLS Tunnel config node. */
+  MPLS_TE_TUNNEL_NODE,
+  MPLS_TE_TUNNEL_CONF_NODE,
   ZEBRA_NODE,			/* zebra connection node. */
   TABLE_NODE,			/* rtm_table selection node. */
   RIP_NODE,			/* RIP protocol mode node. */ 
   RIPNG_NODE,			/* RIPng protocol mode node. */
+  LDP_NODE,			/* LDP protocol mode */
+  LDP_IF_NODE,			/* LDP interface mode */
   BGP_NODE,			/* BGP protocol mode which includes BGP4+ */
   BGP_VPNV4_NODE,		/* BGP MPLS-VPN PE exchange. */
   BGP_IPV4_NODE,		/* BGP IPv4 unicast address family.  */
diff --git a/lib/if.c b/lib/if.c
index db590f5..a5bd6f1 100644
--- a/lib/if.c
+++ b/lib/if.c
@@ -131,6 +131,7 @@ if_create (const char *name, int namelen)
 	     "name exists already!", ifp->name);
   ifp->connected = list_new ();
   ifp->connected->del = (void (*) (void *)) connected_free;
+  ifp->mpls_labelspace = -1;
 
   if (if_master.if_new_hook)
     (*if_master.if_new_hook) (ifp);
@@ -770,6 +771,30 @@ if_nametoindex (const char *name)
 }
 #endif
 
+struct interface *if_getfirst()
+{
+  struct listnode *node = listhead(iflist);
+  return listgetdata(node);
+}
+
+struct interface *if_getnext(struct interface *old)
+{
+  struct interface *ifp;
+  struct listnode *node;
+  int flag = 0;
+
+  for (node = listhead(iflist); node; listnextnode(node)) {
+    ifp = listgetdata(node);
+    if (flag) {
+      return ifp;
+    }
+    if (ifp->ifindex == old->ifindex) {
+      flag = 1;
+    }
+  }
+  return NULL;
+}
+
 #ifndef HAVE_IF_INDEXTONAME
 char *
 if_indextoname (unsigned int ifindex, char *name)
diff --git a/lib/if.h b/lib/if.h
index c99ab81..e007203 100644
--- a/lib/if.h
+++ b/lib/if.h
@@ -133,6 +133,7 @@ struct interface
 #ifdef HAVE_NET_RT_IFLIST
   struct if_data stats;
 #endif /* HAVE_NET_RT_IFLIST */
+  int mpls_labelspace;
 };
 
 /* Connected address structure. */
@@ -291,6 +292,9 @@ extern struct connected  *connected_delete_by_prefix (struct interface *,
 extern struct connected  *connected_lookup_address (struct interface *, 
                                              struct in_addr);
 
+extern struct interface *if_getfirst();
+extern struct interface *if_getnext(struct interface*);
+
 #ifndef HAVE_IF_NAMETOINDEX
 extern unsigned int if_nametoindex (const char *);
 #endif
diff --git a/lib/log.c b/lib/log.c
index ce00bfb..df65a2b 100644
--- a/lib/log.c
+++ b/lib/log.c
@@ -42,6 +42,8 @@ const char *zlog_proto_names[] =
   "ZEBRA",
   "RIP",
   "BGP",
+  "LDP",
+  "RSVP",
   "OSPF",
   "RIPNG",
   "OSPF6",
@@ -820,6 +822,9 @@ static const struct zebra_desc_table route_types[] = {
   DESC_ENTRY	(ZEBRA_ROUTE_ISIS,	"isis",		'I' ),
   DESC_ENTRY	(ZEBRA_ROUTE_BGP,	"bgp",		'B' ),
   DESC_ENTRY	(ZEBRA_ROUTE_HSLS,	"hsls",		'H' ),
+  DESC_ENTRY	(ZEBRA_ROUTE_LDP,	"ldp",		'L' ),
+  DESC_ENTRY	(ZEBRA_ROUTE_RSVP,	"rsvp",		'r' ),
+  DESC_ENTRY	(ZEBRA_ROUTE_TE,	"te",		't' ),
 };
 #undef DESC_ENTRY
 
@@ -847,6 +852,16 @@ static const struct zebra_desc_table command_types[] = {
   DESC_ENTRY	(ZEBRA_ROUTER_ID_ADD),
   DESC_ENTRY	(ZEBRA_ROUTER_ID_DELETE),
   DESC_ENTRY	(ZEBRA_ROUTER_ID_UPDATE),
+  DESC_ENTRY	(ZEBRA_MPLS_XC_ADD),
+  DESC_ENTRY	(ZEBRA_MPLS_XC_DELETE),
+  DESC_ENTRY	(ZEBRA_MPLS_IN_SEGMENT_ADD),
+  DESC_ENTRY	(ZEBRA_MPLS_IN_SEGMENT_DELETE),
+  DESC_ENTRY	(ZEBRA_MPLS_OUT_SEGMENT_ADD),
+  DESC_ENTRY	(ZEBRA_MPLS_OUT_SEGMENT_DELETE),
+  DESC_ENTRY	(ZEBRA_MPLS_LABELSPACE_ADD),
+  DESC_ENTRY	(ZEBRA_MPLS_LABELSPACE_DELETE),
+  DESC_ENTRY	(ZEBRA_MPLS_FTN_ADD),
+  DESC_ENTRY	(ZEBRA_MPLS_FTN_DELETE),
 };
 #undef DESC_ENTRY
 
diff --git a/lib/log.h b/lib/log.h
index 7432b25..fabd079 100644
--- a/lib/log.h
+++ b/lib/log.h
@@ -50,6 +50,8 @@ typedef enum
   ZLOG_ZEBRA,
   ZLOG_RIP,
   ZLOG_BGP,
+  ZLOG_LDP,
+  ZLOG_RSVP,
   ZLOG_OSPF,
   ZLOG_RIPNG,  
   ZLOG_OSPF6,
diff --git a/lib/memtypes.c b/lib/memtypes.c
index f1b10e7..c8f5a24 100644
--- a/lib/memtypes.c
+++ b/lib/memtypes.c
@@ -83,8 +83,8 @@ struct memory_list memory_list_zebra[] =
   { MTYPE_NEXTHOP,		"Nexthop"			},
   { MTYPE_RIB,			"RIB"				},
   { MTYPE_RIB_QUEUE,		"RIB process work queue"	},
-  { MTYPE_STATIC_IPV4,		"Static IPv4 route"		},
-  { MTYPE_STATIC_IPV6,		"Static IPv6 route"		},
+  { MTYPE_STATIC_ROUTE,		"Static route"			},
+  { MTYPE_TE,			"Traffic Engineering"		},
   { -1, NULL },
 };
 
@@ -242,6 +242,18 @@ struct memory_list memory_list_isis[] =
   { -1, NULL },
 };
 
+struct memory_list memory_list_ldp[] =
+{
+  { MTYPE_LDP,                "LDP"				},
+  { -1, NULL },
+};
+
+struct memory_list memory_list_rsvp[] =
+{
+  { MTYPE_RSVP,               "RSVP"				},
+  { -1, NULL },
+};
+
 struct memory_list memory_list_vtysh[] =
 {
   { MTYPE_VTYSH_CONFIG,		"Vtysh configuration",		},
@@ -258,5 +270,7 @@ struct mlist mlists[] __attribute__ ((unused)) = {
   { memory_list_ospf6,	"OSPF6"	},
   { memory_list_isis,	"ISIS"	},
   { memory_list_bgp,	"BGP"	},
+  { memory_list_ldp,	"LDP"	},
+  { memory_list_rsvp,	"RSVP"	},
   { NULL, NULL},
 };
diff --git a/lib/stream.c b/lib/stream.c
index 983330f..bf8c9f1 100644
--- a/lib/stream.c
+++ b/lib/stream.c
@@ -449,6 +449,25 @@ stream_get_ipv4 (struct stream *s)
 
   return l;
 }
+
+/* Get next float from the stream. */
+float
+stream_getf_from (struct stream *s, size_t from)
+{
+  u_int32_t l = stream_getl_from (s, from);
+  float f;
+  ntohf ((float*)&l, &f);
+  return f;
+}
+
+float
+stream_getf (struct stream *s)
+{
+  u_int32_t l = stream_getl (s);
+  float f;
+  ntohf ((float*)&l, &f);
+  return f;
+}
 
 /* Copy to source to stream.
  *
@@ -688,6 +707,24 @@ stream_put_prefix (struct stream *s, struct prefix *p)
   
   return psize;
 }
+
+int
+stream_putf (struct stream *s, float f)
+{
+  u_int32_t l;
+  htonf(&f, (float *)&l);
+  stream_putl (s, l);
+  return 4;
+}
+
+int
+stream_putf_at (struct stream *s, size_t putp, float f)
+{
+  u_int32_t l;
+  htonf(&f, (float *)&l);
+  stream_putl_at (s, putp, l);
+  return 4;
+}
 
 /* Read size from fd. */
 int
@@ -969,3 +1006,25 @@ stream_fifo_free (struct stream_fifo *fifo)
   stream_fifo_clean (fifo);
   XFREE (MTYPE_STREAM_FIFO, fifo);
 }
+
+void
+htonf (float *src, float *dst)
+{
+  u_int32_t lu1, lu2;
+
+  memcpy (&lu1, src, sizeof (u_int32_t));
+  lu2 = htonl (lu1);
+  memcpy (dst, &lu2, sizeof (u_int32_t));
+  return;
+}
+
+void
+ntohf (float *src, float *dst)
+{
+  u_int32_t lu1, lu2;
+
+  memcpy (&lu1, src, sizeof (u_int32_t));
+  lu2 = ntohl (lu1);
+  memcpy (dst, &lu2, sizeof (u_int32_t));
+  return;
+}
diff --git a/lib/stream.h b/lib/stream.h
index 3e4ba7b..bb9088d 100644
--- a/lib/stream.h
+++ b/lib/stream.h
@@ -162,6 +162,8 @@ extern int stream_putq_at (struct stream *, size_t, uint64_t);
 extern int stream_put_ipv4 (struct stream *, u_int32_t);
 extern int stream_put_in_addr (struct stream *, struct in_addr *);
 extern int stream_put_prefix (struct stream *, struct prefix *);
+extern int stream_putf (struct stream *, float);
+extern int stream_putf_at (struct stream *, size_t, float);
 
 extern void stream_get (void *, struct stream *, size_t);
 extern u_char stream_getc (struct stream *);
@@ -173,6 +175,8 @@ extern u_int32_t stream_getl_from (struct stream *, size_t);
 extern uint64_t stream_getq (struct stream *);
 extern uint64_t stream_getq_from (struct stream *, size_t);
 extern u_int32_t stream_get_ipv4 (struct stream *);
+extern float stream_getf (struct stream *);
+extern float stream_getf_from (struct stream *, size_t);
 
 #undef stream_read
 #undef stream_write
@@ -218,4 +222,7 @@ extern struct stream *stream_fifo_head (struct stream_fifo *fifo);
 extern void stream_fifo_clean (struct stream_fifo *fifo);
 extern void stream_fifo_free (struct stream_fifo *fifo);
 
+extern void htonf (float *src, float *dst);
+extern void ntohf (float *src, float *dst);
+
 #endif /* _ZEBRA_STREAM_H */
diff --git a/lib/table.c b/lib/table.c
index 2ade71b..b9da952 100644
--- a/lib/table.c
+++ b/lib/table.c
@@ -311,6 +311,37 @@ route_node_lookup (struct route_table *table, struct prefix *p)
   return NULL;
 }
 
+struct route_node *
+route_node_lookup2 (struct route_table *table, struct prefix *p)
+{
+  struct route_node *rn_in, *rn_tmp;
+
+  if (!(rn_in = route_node_lookup(table,p))) {
+fprintf(stderr,"lookup2 is doing work\n");
+    /* walk as far down the tree as we can */
+    rn_in = table->top;
+    while (rn_in && rn_in->p.prefixlen <= p->prefixlen &&
+      prefix_match(&rn_in->p, p)) {
+      rn_tmp = rn_in->link[check_bit(&p->u.prefix, rn_in->p.prefixlen)];
+      if (!rn_tmp) {
+        break;
+      }
+      rn_in = rn_tmp;
+    }
+    route_lock_node(rn_in);
+
+    /* rn_in is either the actual node of the furthest node in the tree */
+    /* so get the 'next' one with 'info' */
+    rn_in = route_next2(rn_in);
+  }
+
+  if (rn_in && !rn_in->info) {
+    route_unlock_node(rn_in);
+    rn_in = NULL;
+  }
+  return rn_in;
+}
+
 /* Add node to routing table. */
 struct route_node *
 route_node_get (struct route_table *table, struct prefix *p)
@@ -461,6 +492,22 @@ route_next (struct route_node *node)
   return NULL;
 }
 
+struct route_node *
+route_next2 (struct route_node *rn_in)
+{
+  struct route_node *rn = rn_in;
+  struct route_node *rn2;
+  do {
+    rn2 = route_next(rn);
+    rn = rn2;
+  } while(rn && !rn->info);
+
+  if (rn && rn->info) {
+    return rn;
+  }
+  return NULL;
+}
+
 /* Unlock current node and lock next node until limit. */
 struct route_node *
 route_next_until (struct route_node *node, struct route_node *limit)
diff --git a/lib/table.h b/lib/table.h
index 45ec606..1858e0e 100644
--- a/lib/table.h
+++ b/lib/table.h
@@ -59,12 +59,15 @@ extern void route_unlock_node (struct route_node *node);
 extern void route_node_delete (struct route_node *node);
 extern struct route_node *route_top (struct route_table *);
 extern struct route_node *route_next (struct route_node *);
+extern struct route_node *route_next2 (struct route_node *);
 extern struct route_node *route_next_until (struct route_node *,
                                             struct route_node *);
 extern struct route_node *route_node_get (struct route_table *,
                                           struct prefix *);
 extern struct route_node *route_node_lookup (struct route_table *,
                                              struct prefix *);
+extern struct route_node *route_node_lookup2 (struct route_table *,
+                                              struct prefix *);
 extern struct route_node *route_lock_node (struct route_node *node);
 extern struct route_node *route_node_match (struct route_table *, 
                                             struct prefix *);
diff --git a/lib/thread.c b/lib/thread.c
index 095dff4..5ca0c07 100644
--- a/lib/thread.c
+++ b/lib/thread.c
@@ -416,10 +416,26 @@ thread_master_create ()
 					   sizeof (struct thread_master));
 }
 
+static int thread_in_list(struct thread_list *list, struct thread *thread)
+{
+  struct thread *tt;
+
+  for (tt = list->head; tt; tt = tt->next)
+  {
+    if (tt == thread)
+    {
+      return 1;
+    }
+  }
+  return 0;
+}
+
 /* Add a new thread to the list.  */
 static void
 thread_list_add (struct thread_list *list, struct thread *thread)
 {
+  assert(!thread_in_list(list,thread));
+
   thread->next = NULL;
   thread->prev = list->tail;
   if (list->tail)
@@ -436,6 +452,8 @@ thread_list_add_before (struct thread_list *list,
 			struct thread *point, 
 			struct thread *thread)
 {
+  assert(!thread_in_list(list,thread));
+
   thread->next = point;
   thread->prev = point->prev;
   if (point->prev)
@@ -450,6 +468,8 @@ thread_list_add_before (struct thread_list *list,
 static struct thread *
 thread_list_delete (struct thread_list *list, struct thread *thread)
 {
+  assert(thread_in_list(list,thread));
+
   if (thread->next)
     thread->next->prev = thread->prev;
   else
diff --git a/lib/vty.c b/lib/vty.c
index ccf6640..d94e2dd 100644
--- a/lib/vty.c
+++ b/lib/vty.c
@@ -690,10 +690,17 @@ vty_end_config (struct vty *vty)
       /* Nothing to do. */
       break;
     case CONFIG_NODE:
+    case MPLS_LABELSPACE_NODE:
     case INTERFACE_NODE:
+    case TUNNEL_NODE:
+    case MPLS_TUNNEL_NODE:
+    case MPLS_TE_TUNNEL_NODE:
+    case MPLS_TE_TUNNEL_CONF_NODE:
     case ZEBRA_NODE:
     case RIP_NODE:
     case RIPNG_NODE:
+    case LDP_NODE:
+    case LDP_IF_NODE:
     case BGP_NODE:
     case BGP_VPNV4_NODE:
     case BGP_IPV4_NODE:
@@ -1097,10 +1104,17 @@ vty_stop_input (struct vty *vty)
       /* Nothing to do. */
       break;
     case CONFIG_NODE:
+    case MPLS_LABELSPACE_NODE:
     case INTERFACE_NODE:
+    case TUNNEL_NODE:
+    case MPLS_TUNNEL_NODE:
+    case MPLS_TE_TUNNEL_NODE:
+    case MPLS_TE_TUNNEL_CONF_NODE:
     case ZEBRA_NODE:
     case RIP_NODE:
     case RIPNG_NODE:
+    case LDP_NODE:
+    case LDP_IF_NODE:
     case BGP_NODE:
     case RMAP_NODE:
     case OSPF_NODE:
diff --git a/lib/zclient.c b/lib/zclient.c
index 10e6b5f..af3cb9a 100644
--- a/lib/zclient.c
+++ b/lib/zclient.c
@@ -39,6 +39,11 @@ enum event {ZCLIENT_SCHEDULE, ZCLIENT_READ, ZCLIENT_CONNECT};
 /* Prototype for event manager. */
 static void zclient_event (enum event, struct zclient *);
 
+#ifdef HAVE_MPLS
+static void mpls_label_stream_write (struct stream *s, struct zmpls_label *label);
+static int mpls_label_stream_read (struct stream *s, struct zmpls_label *label);
+#endif
+
 extern struct thread_master *master;
 
 /* This file local debug flag. */
@@ -399,19 +404,52 @@ zclient_connect (struct thread *t)
   * +-+-+-+-+-+-+-+-+
   *
   * 
-  * A number of IPv4 nexthop(s) or nexthop interface index(es) are then 
-  * described, as per the Nexthop count. Each nexthop described as:
+  * A number of nexthop(s) are then  described, as per the Nexthop count.
+  * Each nexthop described as:
+  *
+  * +-+-+-+-+-+-+-+-+
+  * | Nexthop Flags |  Set to bitwise combination of ZEBRA_NEXTHOP_*
+  * +-+-+-+-+-+-+-+-+
+  *
+  * For each bit in "Nexthop Flags" one of the following is written
+  *
+  * +-+-+-+-+-+-+-+-+
+  * | NEXTHOP_IPV4  |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |       IPv4 Nexthop address                                    |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   *
   * +-+-+-+-+-+-+-+-+
-  * | Nexthop Type  |  Set to one of ZEBRA_NEXTHOP_*
+  * | NEXTHOP_IPV6  |
   * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-  * |       IPv4 Nexthop address or Interface Index number          |
+  * |       IPv6 Nexthop address                                    |
   * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *   ....
   *
-  * Alternatively, if the flags field has ZEBRA_FLAG_BLACKHOLE or
-  * ZEBRA_FLAG_REJECT is set then Nexthop count is set to 1, then _no_ 
-  * nexthop information is provided, and the message describes a prefix
-  * to blackhole or reject route.
+  * +-+-+-+-+-+-+-+-+
+  * |NEXTHOP_IFINDEX|
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |       Interface Index                                         |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *
+  * +-+-+-+-+-+-+-+-+
+  * |NEXTHOP_IFNAME |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |       Interface Name                                          |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  *   ....
+  *
+  * +-+-+-+-+-+-+-+-+
+  * | NEXTHOP_DROP  |
+  * +-+-+-+-+-+-+-+-+
+  * |  DROP type    |
+  * +-+-+-+-+-+-+-+-+
+  *
+  * +-+-+-+-+-+-+-+-+
+  * |NEXTHOP_MPLS   |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  * |       MPLS value                                              |
+  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   *
   * If ZAPI_MESSAGE_DISTANCE is set, the distance value is written as a 1
   * byte value.
@@ -421,16 +459,106 @@ zclient_connect (struct thread *t)
   *
   * XXX: No attention paid to alignment.
   */ 
+
+void
+zapi_nexthop_write(struct stream *s, struct zapi_nexthop *nh)
+{
+  stream_putc (s, nh->type);    
+  if (CHECK_FLAG (nh->type, ZEBRA_NEXTHOP_DROP))
+    {
+      stream_putc (s, ZEBRA_NEXTHOP_DROP);
+      stream_putc (s, nh->gw.drop);
+      return;
+    }
+
+  if (CHECK_FLAG (nh->type, ZEBRA_NEXTHOP_IPV4))
+    {
+      stream_putc (s, ZEBRA_NEXTHOP_IPV4);
+      stream_put_in_addr (s, &nh->gw.ipv4);
+    }
+#ifdef HAVE_IPV6
+  if (CHECK_FLAG (nh->type, ZEBRA_NEXTHOP_IPV6))
+    {
+      stream_putc (s, ZEBRA_NEXTHOP_IPV6);
+      stream_write (s, (u_char *)&nh->gw.ipv6, 16);
+    }
+#endif
+  if (CHECK_FLAG (nh->type, ZEBRA_NEXTHOP_IFINDEX))
+    {
+      stream_putc (s, ZEBRA_NEXTHOP_IFINDEX);
+      stream_putl (s, nh->intf.index);
+    }
+
+  if (CHECK_FLAG (nh->type, ZEBRA_NEXTHOP_IFNAME))
+    {
+      stream_putc (s, ZEBRA_NEXTHOP_IFNAME);
+      stream_put (s, nh->intf.name, INTERFACE_NAMSIZ);
+    }
+
+  if (CHECK_FLAG (nh->type, ZEBRA_NEXTHOP_SRC_IPV4))
+    {
+      stream_putc (s, ZEBRA_NEXTHOP_SRC_IPV4);
+      stream_put_in_addr (s, &nh->src.ipv4);
+    }
+#ifdef HAVE_IPV6
+  if (CHECK_FLAG (nh->type, ZEBRA_NEXTHOP_SRC_IPV6))
+    {
+      stream_putc (s, ZEBRA_NEXTHOP_SRC_IPV6);
+      stream_write (s, (u_char *)&nh->src.ipv6, 16);
+    }
+#endif
+
+#ifdef HAVE_MPLS
+  if (CHECK_FLAG (nh->type, ZEBRA_NEXTHOP_MPLS))
+    {
+      stream_putc (s, ZEBRA_NEXTHOP_MPLS);
+      mpls_label_stream_write (s, &nh->mpls);
+    }
+#endif
+}
+
+void
+zapi_nexthop_read(struct stream *s, struct zapi_nexthop *nh)
+{
+  char type = stream_getc (s);
+  nh->type = type;  
+  while (type != 0)
+    {
+      char ntype = stream_getc(s);
+      UNSET_FLAG (type, ntype);
+      if (CHECK_FLAG (ntype, ZEBRA_NEXTHOP_DROP))
+        nh->gw.drop = stream_getc(s);
+      else if (CHECK_FLAG (ntype, ZEBRA_NEXTHOP_IPV4))
+        nh->gw.ipv4.s_addr = stream_get_ipv4 (s);
+#ifdef HAVE_IPV6
+      else if (CHECK_FLAG (ntype, ZEBRA_NEXTHOP_IPV6))
+        stream_get (&nh->gw.ipv6, s, 16);
+#endif
+      else if (CHECK_FLAG (ntype, ZEBRA_NEXTHOP_IFINDEX))
+        nh->intf.index = stream_getl (s);
+      else if (CHECK_FLAG (ntype, ZEBRA_NEXTHOP_IFNAME))
+        stream_get (nh->intf.name, s, INTERFACE_NAMSIZ);
+      else if (CHECK_FLAG (ntype, ZEBRA_NEXTHOP_SRC_IPV4))
+        nh->src.ipv4.s_addr = stream_get_ipv4 (s);
+#ifdef HAVE_IPV6
+      else if (CHECK_FLAG (ntype, ZEBRA_NEXTHOP_SRC_IPV6))
+        stream_get (&nh->src.ipv6, s, 16);
+#endif
+#ifdef HAVE_MPLS
+      else if (CHECK_FLAG (ntype, ZEBRA_NEXTHOP_MPLS))
+        mpls_label_stream_read(s, &nh->mpls);
+#endif
+    }
+}
+
 int
-zapi_ipv4_route (u_char cmd, struct zclient *zclient, struct prefix_ipv4 *p,
+zapi_ipv4_write (u_char cmd, struct stream *s, struct prefix_ipv4 *p,
                  struct zapi_ipv4 *api)
 {
   int i;
   int psize;
-  struct stream *s;
 
   /* Reset stream. */
-  s = zclient->obuf;
   stream_reset (s);
   
   zclient_create_header (s, cmd);
@@ -445,31 +573,15 @@ zapi_ipv4_route (u_char cmd, struct zclient *zclient, struct prefix_ipv4 *p,
   stream_putc (s, p->prefixlen);
   stream_write (s, (u_char *) & p->prefix, psize);
 
-  /* Nexthop, ifindex, distance and metric information. */
+  /* Nexthop information. */
   if (CHECK_FLAG (api->message, ZAPI_MESSAGE_NEXTHOP))
     {
-      if (CHECK_FLAG (api->flags, ZEBRA_FLAG_BLACKHOLE))
-        {
-          stream_putc (s, 1);
-          stream_putc (s, ZEBRA_NEXTHOP_BLACKHOLE);
-          /* XXX assert(api->nexthop_num == 0); */
-          /* XXX assert(api->ifindex_num == 0); */
-        }
-      else
-        stream_putc (s, api->nexthop_num + api->ifindex_num);
-
+      stream_putc (s, api->nexthop_num);
       for (i = 0; i < api->nexthop_num; i++)
-        {
-          stream_putc (s, ZEBRA_NEXTHOP_IPV4);
-          stream_put_in_addr (s, api->nexthop[i]);
-        }
-      for (i = 0; i < api->ifindex_num; i++)
-        {
-          stream_putc (s, ZEBRA_NEXTHOP_IFINDEX);
-          stream_putl (s, api->ifindex[i]);
-        }
+        zapi_nexthop_write(s, &api->nexthop[i]);
     }
 
+  /* distance and metric information. */
   if (CHECK_FLAG (api->message, ZAPI_MESSAGE_DISTANCE))
     stream_putc (s, api->distance);
   if (CHECK_FLAG (api->message, ZAPI_MESSAGE_METRIC))
@@ -478,20 +590,75 @@ zapi_ipv4_route (u_char cmd, struct zclient *zclient, struct prefix_ipv4 *p,
   /* Put length at the first point of the stream. */
   stream_putw_at (s, 0, stream_get_endp (s));
 
+  return 0;
+}
+
+int
+zapi_ipv4_read (struct stream *s, zebra_size_t length,
+                struct zapi_ipv4 *api, struct prefix_ipv4 *p)
+{
+  /* Type, flags, message. */
+  api->type = stream_getc (s);
+  api->flags = stream_getc (s);
+  api->message = stream_getc (s);
+
+  /* IPv4 prefix. */
+  memset (p, 0, sizeof (struct prefix_ipv4));
+  p->family = AF_INET;
+  p->prefixlen = stream_getc (s);
+  stream_get (&p->prefix, s, PSIZE (p->prefixlen));
+
+  /* Nexthop, ifindex, distance and metric information. */
+  if (CHECK_FLAG (api->message, ZAPI_MESSAGE_NEXTHOP))
+    {
+      int count = 0;
+      int i = 0;
+
+      count = stream_getc (s);
+      while (count > 0)
+        {
+           zapi_nexthop_read (s, &api->nexthop[i]);
+           count--;
+           i++;
+        }
+
+      api->nexthop_num = i;
+    }
+
+  if (CHECK_FLAG (api->message, ZAPI_MESSAGE_DISTANCE))
+    api->distance = stream_getc (s);
+  if (CHECK_FLAG (api->message, ZAPI_MESSAGE_METRIC))
+    api->metric = stream_getl (s);
+
+  return 0;
+}
+
+int
+zapi_ipv4_route (u_char cmd, struct zclient *zclient, struct prefix_ipv4 *p,
+                 struct zapi_ipv4 *api)
+{
+  struct stream *s = zclient->obuf;
+  zapi_ipv4_write(cmd, s, p, api);
   return zclient_send_message(zclient);
 }
 
+int
+zapi_ipv4_route_read (struct zclient *zclient, zebra_size_t length,
+                      struct zapi_ipv4 *api, struct prefix_ipv4 *p)
+{
+  struct stream *s = zclient->ibuf;
+  return zapi_ipv4_read(s, length, api, p);
+}
+
 #ifdef HAVE_IPV6
 int
-zapi_ipv6_route (u_char cmd, struct zclient *zclient, struct prefix_ipv6 *p,
-	       struct zapi_ipv6 *api)
+zapi_ipv6_write (u_char cmd, struct stream *s, struct prefix_ipv6 *p,
+                 struct zapi_ipv6 *api)
 {
   int i;
   int psize;
-  struct stream *s;
 
   /* Reset stream. */
-  s = zclient->obuf;
   stream_reset (s);
 
   zclient_create_header (s, cmd);
@@ -506,23 +673,15 @@ zapi_ipv6_route (u_char cmd, struct zclient *zclient, struct prefix_ipv6 *p,
   stream_putc (s, p->prefixlen);
   stream_write (s, (u_char *)&p->prefix, psize);
 
-  /* Nexthop, ifindex, distance and metric information. */
+  /* Nexthop information. */
   if (CHECK_FLAG (api->message, ZAPI_MESSAGE_NEXTHOP))
     {
-      stream_putc (s, api->nexthop_num + api->ifindex_num);
-
+      stream_putc (s, api->nexthop_num);
       for (i = 0; i < api->nexthop_num; i++)
-	{
-	  stream_putc (s, ZEBRA_NEXTHOP_IPV6);
-	  stream_write (s, (u_char *)api->nexthop[i], 16);
-	}
-      for (i = 0; i < api->ifindex_num; i++)
-	{
-	  stream_putc (s, ZEBRA_NEXTHOP_IFINDEX);
-	  stream_putl (s, api->ifindex[i]);
-	}
+        zapi_nexthop_write(s, &api->nexthop[i]);
     }
 
+  /* distance and metric information. */
   if (CHECK_FLAG (api->message, ZAPI_MESSAGE_DISTANCE))
     stream_putc (s, api->distance);
   if (CHECK_FLAG (api->message, ZAPI_MESSAGE_METRIC))
@@ -531,8 +690,65 @@ zapi_ipv6_route (u_char cmd, struct zclient *zclient, struct prefix_ipv6 *p,
   /* Put length at the first point of the stream. */
   stream_putw_at (s, 0, stream_get_endp (s));
 
+  return 0;
+}
+
+int
+zapi_ipv6_read (struct stream *s, zebra_size_t length,
+                struct zapi_ipv6 *api, struct prefix_ipv6 *p)
+{
+  /* Type, flags, message. */
+  api->type = stream_getc (s);
+  api->flags = stream_getc (s);
+  api->message = stream_getc (s);
+
+  /* IPv4 prefix. */
+  memset (p, 0, sizeof (struct prefix_ipv6));
+  p->family = AF_INET6;
+  p->prefixlen = stream_getc (s);
+  stream_get (&p->prefix, s, PSIZE (p->prefixlen));
+
+  /* Nexthop, ifindex, distance and metric information. */
+  if (CHECK_FLAG (api->message, ZAPI_MESSAGE_NEXTHOP))
+    {
+      int count = 0;
+      int i = 0;
+
+      count = stream_getc (s);
+      while (count > 0)
+        {
+           zapi_nexthop_read (s, &api->nexthop[i]);
+           count--;
+           i++;
+        }
+
+      api->nexthop_num = i;
+    }
+
+  if (CHECK_FLAG (api->message, ZAPI_MESSAGE_DISTANCE))
+    api->distance = stream_getc (s);
+  if (CHECK_FLAG (api->message, ZAPI_MESSAGE_METRIC))
+    api->metric = stream_getl (s);
+
+  return 0;
+}
+
+int
+zapi_ipv6_route (u_char cmd, struct zclient *zclient, struct prefix_ipv6 *p,
+                 struct zapi_ipv6 *api)
+{
+  struct stream *s = zclient->obuf;
+  zapi_ipv6_write(cmd, s, p, api);
   return zclient_send_message(zclient);
 }
+
+int
+zapi_ipv6_route_read (struct zclient *zclient, zebra_size_t length,
+                      struct zapi_ipv6 *api, struct prefix_ipv6 *p)
+{
+  struct stream *s = zclient->ibuf;
+  return zapi_ipv6_read (s, length, api, p);
+}
 #endif /* HAVE_IPV6 */
 
 /* 
@@ -541,6 +757,545 @@ zapi_ipv6_route (u_char cmd, struct zclient *zclient, struct prefix_ipv6 *p,
  * then set/unset redist[type] in the client handle (a struct zserv) for the 
  * sending client
  */
+
+#ifdef HAVE_MPLS
+
+static void
+mpls_label_stream_write (struct stream *s, struct zmpls_label *label)
+{
+  /* Put label type. */
+  stream_putc (s, label->type);
+
+  /* put the label value */
+  switch (label->type)
+  {
+    case ZEBRA_MPLS_LABEL_GEN:
+      stream_putl (s, label->u.gen);
+      break;
+    case ZEBRA_MPLS_LABEL_ATM:
+      stream_putw (s, label->u.atm.vci);
+      stream_putw (s, label->u.atm.vpi);
+      break;
+    case ZEBRA_MPLS_LABEL_FR:
+      stream_putl (s, label->u.fr);
+      break;
+    default:
+      assert(0);
+  }
+}
+
+int
+mpls_label_stream_read (struct stream *s, struct zmpls_label *label)
+{
+  /* get the label type */
+  label->type = stream_getc (s);
+
+  /* get the label value */
+  switch (label->type)
+  {
+    case ZEBRA_MPLS_LABEL_GEN:
+      label->u.gen = stream_getl (s);
+      break;
+    case ZEBRA_MPLS_LABEL_ATM:
+      label->u.atm.vci = stream_getw (s);
+      label->u.atm.vpi = stream_getw (s);
+      break;
+    case ZEBRA_MPLS_LABEL_FR:
+      label->u.fr = stream_getl (s);
+      break;
+    default:
+      assert(0);
+  }
+  return 0;
+}
+
+static void
+mpls_fec_stream_write (struct stream *s, struct zmpls_fec *fec)
+{
+  int psize;
+
+  /* Put FEC type. */
+  stream_putc (s, fec->type);
+  stream_putc (s, fec->owner);
+
+  /* put the label value */
+  switch (fec->type)
+  {
+    case ZEBRA_MPLS_FEC_IPV4:
+    case ZEBRA_MPLS_FEC_IPV6:
+      /* Put prefix information. */
+      psize = PSIZE (fec->u.p.prefixlen);
+      stream_putc (s, fec->u.p.prefixlen);
+      stream_write (s, (u_char *)&fec->u.p.u.prefix, psize);
+      break;
+    case ZEBRA_MPLS_FEC_L2:
+      stream_put (s, fec->u.l2_ifname, INTERFACE_NAMSIZ);
+      break;
+    default:
+      assert(0);
+  }
+}
+
+static int
+mpls_fec_stream_read (struct stream *s, struct zmpls_fec *fec)
+{
+  /* get the fec type */
+  fec->type = stream_getc (s);
+  fec->owner = stream_getc (s);
+
+  /* get the fec value */
+  switch (fec->type)
+  {
+    case ZEBRA_MPLS_FEC_IPV4:
+    case ZEBRA_MPLS_FEC_IPV6:
+      memset (&fec->u.p, 0, sizeof (struct prefix));
+
+      if (fec->type == ZEBRA_MPLS_FEC_IPV4)
+        fec->u.p.family = AF_INET;
+      else
+        fec->u.p.family = AF_INET6;
+
+      fec->u.p.prefixlen = stream_getc (s);
+      stream_get (&fec->u.p.u.prefix, s, PSIZE (fec->u.p.prefixlen));
+      break;
+    case ZEBRA_MPLS_FEC_L2:
+      stream_get (fec->u.l2_ifname, s, INTERFACE_NAMSIZ);
+      break;
+    default:
+      assert(0);
+  }
+
+  return 0;
+}
+
+void
+mpls_ftn_stream_write (struct stream *s, struct zapi_mpls_ftn *api)
+{
+  stream_putc (s, api->owner);
+
+  /* the FEC we're binding to */
+  mpls_fec_stream_write (s, &api->fec);
+
+  /* out-segment index */
+  stream_putl (s, api->out_index);
+}
+
+int
+mpls_ftn_stream_read (struct stream *s, struct zapi_mpls_ftn *api)
+{
+  api->owner = stream_getc (s);
+
+  mpls_fec_stream_read (s, &api->fec);
+
+  api->out_index = stream_getl (s);
+  return 0;
+}
+
+void
+mpls_xc_stream_write (struct stream *s, struct zapi_mpls_xc *api)
+{
+  stream_putc (s, api->owner);
+
+  stream_putc (s, api->in_labelspace);
+  mpls_label_stream_write (s, &api->in_label);
+
+  stream_putl (s, api->out_index);
+}
+
+int
+mpls_xc_stream_read (struct stream *s, struct zapi_mpls_xc *api)
+{
+  api->owner = stream_getc (s);
+  api->in_labelspace = stream_getc (s);
+  mpls_label_stream_read (s, &api->in_label);
+
+  api->out_index = stream_getl (s);
+  return 0;
+}
+
+void
+mpls_in_segment_stream_write (struct stream *s,
+  struct zapi_mpls_in_segment *api)
+{
+  stream_putc (s, api->owner);
+  stream_putc (s, api->labelspace);
+  stream_putw (s, api->protocol);
+  stream_putc (s, api->pop);
+
+  mpls_label_stream_write (s, &api->label);
+}
+
+int
+mpls_in_segment_stream_read (struct stream *s,
+  struct zapi_mpls_in_segment *api)
+{
+  api->owner = stream_getc (s);
+  api->labelspace = stream_getc (s);
+  api->protocol = stream_getw (s);
+  api->pop = stream_getc (s);
+
+  mpls_label_stream_read (s, &api->label);
+  return 0;
+}
+
+void
+mpls_out_segment_stream_write (struct stream *s,
+  struct zapi_mpls_out_segment *api)
+{
+  stream_putc (s, api->owner);
+  zapi_nexthop_write(s, &api->nh);
+  stream_putl (s, api->index);
+  stream_putl (s, api->req);
+}
+
+int
+mpls_out_segment_stream_read (struct stream *s,
+  struct zapi_mpls_out_segment *api)
+{
+  api->owner = stream_getc (s);
+  zapi_nexthop_read(s, &api->nh);
+  api->index = stream_getl (s);
+  api->req = stream_getl (s);
+  return 0;
+}
+
+void
+mpls_labelspace_stream_write (struct stream *s,
+  struct zapi_mpls_labelspace *api)
+{
+  stream_putc (s, api->owner);
+  stream_putc (s, api->labelspace);
+  stream_put (s, api->ifname, INTERFACE_NAMSIZ);
+}
+
+int
+mpls_labelspace_stream_read (struct stream *s,
+  struct zapi_mpls_labelspace *api)
+{
+  api->owner = stream_getc (s);
+  api->labelspace = stream_getc (s);
+  stream_get (api->ifname, s, INTERFACE_NAMSIZ);
+
+  return 0;
+}
+
+static int
+zapi_mpls_xc (struct zclient *zclient, struct zapi_mpls_xc *api, u_char cmd)
+{
+  struct stream *s;
+
+  /* Reset stream. */
+  s = zclient->obuf;
+  stream_reset (s);
+
+  zclient_create_header (s, cmd);
+
+  mpls_xc_stream_write(s, api);
+
+  /* Put length at the first point of the stream. */
+  stream_putw_at (s, 0, stream_get_endp (s));
+
+  return zclient_send_message(zclient);
+}
+
+int
+zapi_mpls_xc_add (struct zclient *zclient, struct zapi_mpls_xc *api)
+{
+  return zapi_mpls_xc (zclient, api, ZEBRA_MPLS_XC_ADD);
+}
+
+int
+zapi_mpls_xc_delete (struct zclient *zclient, struct zapi_mpls_xc *api)
+{
+  return zapi_mpls_xc (zclient, api, ZEBRA_MPLS_XC_DELETE);
+}
+
+static int
+zapi_mpls_in_segment (struct zclient *zclient,
+  struct zapi_mpls_in_segment *api, u_char cmd)
+{
+  struct stream *s;
+
+  /* Reset stream. */
+  s = zclient->obuf;
+  stream_reset (s);
+
+  zclient_create_header (s, cmd);
+
+  mpls_in_segment_stream_write(s, api);
+
+  /* Put length at the first point of the stream. */
+  stream_putw_at (s, 0, stream_get_endp (s));
+
+  return zclient_send_message(zclient);
+}
+
+int
+zapi_mpls_in_segment_add (struct zclient *zclient,
+  struct zapi_mpls_in_segment *api)
+{
+  return zapi_mpls_in_segment (zclient, api, ZEBRA_MPLS_IN_SEGMENT_ADD);
+}
+
+int
+zapi_mpls_in_segment_delete (struct zclient *zclient,
+  struct zapi_mpls_in_segment *api)
+{
+  return zapi_mpls_in_segment (zclient, api, ZEBRA_MPLS_IN_SEGMENT_DELETE);
+}
+
+static int
+zapi_mpls_out_segment (struct zclient *zclient,
+  struct zapi_mpls_out_segment *api, u_char cmd)
+{
+  struct stream *s;
+
+  /* Reset stream. */
+  s = zclient->obuf;
+  stream_reset (s);
+
+  zclient_create_header (s, cmd);
+
+  mpls_out_segment_stream_write(s, api);
+
+  /* Put length at the first point of the stream. */
+  stream_putw_at (s, 0, stream_get_endp (s));
+
+  return zclient_send_message(zclient);
+}
+
+int
+zapi_mpls_out_segment_add (struct zclient *zclient,
+  struct zapi_mpls_out_segment *api)
+{
+  return zapi_mpls_out_segment (zclient, api, ZEBRA_MPLS_OUT_SEGMENT_ADD);
+}
+
+int
+zapi_mpls_out_segment_delete (struct zclient *zclient,
+  struct zapi_mpls_out_segment *api)
+{
+  return zapi_mpls_out_segment (zclient, api, ZEBRA_MPLS_OUT_SEGMENT_DELETE);
+}
+
+static int
+zapi_mpls_labelspace (struct zclient *zclient,
+  struct zapi_mpls_labelspace *api, u_char cmd)
+{
+  struct stream *s;
+
+  /* Reset stream. */
+  s = zclient->obuf;
+  stream_reset (s);
+
+  zclient_create_header (s, cmd);
+
+  mpls_labelspace_stream_write(s, api);
+
+  /* Put length at the first point of the stream. */
+  stream_putw_at (s, 0, stream_get_endp (s));
+
+  return zclient_send_message(zclient);
+}
+
+int
+zapi_mpls_labelspace_add (struct zclient *zclient,
+  struct zapi_mpls_labelspace *api)
+{
+  return zapi_mpls_labelspace (zclient, api, ZEBRA_MPLS_LABELSPACE_ADD);
+}
+
+int
+zapi_mpls_labelspace_delete (struct zclient *zclient,
+  struct zapi_mpls_labelspace *api)
+{
+  return zapi_mpls_labelspace (zclient, api, ZEBRA_MPLS_LABELSPACE_DELETE);
+}
+
+static int
+zapi_mpls_ftn (struct zclient *zclient, struct zapi_mpls_ftn *api, u_char cmd)
+{
+  struct stream *s;
+
+  /* Reset stream. */
+  s = zclient->obuf;
+  stream_reset (s);
+
+  zclient_create_header (s, cmd);
+
+  mpls_ftn_stream_write(s, api);
+
+  /* Put length at the first point of the stream. */
+  stream_putw_at (s, 0, stream_get_endp (s));
+
+  return zclient_send_message(zclient);
+}
+
+int
+zapi_mpls_ftn_add (struct zclient *zclient, struct zapi_mpls_ftn *api)
+{
+  return zapi_mpls_ftn (zclient, api, ZEBRA_MPLS_FTN_ADD);
+}
+
+int
+zapi_mpls_ftn_delete (struct zclient *zclient, struct zapi_mpls_ftn *api)
+{
+  return zapi_mpls_ftn (zclient, api, ZEBRA_MPLS_FTN_DELETE);
+}
+
+int
+mpls_label_match (struct zmpls_label *a, struct zmpls_label *b)
+{
+  if (a->type != b->type)
+    return 0;
+
+  switch (a->type)
+  {
+    case ZEBRA_MPLS_LABEL_GEN:
+      if (a->u.gen != b->u.gen)
+        return 0;
+      break;
+    case ZEBRA_MPLS_LABEL_ATM:
+      if (a->u.atm.vci != b->u.atm.vci &&
+          a->u.atm.vpi != b->u.atm.vpi)
+        return 0;
+      break;
+    case ZEBRA_MPLS_LABEL_FR:
+      if (a->u.fr != b->u.fr)
+        return 0;
+      break;
+    default:
+      assert(0);
+  }
+  return 1;
+}
+
+int
+mpls_fec_match(struct zmpls_fec *a, struct zmpls_fec *b)
+{
+  if (a->type != b->type)
+    return 0;
+
+  switch (a->type)
+  {
+    case ZEBRA_MPLS_FEC_IPV4:
+    case ZEBRA_MPLS_FEC_IPV6:
+      if (!prefix_same(&a->u.p, &b->u.p))
+      {
+	return 0;
+      }
+      break;
+    case ZEBRA_MPLS_FEC_L2:
+      if (strncmp(a->u.l2_ifname, b->u.l2_ifname, INTERFACE_NAMSIZ))
+      {
+	return 0;
+      }
+      break;
+    default:
+      assert(0);
+  }
+  return 1;
+}
+
+#endif
+/*
+ * NOTE when doing nexthop comparison, some IPv4 nexthop have ifindex
+ * and some do not. We only need to check the ifindex if this is not a
+ * IPv4 nexthop or if the both have ifindices
+ */
+
+int
+zapi_nexthop_match(struct zapi_nexthop *a, struct zapi_nexthop *b, int mask)
+{
+  int either = (a->type | b->type) & mask;
+  int both = (a->type & b->type) & mask;
+  int try = 0;
+  int match = 0;
+  int v4_gate_match = 0;
+
+  try++;
+  if (a->advmss == b->advmss)
+    match++;
+    
+  if (CHECK_FLAG (either, ZEBRA_NEXTHOP_DROP))
+    {
+      try++;
+      if (CHECK_FLAG (both, ZEBRA_NEXTHOP_DROP) &&
+	  a->gw.drop == b->gw.drop)
+        match++;
+    }
+  else if (CHECK_FLAG (either, ZEBRA_NEXTHOP_IPV4))
+    {
+      try++;
+      if (CHECK_FLAG (both, ZEBRA_NEXTHOP_IPV4) &&
+          IPV4_ADDR_SAME (&a->gw.ipv4, &b->gw.ipv4))
+	{
+	  match++;
+	  v4_gate_match = 1;
+	}
+    }
+#ifdef HAVE_IPV6
+  else if (CHECK_FLAG (either, ZEBRA_NEXTHOP_IPV6))
+    {
+      try++;
+      if (CHECK_FLAG (both, ZEBRA_NEXTHOP_IPV6) &&
+          IPV6_ADDR_SAME (&a->gw.ipv6, &b->gw.ipv6))
+        match++;
+    }
+#endif
+
+  if (CHECK_FLAG(either, ZEBRA_NEXTHOP_SRC_IPV4))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_SRC_IPV4) &&
+          IPV4_ADDR_SAME (&a->src.ipv4, &b->src.ipv4))
+        match++;
+    }
+#ifdef HAVE_IPV6
+  else if (CHECK_FLAG(either, ZEBRA_NEXTHOP_SRC_IPV6))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_SRC_IPV6) &&
+          IPV6_ADDR_SAME (&a->src.ipv6, &b->src.ipv6))
+        match++;
+    }
+#endif
+
+  if (CHECK_FLAG (either, ZEBRA_NEXTHOP_IFNAME))
+    {
+      try++;
+      if (CHECK_FLAG (both, ZEBRA_NEXTHOP_IFNAME) &&
+          strcmp (&a->intf.name, &b->intf.name) == 0)
+        match++;
+    }
+  else if (CHECK_FLAG (either, ZEBRA_NEXTHOP_IFINDEX))
+    {
+      if (!v4_gate_match)
+        {
+          try++;
+          if (CHECK_FLAG (both, ZEBRA_NEXTHOP_IFINDEX) &&
+            (a->intf.index == b->intf.index))
+            match++;
+        }
+      else if (CHECK_FLAG (both, ZEBRA_NEXTHOP_IFINDEX))
+        {
+            try++;
+            if (a->intf.index == b->intf.index)
+              match++;
+        }
+    }
+#ifdef HAVE_MPLS
+  if (CHECK_FLAG (either, ZEBRA_NEXTHOP_MPLS))
+    {
+      try++;
+      if (CHECK_FLAG (both, ZEBRA_NEXTHOP_MPLS) &&
+          mpls_label_match(&a->mpls, &b->mpls))
+        match++;
+    }
+#endif
+  return (try && try == match) ? 1 : 0;
+}
+
 int
 zebra_redistribute_send (int command, struct zclient *zclient, int type)
 {
@@ -937,6 +1692,46 @@ zclient_read (struct thread *thread)
       if (zclient->ipv6_route_delete)
 	ret = (*zclient->ipv6_route_delete) (command, zclient, length);
       break;
+    case ZEBRA_MPLS_XC_ADD:
+      if (zclient->mpls_xc_add)
+	ret = (*zclient->mpls_xc_add) (command, zclient, length);
+      break;
+    case ZEBRA_MPLS_XC_DELETE:
+      if (zclient->mpls_xc_delete)
+	ret = (*zclient->mpls_xc_delete) (command, zclient, length);
+      break;
+    case ZEBRA_MPLS_IN_SEGMENT_ADD:
+      if (zclient->mpls_in_segment_add)
+	ret = (*zclient->mpls_in_segment_add) (command, zclient, length);
+      break;
+    case ZEBRA_MPLS_IN_SEGMENT_DELETE:
+      if (zclient->mpls_in_segment_delete)
+	ret = (*zclient->mpls_in_segment_delete) (command, zclient, length);
+      break;
+    case ZEBRA_MPLS_OUT_SEGMENT_ADD:
+      if (zclient->mpls_out_segment_add)
+	ret = (*zclient->mpls_out_segment_add) (command, zclient, length);
+      break;
+    case ZEBRA_MPLS_OUT_SEGMENT_DELETE:
+      if (zclient->mpls_out_segment_delete)
+	ret = (*zclient->mpls_out_segment_delete) (command, zclient, length);
+      break;
+    case ZEBRA_MPLS_LABELSPACE_ADD:
+      if (zclient->mpls_labelspace_add)
+	ret = (*zclient->mpls_labelspace_add) (command, zclient, length);
+      break;
+    case ZEBRA_MPLS_LABELSPACE_DELETE:
+      if (zclient->mpls_labelspace_delete)
+	ret = (*zclient->mpls_labelspace_delete) (command, zclient, length);
+      break;
+    case ZEBRA_MPLS_FTN_ADD:
+      if (zclient->mpls_ftn_add)
+	ret = (*zclient->mpls_ftn_add) (command, zclient, length);
+      break;
+    case ZEBRA_MPLS_FTN_DELETE:
+      if (zclient->mpls_ftn_delete)
+	ret = (*zclient->mpls_ftn_delete) (command, zclient, length);
+      break;
     default:
       break;
     }
diff --git a/lib/zclient.h b/lib/zclient.h
index 69ada14..d66af1c 100644
--- a/lib/zclient.h
+++ b/lib/zclient.h
@@ -24,6 +24,7 @@
 
 /* For struct interface and struct connected. */
 #include "if.h"
+#include "prefix.h"
 
 /* For input/output buffer to zebra. */
 #define ZEBRA_MAX_PACKET_SIZ          4096
@@ -31,6 +32,9 @@
 /* Zebra header size. */
 #define ZEBRA_HEADER_SIZE             6
 
+/* Zebra maximum number of nexthops per API struct */
+#define ZEBRA_MAX_NEXTHOP                8
+
 /* Structure for the zebra client. */
 struct zclient
 {
@@ -67,6 +71,9 @@ struct zclient
   /* Redistribute defauilt. */
   u_char default_information;
 
+  /* Router-id information. */
+  u_char ridinfo;
+
   /* Pointer to the callback functions. */
   int (*router_id_update) (int, struct zclient *, uint16_t);
   int (*interface_add) (int, struct zclient *, uint16_t);
@@ -79,6 +86,16 @@ struct zclient
   int (*ipv4_route_delete) (int, struct zclient *, uint16_t);
   int (*ipv6_route_add) (int, struct zclient *, uint16_t);
   int (*ipv6_route_delete) (int, struct zclient *, uint16_t);
+  int (*mpls_xc_add) (int, struct zclient *, uint16_t);
+  int (*mpls_xc_delete) (int, struct zclient *, uint16_t);
+  int (*mpls_in_segment_add) (int, struct zclient *, uint16_t);
+  int (*mpls_in_segment_delete) (int, struct zclient *, uint16_t);
+  int (*mpls_out_segment_add) (int, struct zclient *, uint16_t);
+  int (*mpls_out_segment_delete) (int, struct zclient *, uint16_t);
+  int (*mpls_labelspace_add) (int, struct zclient *, uint16_t);
+  int (*mpls_labelspace_delete) (int, struct zclient *, uint16_t);
+  int (*mpls_ftn_add) (int, struct zclient *, uint16_t);
+  int (*mpls_ftn_delete) (int, struct zclient *, uint16_t);
 };
 
 /* Zebra API message flag. */
@@ -95,10 +112,58 @@ struct zserv_header
                          * always set to 255 in new zserv.
                          */
   uint8_t version;
-#define ZSERV_VERSION	1
+#define ZSERV_VERSION	2
   uint16_t command;
 };
 
+#ifdef HAVE_MPLS
+
+#define ZEBRA_MPLS_LABEL_GEN 1
+#define ZEBRA_MPLS_LABEL_ATM 2
+#define ZEBRA_MPLS_LABEL_FR  3
+
+struct zmpls_label
+{
+  u_char type;
+  union {
+    u_int32_t gen;
+    u_int32_t fr;
+    struct {
+      u_int16_t  vpi;
+      u_int16_t  vci;
+    } atm;
+  } u;
+};
+#endif
+
+struct zapi_nexthop {
+  u_char type;
+  union
+    {
+      char name[INTERFACE_NAMSIZ + 1];
+      unsigned int index;
+    } intf;
+  union
+    {
+      struct in_addr ipv4;
+#ifdef HAVE_IPV6
+      struct in6_addr ipv6;
+#endif
+      u_char drop;
+    } gw;
+  union
+    {
+      struct in_addr ipv4;
+      struct in6_addr ipv6;
+    } src;
+
+  /* Advertised MSS */
+  int advmss;
+#ifdef HAVE_MPLS
+  struct zmpls_label mpls;
+#endif
+};
+
 /* Zebra IPv4 route message API. */
 struct zapi_ipv4
 {
@@ -109,10 +174,7 @@ struct zapi_ipv4
   u_char message;
 
   u_char nexthop_num;
-  struct in_addr **nexthop;
-
-  u_char ifindex_num;
-  unsigned int *ifindex;
+  struct zapi_nexthop nexthop[8];
 
   u_char distance;
 
@@ -153,8 +215,19 @@ extern struct interface *zebra_interface_state_read (struct stream *s);
 extern struct connected *zebra_interface_address_read (int, struct stream *);
 extern void zebra_interface_if_set_value (struct stream *, struct interface *);
 extern void zebra_router_id_update_read (struct stream *s, struct prefix *rid);
+
+extern void zapi_nexthop_write(struct stream *s, struct zapi_nexthop *nh);
+extern void zapi_nexthop_read(struct stream *s, struct zapi_nexthop *nh);
+
+extern int zapi_ipv4_write (u_char cmd, struct stream *s, struct prefix_ipv4 *p,
+                            struct zapi_ipv4 *api);
+extern int zapi_ipv4_read (struct stream *, zebra_size_t, struct zapi_ipv4 *,
+                           struct prefix_ipv4 *);
+
 extern int zapi_ipv4_route (u_char, struct zclient *, struct prefix_ipv4 *, 
                             struct zapi_ipv4 *);
+extern int zapi_ipv4_route_read (struct zclient *, zebra_size_t, struct zapi_ipv4 *,
+                                 struct prefix_ipv4 *);
 
 #ifdef HAVE_IPV6
 /* IPv6 prefix add and delete function prototype. */
@@ -168,18 +241,162 @@ struct zapi_ipv6
   u_char message;
 
   u_char nexthop_num;
-  struct in6_addr **nexthop;
-
-  u_char ifindex_num;
-  unsigned int *ifindex;
+  struct zapi_nexthop nexthop[8];
 
   u_char distance;
 
   u_int32_t metric;
 };
 
+extern int zapi_ipv6_write (u_char cmd, struct stream *s, struct prefix_ipv6 *p,
+                            struct zapi_ipv6 *api);
+extern int zapi_ipv6_read (struct stream *, zebra_size_t, struct zapi_ipv6 *,
+                           struct prefix_ipv6 *);
+
 extern int zapi_ipv6_route (u_char cmd, struct zclient *zclient, 
-                     struct prefix_ipv6 *p, struct zapi_ipv6 *api);
+                            struct prefix_ipv6 *p, struct zapi_ipv6 *api);
+extern int zapi_ipv6_route_read (struct zclient *, zebra_size_t, struct zapi_ipv6 *,
+                                 struct prefix_ipv6 *);
 #endif /* HAVE_IPV6 */
 
+#ifdef HAVE_MPLS
+
+#define ZEBRA_MPLS_FEC_IPV4 1
+#define ZEBRA_MPLS_FEC_IPV6 2
+#define ZEBRA_MPLS_FEC_L2  3
+
+struct zmpls_fec
+{
+  u_char type;
+  char owner;
+  union {
+    struct prefix p;
+    char l2_ifname[INTERFACE_NAMSIZ + 1];
+  } u;
+};
+
+/* structures used by clients */
+
+struct zapi_mpls_xc
+{
+  u_int index;
+  u_char owner;
+  u_char in_labelspace;
+  struct zmpls_label in_label;
+  u_int out_index;
+};
+
+struct zapi_mpls_in_segment
+{
+  u_char owner;
+  u_char labelspace;
+  u_short protocol;
+  u_char pop;
+  struct zmpls_label label;
+};
+
+struct zapi_mpls_out_segment
+{
+  u_char owner;
+  /* label is embeded in zapi_nexthop */
+  struct zapi_nexthop nh;
+  u_int index;
+  int req;
+};
+
+struct zapi_mpls_labelspace
+{
+  u_char owner;
+  char labelspace;
+  char ifname[INTERFACE_NAMSIZ + 1];
+};
+
+struct zapi_mpls_ftn
+{
+  u_char owner;
+  struct zmpls_fec fec;
+  u_int out_index;
+};
+
+int
+mpls_label_match (struct zmpls_label *a, struct zmpls_label *b);
+
+int
+mpls_fec_match (struct zmpls_fec *a, struct zmpls_fec *b);
+
+int
+zapi_nexthop_match(struct zapi_nexthop *a, struct zapi_nexthop *b, int mask);
+
+void
+mpls_xc_stream_write (struct stream *s, struct zapi_mpls_xc *api);
+
+int
+mpls_xc_stream_read (struct stream *s, struct zapi_mpls_xc *api);
+
+void
+mpls_in_segment_stream_write (struct stream *s,
+                              struct zapi_mpls_in_segment *api);
+int
+mpls_in_segment_stream_read (struct stream *s,
+                             struct zapi_mpls_in_segment *api);
+
+void
+mpls_out_segment_stream_write (struct stream *s,
+                               struct zapi_mpls_out_segment *api);
+int
+mpls_out_segment_stream_read (struct stream *s,
+                              struct zapi_mpls_out_segment *api);
+
+void
+mpls_labelspace_stream_write (struct stream *s,
+                              struct zapi_mpls_labelspace *api);
+int
+mpls_labelspace_stream_read (struct stream *s,
+                             struct zapi_mpls_labelspace *api);
+
+void
+mpls_ftn_stream_write (struct stream *s,
+                              struct zapi_mpls_ftn *api);
+int
+mpls_ftn_stream_read (struct stream *s,
+                             struct zapi_mpls_ftn *api);
+
+int
+zapi_mpls_xc_add (struct zclient *zclient, struct zapi_mpls_xc *api);
+
+int
+zapi_mpls_xc_delete (struct zclient *zclient, struct zapi_mpls_xc *api);
+
+int
+zapi_mpls_in_segment_add (struct zclient *zclient,
+                          struct zapi_mpls_in_segment *api);
+
+int
+zapi_mpls_in_segment_delete (struct zclient *zclient,
+                             struct zapi_mpls_in_segment *api);
+
+int
+zapi_mpls_out_segment_add (struct zclient *zclient,
+                           struct zapi_mpls_out_segment *api);
+
+int
+zapi_mpls_out_segment_delete (struct zclient *zclient,
+                              struct zapi_mpls_out_segment *api);
+
+int
+zapi_mpls_labelspace_add (struct zclient *zclient,
+                          struct zapi_mpls_labelspace *api);
+
+int
+zapi_mpls_labelspace_delete (struct zclient *zclient,
+                             struct zapi_mpls_labelspace *api);
+
+int
+zapi_mpls_ftn_add (struct zclient *zclient, struct zapi_mpls_ftn *api);
+
+int
+zapi_mpls_ftn_delete (struct zclient *zclient,
+                      struct zapi_mpls_ftn *api);
+
+#endif /* HAVE_MPLS */
 #endif /* _ZEBRA_ZCLIENT_H */
diff --git a/lib/zebra.h b/lib/zebra.h
index 2716460..2d50b75 100644
--- a/lib/zebra.h
+++ b/lib/zebra.h
@@ -159,11 +159,16 @@ typedef int socklen_t;
 #include <net/route.h>
 #endif /* HAVE_NET_ROUTE_H */
 
+#undef __STRICT_ANSI__
+
 #ifdef HAVE_NETLINK
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
 #include <linux/filter.h>
 #include <stddef.h>
+#if defined(HAVE_MPLS) && defined(LINUX_MPLS)
+#include <linux/genetlink.h>
+#endif
 #else
 #define RT_TABLE_MAIN		0
 #endif /* HAVE_NETLINK */
@@ -413,7 +418,17 @@ struct in_pktinfo
 #define ZEBRA_ROUTER_ID_ADD               20
 #define ZEBRA_ROUTER_ID_DELETE            21
 #define ZEBRA_ROUTER_ID_UPDATE            22
-#define ZEBRA_MESSAGE_MAX                 23
+#define ZEBRA_MPLS_XC_ADD                 23
+#define ZEBRA_MPLS_XC_DELETE              24
+#define ZEBRA_MPLS_IN_SEGMENT_ADD         25
+#define ZEBRA_MPLS_IN_SEGMENT_DELETE      26
+#define ZEBRA_MPLS_OUT_SEGMENT_ADD        27
+#define ZEBRA_MPLS_OUT_SEGMENT_DELETE     28
+#define ZEBRA_MPLS_LABELSPACE_ADD         29
+#define ZEBRA_MPLS_LABELSPACE_DELETE      30
+#define ZEBRA_MPLS_FTN_ADD                31
+#define ZEBRA_MPLS_FTN_DELETE             32
+#define ZEBRA_MESSAGE_MAX                 33
 
 /* Marker value used in new Zserv, in the byte location corresponding
  * the command value in the old zserv header. To allow old and new
@@ -433,7 +448,10 @@ struct in_pktinfo
 #define ZEBRA_ROUTE_ISIS                 8
 #define ZEBRA_ROUTE_BGP                  9
 #define ZEBRA_ROUTE_HSLS		 10
-#define ZEBRA_ROUTE_MAX                  11
+#define ZEBRA_ROUTE_LDP                  11
+#define ZEBRA_ROUTE_RSVP                 12
+#define ZEBRA_ROUTE_TE                   13
+#define ZEBRA_ROUTE_MAX                  14
 
 /* Note: whenever a new route-type or zserv-command is added the
  * corresponding {command,route}_types[] table in lib/log.c MUST be
@@ -472,17 +490,29 @@ extern const char *zserv_command_string (unsigned int command);
 #define ZEBRA_FLAG_CHANGED            0x20
 #define ZEBRA_FLAG_STATIC             0x40
 #define ZEBRA_FLAG_REJECT             0x80
+#define ZEBRA_FLAG_CHANGED_MPLS      0x100
+
+/*
+ * REJECT and BLACKHOLE flags should never be set by
+ * anything except nexthop_active_check(), instead create
+ * a nexthop * with flag ZEBRA_NEXTHOP_DROP and set the
+ * drop field to one of the ZEBRA_DROP_* values below.
+ */
 
 /* Zebra nexthop flags. */
-#define ZEBRA_NEXTHOP_IFINDEX            1
-#define ZEBRA_NEXTHOP_IFNAME             2
-#define ZEBRA_NEXTHOP_IPV4               3
-#define ZEBRA_NEXTHOP_IPV4_IFINDEX       4
-#define ZEBRA_NEXTHOP_IPV4_IFNAME        5
-#define ZEBRA_NEXTHOP_IPV6               6
-#define ZEBRA_NEXTHOP_IPV6_IFINDEX       7
-#define ZEBRA_NEXTHOP_IPV6_IFNAME        8
-#define ZEBRA_NEXTHOP_BLACKHOLE          9
+#define ZEBRA_NEXTHOP_IFINDEX            0x01
+#define ZEBRA_NEXTHOP_IFNAME             0x02
+#define ZEBRA_NEXTHOP_IPV4               0x04
+#define ZEBRA_NEXTHOP_IPV6               0x08
+#define ZEBRA_NEXTHOP_DROP               0x10
+#define ZEBRA_NEXTHOP_SRC_IPV4           0x20
+#define ZEBRA_NEXTHOP_SRC_IPV6           0x40
+#define ZEBRA_NEXTHOP_MPLS               0x80
+#define ZEBRA_NEXTHOP_ALL                0xFF
+
+#define ZEBRA_DROP_BLACKHOLE             1
+#define ZEBRA_DROP_REJECT                2
+#define ZEBRA_DROP_NULL                  3
 
 #ifndef INADDR_LOOPBACK
 #define	INADDR_LOOPBACK	0x7f000001	/* Internet address 127.0.0.1.  */
diff --git a/ospf6d/ospf6_zebra.c b/ospf6d/ospf6_zebra.c
index c974005..5c465a1 100644
--- a/ospf6d/ospf6_zebra.c
+++ b/ospf6d/ospf6_zebra.c
@@ -195,74 +195,50 @@ ospf6_zebra_read_ipv6 (int command, struct zclient *zclient,
   struct zapi_ipv6 api;
   unsigned long ifindex;
   struct prefix_ipv6 p;
-  struct in6_addr *nexthop;
+  struct in6_addr nexthop;
+  int i;
 
   s = zclient->ibuf;
-  ifindex = 0;
-  nexthop = NULL;
   memset (&api, 0, sizeof (api));
 
-  /* Type, flags, message. */
-  api.type = stream_getc (s);
-  api.flags = stream_getc (s);
-  api.message = stream_getc (s);
+  zapi_ipv6_read (s, length, &api, &p);
 
-  /* IPv6 prefix. */
-  memset (&p, 0, sizeof (struct prefix_ipv6));
-  p.family = AF_INET6;
-  p.prefixlen = stream_getc (s);
-  stream_get (&p.prefix, s, PSIZE (p.prefixlen));
+  for (i = 0; i < api.nexthop_num; i++)
+    { 
+      ifindex = 0;
+      memset (&nexthop, 0, sizeof (nexthop));
 
-  /* Nexthop, ifindex, distance, metric. */
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
-    {
-      api.nexthop_num = stream_getc (s);
-      nexthop = (struct in6_addr *)
-        malloc (api.nexthop_num * sizeof (struct in6_addr));
-      stream_get (nexthop, s, api.nexthop_num * sizeof (struct in6_addr));
-    }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_IFINDEX))
-    {
-      api.ifindex_num = stream_getc (s);
-      ifindex = stream_getl (s);
-    }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))
-    api.distance = stream_getc (s);
-  else
-    api.distance = 0;
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))
-    api.metric = stream_getl (s);
-  else
-    api.metric = 0;
+      if (api.nexthop[i].type & ZEBRA_NEXTHOP_IFINDEX)
+        ifindex = api.nexthop[i].intf.index;
 
-  if (IS_OSPF6_DEBUG_ZEBRA (RECV))
-    {
-      char prefixstr[128], nexthopstr[128];
-      prefix2str ((struct prefix *)&p, prefixstr, sizeof (prefixstr));
-      if (nexthop)
-        inet_ntop (AF_INET6, nexthop, nexthopstr, sizeof (nexthopstr));
-      else
-        snprintf (nexthopstr, sizeof (nexthopstr), "::");
+      if (api.nexthop[i].type & ZEBRA_NEXTHOP_IPV6)
+        memcpy(&nexthop, &api.nexthop[i].gw.ipv6, sizeof (nexthop));
 
-      zlog_debug ("Zebra Receive route %s: %s %s nexthop %s ifindex %ld",
-		  (command == ZEBRA_IPV6_ROUTE_ADD ? "add" : "delete"),
-		  zebra_route_string(api.type), prefixstr, nexthopstr, ifindex);
+      if (IS_OSPF6_DEBUG_ZEBRA (RECV))
+        {
+          char prefixstr[128], nexthopstr[128];
+          prefix2str ((struct prefix *)&p, prefixstr, sizeof (prefixstr));
+          if (api.nexthop[i].type & ZEBRA_NEXTHOP_IPV6)
+            inet_ntop (AF_INET6, &nexthop, nexthopstr, sizeof (nexthopstr));
+          else
+            snprintf (nexthopstr, sizeof (nexthopstr), "::");
+
+          zlog_debug ("Zebra Receive route %s: %s %s nexthop %s ifindex %ld",
+		      (command == ZEBRA_IPV6_ROUTE_ADD ? "add" : "delete"),
+		      zebra_route_string(api.type), prefixstr,
+                      nexthopstr, ifindex);
+        }
+
+      if (command == ZEBRA_IPV6_ROUTE_ADD)
+        ospf6_asbr_redistribute_add (api.type, ifindex, (struct prefix *) &p,
+                                     api.nexthop_num, &nexthop);
+      else
+        ospf6_asbr_redistribute_remove (api.type, ifindex,
+                                        (struct prefix *) &p);
     }
- 
-  if (command == ZEBRA_IPV6_ROUTE_ADD)
-    ospf6_asbr_redistribute_add (api.type, ifindex, (struct prefix *) &p,
-                                 api.nexthop_num, nexthop);
-  else
-    ospf6_asbr_redistribute_remove (api.type, ifindex, (struct prefix *) &p);
-
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
-    free (nexthop);
 
   return 0;
 }
-
-
-
 
 DEFUN (show_zebra,
        show_zebra_cmd,
@@ -349,8 +325,6 @@ ospf6_zebra_route_update (int type, struct ospf6_route *request)
   struct zapi_ipv6 api;
   char buf[64];
   int nhcount;
-  struct in6_addr **nexthops;
-  unsigned int *ifindexes;
   int i, ret = 0;
   struct prefix_ipv6 *dest;
 
@@ -409,24 +383,9 @@ ospf6_zebra_route_update (int type, struct ospf6_route *request)
       return;
     }
 
-  /* allocate memory for nexthop_list */
-  nexthops = XCALLOC (MTYPE_OSPF6_OTHER,
-                      nhcount * sizeof (struct in6_addr *));
-  if (nexthops == NULL)
-    {
-      zlog_warn ("Can't send route to zebra: malloc failed");
-      return;
-    }
-
-  /* allocate memory for ifindex_list */
-  ifindexes = XCALLOC (MTYPE_OSPF6_OTHER,
-                       nhcount * sizeof (unsigned int));
-  if (ifindexes == NULL)
-    {
-      zlog_warn ("Can't send route to zebra: malloc failed");
-      XFREE (MTYPE_OSPF6_OTHER, nexthops);
-      return;
-    }
+  api.type = ZEBRA_ROUTE_OSPF6;
+  api.flags = 0;
+  api.message = 0;
 
   for (i = 0; i < nhcount; i++)
     {
@@ -440,19 +399,14 @@ ospf6_zebra_route_update (int type, struct ospf6_route *request)
 	  zlog_debug ("  nexthop: %s%%%.*s(%d)", buf, IFNAMSIZ, ifname,
 		      request->nexthop[i].ifindex);
 	}
-      nexthops[i] = &request->nexthop[i].address;
-      ifindexes[i] = request->nexthop[i].ifindex;
+
+      SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
+      api.nexthop[i].type = ZEBRA_NEXTHOP_IPV6|ZEBRA_NEXTHOP_IFINDEX;
+      memcpy (&api.nexthop[i].gw.ipv6, &request->nexthop[i].address, 16);
+      api.nexthop[i].intf.index = request->nexthop[i].ifindex;
     }
 
-  api.type = ZEBRA_ROUTE_OSPF6;
-  api.flags = 0;
-  api.message = 0;
-  SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
-  api.nexthop_num = nhcount;
-  api.nexthop = nexthops;
-  SET_FLAG (api.message, ZAPI_MESSAGE_IFINDEX);
-  api.ifindex_num = nhcount;
-  api.ifindex = ifindexes;
+  api.nexthop_num = i;
   SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);
   api.metric = (request->path.metric_type == 2 ?
                 request->path.cost_e2 : request->path.cost);
@@ -467,9 +421,6 @@ ospf6_zebra_route_update (int type, struct ospf6_route *request)
     zlog_err ("zapi_ipv6_route() %s failed: %s",
               (type == REM ? "delete" : "add"), safe_strerror (errno));
 
-  XFREE (MTYPE_OSPF6_OTHER, nexthops);
-  XFREE (MTYPE_OSPF6_OTHER, ifindexes);
-
   return;
 }
 
diff --git a/ospfd/ospf_zebra.c b/ospfd/ospf_zebra.c
index f302d28..3a516ee 100644
--- a/ospfd/ospf_zebra.c
+++ b/ospfd/ospf_zebra.c
@@ -339,59 +339,37 @@ ospf_zebra_add (struct prefix_ipv4 *p, struct ospf_route *or)
 {
   u_char message;
   u_char distance;
-  u_char flags;
-  int psize;
-  struct stream *s;
   struct ospf_path *path;
   struct listnode *node;
+  struct zapi_ipv4 api;
+  int count;
 
   if (zclient->redist[ZEBRA_ROUTE_OSPF])
     {
-      message = 0;
-      flags = 0;
-
-      /* OSPF pass nexthop and metric */
-      SET_FLAG (message, ZAPI_MESSAGE_NEXTHOP);
-      SET_FLAG (message, ZAPI_MESSAGE_METRIC);
-
-      /* Distance value. */
-      distance = ospf_distance_apply (p, or);
-      if (distance)
-        SET_FLAG (message, ZAPI_MESSAGE_DISTANCE);
-
-      /* Make packet. */
-      s = zclient->obuf;
-      stream_reset (s);
+      memset (&api, 0, sizeof (api));
 
-      /* Put command, type, flags, message. */
-      zclient_create_header (s, ZEBRA_IPV4_ROUTE_ADD);
-      stream_putc (s, ZEBRA_ROUTE_OSPF);
-      stream_putc (s, flags);
-      stream_putc (s, message);
-
-      /* Put prefix information. */
-      psize = PSIZE (p->prefixlen);
-      stream_putc (s, p->prefixlen);
-      stream_write (s, (u_char *) & p->prefix, psize);
+      api.flags = 0;
+      api.type = ZEBRA_ROUTE_OSPF;
 
-      /* Nexthop count. */
-      stream_putc (s, or->paths->count);
+      count = 0;
 
       /* Nexthop, ifindex, distance and metric information. */
       for (ALL_LIST_ELEMENTS_RO (or->paths, node, path))
         {
           if (path->nexthop.s_addr != INADDR_ANY)
             {
-              stream_putc (s, ZEBRA_NEXTHOP_IPV4);
-              stream_put_in_addr (s, &path->nexthop);
+              SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
+              api.nexthop[count].type = ZEBRA_NEXTHOP_IPV4;
+              api.nexthop[count].gw.ipv4.s_addr = path->nexthop.s_addr;
             }
           else
             {
-              stream_putc (s, ZEBRA_NEXTHOP_IFINDEX);
+              SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
+              api.nexthop[count].type = ZEBRA_NEXTHOP_IFINDEX;
               if (path->oi)
-                stream_putl (s, path->oi->ifp->ifindex);
+                api.nexthop[count].intf.index = path->oi->ifp->ifindex;
               else
-                stream_putl (s, 0);
+                api.nexthop[count].intf.index = 0;
             }
 
           if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))
@@ -404,23 +382,29 @@ ospf_zebra_add (struct prefix_ipv4 *p, struct ospf_route *or)
 			 inet_ntop(AF_INET, &path->nexthop,
 				   buf[1], sizeof(buf[1])));
             }
+          count++;
         }
 
-      if (CHECK_FLAG (message, ZAPI_MESSAGE_DISTANCE))
-        stream_putc (s, distance);
-      if (CHECK_FLAG (message, ZAPI_MESSAGE_METRIC))
+      api.nexthop_num = count;
+
+      /* Distance value. */
+      distance = ospf_distance_apply (p, or);
+      if (distance)
         {
-          if (or->path_type == OSPF_PATH_TYPE1_EXTERNAL)
-            stream_putl (s, or->cost + or->u.ext.type2_cost);
-          else if (or->path_type == OSPF_PATH_TYPE2_EXTERNAL)
-            stream_putl (s, or->u.ext.type2_cost);
-          else
-            stream_putl (s, or->cost);
+          SET_FLAG (api.message, ZAPI_MESSAGE_DISTANCE);
+          api.distance = distance;
         }
 
-      stream_putw_at (s, 0, stream_get_endp (s));
+      /* OSPF pass metric */
+      SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);
+      if (or->path_type == OSPF_PATH_TYPE1_EXTERNAL)
+        api.metric = or->cost + or->u.ext.type2_cost;
+      else if (or->path_type == OSPF_PATH_TYPE2_EXTERNAL)
+        api.metric = or->u.ext.type2_cost;
+      else
+        api.metric = or->cost;
 
-      zclient_send_message(zclient);
+      zapi_ipv4_route(ZEBRA_IPV4_ROUTE_ADD, zclient, p, &api);
     }
 }
 
@@ -429,31 +413,32 @@ ospf_zebra_delete (struct prefix_ipv4 *p, struct ospf_route *or)
 {
   struct zapi_ipv4 api;
   struct ospf_path *path;
-  struct in_addr *nexthop;
   struct listnode *node, *nnode;
+  int count;
 
   if (zclient->redist[ZEBRA_ROUTE_OSPF])
     {
       api.type = ZEBRA_ROUTE_OSPF;
       api.flags = 0;
       api.message = 0;
-      api.ifindex_num = 0;
-      api.nexthop_num = 0;
+      count = 0;
 
       for (ALL_LIST_ELEMENTS (or->paths, node, nnode, path))
         {
           if (path->nexthop.s_addr != INADDR_ANY)
             {
               SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
-              api.nexthop_num = 1;
-              nexthop = &path->nexthop;
-              api.nexthop = &nexthop;
+              api.nexthop[count].type = ZEBRA_NEXTHOP_IPV4;
+              api.nexthop[count].gw.ipv4.s_addr = path->nexthop.s_addr;
             }
           else if (ospf_if_exists(path->oi) && (path->oi->ifp))
             {
               SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
-              api.ifindex_num = 1;
-              api.ifindex = &path->oi->ifp->ifindex;
+              api.nexthop[count].type = ZEBRA_NEXTHOP_IFINDEX;
+              if (path->oi)
+                api.nexthop[count].intf.index = path->oi->ifp->ifindex;
+              else
+                api.nexthop[count].intf.index = 0;
             }
           else if ( IS_DEBUG_OSPF(zebra,ZEBRA_REDISTRIBUTE) )
             {
@@ -462,24 +447,25 @@ ospf_zebra_delete (struct prefix_ipv4 *p, struct ospf_route *or)
                          p->prefixlen);
             }
 
-          zapi_ipv4_route (ZEBRA_IPV4_ROUTE_DELETE, zclient, p, &api);
-
-          if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE) && api.nexthop_num)
+          if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))
             {
 	      char buf[2][INET_ADDRSTRLEN];
-	      zlog_debug("Zebra: Route delete %s/%d nexthop %s",
-			 inet_ntop(AF_INET, &p->prefix, buf[0], sizeof(buf[0])),
-			 p->prefixlen,
-			 inet_ntop(AF_INET, *api.nexthop,
-				   buf[1], sizeof(buf[1])));
-            }
-          if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE) && api.ifindex_num)
-            {
-              zlog_debug ("Zebra: Route delete %s/%d ifindex %d",
-                         inet_ntoa (p->prefix),
-                         p->prefixlen, *api.ifindex);
+	      zlog_debug("Zebra: Route delete %s/%d",
+			 inet_ntop(AF_INET, &p->prefix, buf[0],
+			 sizeof(buf[0])), p->prefixlen);
+
+              if (CHECK_FLAG (api.nexthop[count].type, ZEBRA_NEXTHOP_IPV4))
+		  zlog_debug("\tnexthop %s", inet_ntop(AF_INET,
+			     &api.nexthop[count].gw.ipv4,
+			     buf[1], sizeof(buf[1])));
+
+              if (CHECK_FLAG (api.nexthop[count].type, ZEBRA_NEXTHOP_IFINDEX))
+                zlog_debug ("\tifindex %d", api.nexthop[count].intf.index);
             }
+          count++;
         }
+      api.nexthop_num = count;
+      zapi_ipv4_route (ZEBRA_IPV4_ROUTE_DELETE, zclient, p, &api);
     }
 }
 
@@ -491,11 +477,11 @@ ospf_zebra_add_discard (struct prefix_ipv4 *p)
   if (zclient->redist[ZEBRA_ROUTE_OSPF])
     {
       api.type = ZEBRA_ROUTE_OSPF;
-      api.flags = ZEBRA_FLAG_BLACKHOLE;
-      api.message = 0;
-      SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
-      api.nexthop_num = 0;
-      api.ifindex_num = 0;
+      api.flags = 0;
+      api.message = ZAPI_MESSAGE_NEXTHOP;
+      api.nexthop_num = 1;
+      api.nexthop[0].type = ZEBRA_NEXTHOP_DROP;
+      api.nexthop[0].gw.drop = ZEBRA_DROP_BLACKHOLE;
 
       zapi_ipv4_route (ZEBRA_IPV4_ROUTE_ADD, zclient, p, &api);
 
@@ -513,11 +499,11 @@ ospf_zebra_delete_discard (struct prefix_ipv4 *p)
   if (zclient->redist[ZEBRA_ROUTE_OSPF])
     {
       api.type = ZEBRA_ROUTE_OSPF;
-      api.flags = ZEBRA_FLAG_BLACKHOLE;
-      api.message = 0;
-      SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
-      api.nexthop_num = 0;
-      api.ifindex_num = 0;
+      api.flags = 0;
+      api.message = ZAPI_MESSAGE_NEXTHOP;
+      api.nexthop_num = 1;
+      api.nexthop[0].type = ZEBRA_NEXTHOP_DROP;
+      api.nexthop[0].gw.drop = ZEBRA_DROP_BLACKHOLE;
 
       zapi_ipv4_route (ZEBRA_IPV4_ROUTE_DELETE, zclient, p, &api);
 
@@ -800,96 +786,85 @@ ospf_zebra_read_ipv4 (int command, struct zclient *zclient,
   struct prefix_ipv4 p;
   struct external_info *ei;
   struct ospf *ospf;
+  int i;
 
   s = zclient->ibuf;
-  ifindex = 0;
-  nexthop.s_addr = 0;
 
-  /* Type, flags, message. */
-  api.type = stream_getc (s);
-  api.flags = stream_getc (s);
-  api.message = stream_getc (s);
-
-  /* IPv4 prefix. */
-  memset (&p, 0, sizeof (struct prefix_ipv4));
-  p.family = AF_INET;
-  p.prefixlen = stream_getc (s);
-  stream_get (&p.prefix, s, PSIZE (p.prefixlen));
+  zapi_ipv4_read (s, length, &api, &p);
 
   if (IPV4_NET127(ntohl(p.prefix.s_addr)))
     return 0;
 
-  /* Nexthop, ifindex, distance, metric. */
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
-    {
-      api.nexthop_num = stream_getc (s);
-      nexthop.s_addr = stream_get_ipv4 (s);
-    }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_IFINDEX))
-    {
-      api.ifindex_num = stream_getc (s);
-      /* XXX assert(api.ifindex_num == 1); */
-      ifindex = stream_getl (s);
-    }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))
-    api.distance = stream_getc (s);
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))
-    api.metric = stream_getl (s);
-
   ospf = ospf_lookup ();
   if (ospf == NULL)
     return 0;
 
-  if (command == ZEBRA_IPV4_ROUTE_ADD)
+  /* Nexthop, ifindex, distance, metric. */
+  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
     {
-      /* XXX|HACK|TODO|FIXME:
-       * Maybe we should ignore reject/blackhole routes? Testing shows that
-       * there is no problems though and this is only way to "summarize"
-       * routes in ASBR at the moment. Maybe we need just a better generalised
-       * solution for these types?
-       *
-       * if ( CHECK_FLAG (api.flags, ZEBRA_FLAG_BLACKHOLE)
-       *     || CHECK_FLAG (api.flags, ZEBRA_FLAG_REJECT))
-       * return 0;
-       */
+      for (i = 0; i < api.nexthop_num; i++)
+        {
+          nexthop.s_addr = 0;
+          ifindex = 0;
+
+          if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IPV4))
+            nexthop.s_addr = api.nexthop[i].gw.ipv4.s_addr;
+
+          if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IFINDEX))
+            ifindex = api.nexthop[i].intf.index;
+
+          if (command == ZEBRA_IPV4_ROUTE_ADD)
+            {
+              /* XXX|HACK|TODO|FIXME:
+               * Maybe we should ignore reject/blackhole routes? Testing shows that
+               * there is no problems though and this is only way to "summarize"
+               * routes in ASBR at the moment. Maybe we need just a better generalised
+               * solution for these types?
+               *
+               * if ( CHECK_FLAG (api.flags, ZEBRA_FLAG_BLACKHOLE)
+               *     || CHECK_FLAG (api.flags, ZEBRA_FLAG_REJECT))
+               * return 0;
+               */
         
-      ei = ospf_external_info_add (api.type, p, ifindex, nexthop);
+              ei = ospf_external_info_add (api.type, p, ifindex, nexthop);
 
-      if (ospf->router_id.s_addr == 0)
-        /* Set flags to generate AS-external-LSA originate event
-           for each redistributed protocols later. */
-        ospf->external_origin |= (1 << api.type);
-      else
-        {
-          if (ei)
+              if (ospf->router_id.s_addr == 0)
+                /* Set flags to generate AS-external-LSA originate event
+                   for each redistributed protocols later. */
+                ospf->external_origin |= (1 << api.type);
+              else
+                {
+                  if (ei)
+                    {
+                      if (is_prefix_default (&p))
+                        ospf_external_lsa_refresh_default (ospf);
+                      else
+                        {
+                          struct ospf_lsa *current;
+
+                          current = ospf_external_info_find_lsa (ospf, &ei->p);
+                          if (!current)
+                            ospf_external_lsa_originate (ospf, ei);
+                          else if (IS_LSA_MAXAGE (current))
+                            ospf_external_lsa_refresh (ospf, current,
+                                                       ei, LSA_REFRESH_FORCE);
+                          else
+                            zlog_warn ("ospf_zebra_read_ipv4() : %s already exists",
+                                       inet_ntoa (p.prefix));
+                        }
+                    }
+                }
+            }
+          else                          /* if (command == ZEBRA_IPV4_ROUTE_DELETE) */
             {
+              ospf_external_info_delete (api.type, p);
               if (is_prefix_default (&p))
                 ospf_external_lsa_refresh_default (ospf);
               else
-                {
-                  struct ospf_lsa *current;
-
-                  current = ospf_external_info_find_lsa (ospf, &ei->p);
-                  if (!current)
-                    ospf_external_lsa_originate (ospf, ei);
-                  else if (IS_LSA_MAXAGE (current))
-                    ospf_external_lsa_refresh (ospf, current,
-                                               ei, LSA_REFRESH_FORCE);
-                  else
-                    zlog_warn ("ospf_zebra_read_ipv4() : %s already exists",
-                               inet_ntoa (p.prefix));
-                }
+                ospf_external_lsa_flush (ospf, api.type, &p, ifindex /*, nexthop */);
             }
         }
     }
-  else                          /* if (command == ZEBRA_IPV4_ROUTE_DELETE) */
-    {
-      ospf_external_info_delete (api.type, p);
-      if (is_prefix_default (&p))
-        ospf_external_lsa_refresh_default (ospf);
-      else
-        ospf_external_lsa_flush (ospf, api.type, &p, ifindex /*, nexthop */);
-    }
 
   return 0;
 }
diff --git a/redhat/Makefile.am b/redhat/Makefile.am
index 6a3d38f..71bdd3a 100644
--- a/redhat/Makefile.am
+++ b/redhat/Makefile.am
@@ -1,4 +1,4 @@
 
 EXTRA_DIST = quagga.pam quagga.sysconfig quagga.spec quagga.logrotate \
 	zebra.init ripd.init ospfd.init ripngd.init ospf6d.init bgpd.init \
-	isisd.init watchquagga.init quagga.pam.stack
+	isisd.init ldpd.init watchquagga.init quagga.pam.stack
diff --git a/redhat/quagga.spec.in b/redhat/quagga.spec.in
index 0b2659f..37e6d49 100644
--- a/redhat/quagga.spec.in
+++ b/redhat/quagga.spec.in
@@ -15,6 +15,7 @@
 %{!?with_vtysh:		%define	with_vtysh	1 }
 %{!?with_pam:		%define	with_pam	1 }
 %{!?with_ipv6:		%define	with_ipv6	1 }
+%{!?with_mpls:		%define	with_mpls	1 }
 %{!?with_ospfclient:	%define	with_ospfclient 1 }
 %{!?with_ospfapi:	%define	with_ospfapi	1 }
 %{!?with_irdp:		%define	with_irdp	1 }
@@ -79,21 +80,27 @@
 %define		daemon_other	""
 %endif
 
-%define		all_daemons	%{daemon_list} %{daemonv6_list} %{daemon_other} watchquagga
+%if %{with_mpls}
+%define		daemon_mpls	ldpd rsvpd
+%else
+%define		daemon_mpls	""
+%endif
+
+%define		all_daemons	%{daemon_list} %{daemonv6_list} %{daemon_other} %{daemon_mpls} watchquagga
 
 # allow build dir to be kept
 %{!?keep_build:		%define		keep_build	0 }
 
-#release sub-revision (the two digits after the CONFDATE)
-%{!?release_rev:	%define		release_rev	01 }
+#release
+%{!?release_rev:	%define		release_rev	1 }
 
 Summary: Routing daemon
 Name:		quagga
 Version:	@VERSION@
-Release:	@CONFDATE@%{release_rev}
+Release:	%{release_rev}%{dist}.mpls.%{subver}
 License:	GPL
 Group: System Environment/Daemons
-Source0:	http://www.quagga.net/snapshots/cvs/%{name}-%{version}.tar.gz
+Source0:	http://www.quagga.net/download/%{name}-%{version}.tar.gz
 URL:		http://www.quagga.net
 %if %{with_snmp}
 BuildRequires:	net-snmp-devel
@@ -144,7 +151,6 @@ developing OSPF-API and quagga applications.
 %setup  -q
 
 %build
-
 # For standard gcc verbosity, uncomment these lines:
 #CFLAGS="%{optflags} -Wall -Wsign-compare -Wpointer-arith"
 #CFLAGS="${CFLAGS} -Wbad-function-cast -Wwrite-strings"
@@ -154,6 +160,7 @@ developing OSPF-API and quagga applications.
 #CFLAGS="${CFLAGS} -Wmissing-declarations -Wmissing-noreturn"
 #CFLAGS="${CFLAGS} -Wmissing-format-attribute -Wunreachable-code"
 #CFLAGS="${CFLAGS} -Wpacked -Wpadded"
+export CPPFLAGS="-I %{zeb_src}/include ${CPPFLAGS}"
 
 %configure \
 %if !%{with_shared}
@@ -162,6 +169,9 @@ developing OSPF-API and quagga applications.
 %if %{with_ipv6}
 	--enable-ipv6 \
 %endif
+%if %{with_mpls}
+	--enable-mpls=%{with_mpls} \
+%endif
 %if %{with_snmp}
 	--enable-snmp \
 %endif
@@ -303,6 +313,10 @@ zebra_spec_add_service ospfapi  2607/tcp "OSPF-API"
 %if %{with_isisd}
 zebra_spec_add_service isisd    2608/tcp "ISISd vty"
 %endif
+%if %{with_mpls}
+zebra_spec_add_service ldpd    2610/tcp "LDPd vty"
+zebra_spec_add_service rsvpd   2611/tcp "RSVPd vty"
+%endif
 
 for daemon in %daemon_list ; do
 	/sbin/chkconfig --add ${daemon}
@@ -410,6 +424,10 @@ rm -rf $RPM_BUILD_ROOT
 %if %{with_isisd}
 %{_sbindir}/isisd
 %endif
+%if %{with_mpls}
+%{_sbindir}/ldpd
+%{_sbindir}/rsvpd
+%endif
 %dir %attr(755,root,root) %{_libdir}
 %if %{with_shared}
 %dir %{_libdir}
diff --git a/redhat/quagga.sysconfig b/redhat/quagga.sysconfig
index 9e9da5e..12fb5da 100644
--- a/redhat/quagga.sysconfig
+++ b/redhat/quagga.sysconfig
@@ -9,6 +9,7 @@ RIPD_OPTS="-A 127.0.0.1 -f ${QCONFDIR}/ripd.conf"
 RIPNGD_OPTS="-A ::1 -f ${QCONFDIR}/ripngd.conf"
 ZEBRA_OPTS="-A 127.0.0.1 -f ${QCONFDIR}/zebra.conf"
 ISISD_OPTS="-A ::1 -f ${QCONFDIR}/isisd.conf"
+LDPD_OPTS="-A 127.0.0.1 -f ${QCONFDIR}/ldpd.conf"
 
 # Watchquagga configuration (please check timer values before using):
 WATCH_OPTS=""
diff --git a/ripd/rip_zebra.c b/ripd/rip_zebra.c
index b924199..77668af 100644
--- a/ripd/rip_zebra.c
+++ b/ripd/rip_zebra.c
@@ -48,8 +48,8 @@ rip_zebra_ipv4_add (struct prefix_ipv4 *p, struct in_addr *nexthop,
       api.message = 0;
       SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
       api.nexthop_num = 1;
-      api.nexthop = &nexthop;
-      api.ifindex_num = 0;
+      api.nexthop[0].type = ZEBRA_NEXTHOP_IPV4;
+      api.nexthop[0].gw.ipv4.s_addr = nexthop->s_addr;
       SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);
       api.metric = metric;
 
@@ -78,8 +78,8 @@ rip_zebra_ipv4_delete (struct prefix_ipv4 *p, struct in_addr *nexthop,
       api.message = 0;
       SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
       api.nexthop_num = 1;
-      api.nexthop = &nexthop;
-      api.ifindex_num = 0;
+      api.nexthop[0].type = ZEBRA_NEXTHOP_IPV4;
+      api.nexthop[0].gw.ipv4.s_addr = nexthop->s_addr;
       SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);
       api.metric = metric;
 
@@ -98,48 +98,38 @@ rip_zebra_read_ipv4 (int command, struct zclient *zclient, zebra_size_t length)
   unsigned long ifindex;
   struct in_addr nexthop;
   struct prefix_ipv4 p;
+  int i;
   
   s = zclient->ibuf;
-  ifindex = 0;
-  nexthop.s_addr = 0;
 
-  /* Type, flags, message. */
-  api.type = stream_getc (s);
-  api.flags = stream_getc (s);
-  api.message = stream_getc (s);
+  zapi_ipv4_read(s, length, &api, &p);
 
-  /* IPv4 prefix. */
-  memset (&p, 0, sizeof (struct prefix_ipv4));
-  p.family = AF_INET;
-  p.prefixlen = stream_getc (s);
-  stream_get (&p.prefix, s, PSIZE (p.prefixlen));
+  if (!CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))
+    api.distance = 255;
 
   /* Nexthop, ifindex, distance, metric. */
   if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
     {
-      api.nexthop_num = stream_getc (s);
-      nexthop.s_addr = stream_get_ipv4 (s);
-    }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_IFINDEX))
-    {
-      api.ifindex_num = stream_getc (s);
-      ifindex = stream_getl (s);
+      for (i = 0; i < api.nexthop_num; i++)
+        {
+          ifindex = 0;
+          nexthop.s_addr = 0;
+
+          if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IPV4))
+            nexthop.s_addr = api.nexthop[i].gw.ipv4.s_addr;
+
+          if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IFINDEX))
+            ifindex = api.nexthop[i].intf.index;
+
+          /* Then fetch IPv4 prefixes. */
+          if (command == ZEBRA_IPV4_ROUTE_ADD)
+            rip_redistribute_add (api.type, RIP_ROUTE_REDISTRIBUTE, &p,
+                                  ifindex, &nexthop, api.metric, api.distance);
+          else 
+            rip_redistribute_delete (api.type, RIP_ROUTE_REDISTRIBUTE,
+                                     &p, ifindex);
+        }
     }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))
-    api.distance = stream_getc (s);
-  else
-    api.distance = 255;
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))
-    api.metric = stream_getl (s);
-  else
-    api.metric = 0;
-
-  /* Then fetch IPv4 prefixes. */
-  if (command == ZEBRA_IPV4_ROUTE_ADD)
-    rip_redistribute_add (api.type, RIP_ROUTE_REDISTRIBUTE, &p, ifindex, 
-                          &nexthop, api.metric, api.distance);
-  else 
-    rip_redistribute_delete (api.type, RIP_ROUTE_REDISTRIBUTE, &p, ifindex);
 
   return 0;
 }
diff --git a/ripngd/ripng_zebra.c b/ripngd/ripng_zebra.c
index 1f9bee0..4e97fa5 100644
--- a/ripngd/ripng_zebra.c
+++ b/ripngd/ripng_zebra.c
@@ -52,13 +52,11 @@ ripng_zebra_ipv6_add (struct prefix_ipv6 *p, struct in6_addr *nexthop,
     {
       api.type = ZEBRA_ROUTE_RIPNG;
       api.flags = 0;
-      api.message = 0;
-      SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
+      api.message = ZAPI_MESSAGE_NEXTHOP;
       api.nexthop_num = 1;
-      api.nexthop = &nexthop;
-      SET_FLAG (api.message, ZAPI_MESSAGE_IFINDEX);
-      api.ifindex_num = 1;
-      api.ifindex = &ifindex;
+      api.nexthop[0].type = ZEBRA_NEXTHOP_IPV6|ZEBRA_NEXTHOP_IFINDEX;
+      memcpy (&api.nexthop[0].gw.ipv6, nexthop, sizeof (*nexthop));
+      api.nexthop[0].intf.index = ifindex;
       SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);
       api.metric = metric;
       
@@ -76,14 +74,12 @@ ripng_zebra_ipv6_delete (struct prefix_ipv6 *p, struct in6_addr *nexthop,
     {
       api.type = ZEBRA_ROUTE_RIPNG;
       api.flags = 0;
-      api.message = 0;
-      SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);
+      api.message = ZAPI_MESSAGE_NEXTHOP;
       api.nexthop_num = 1;
-      api.nexthop = &nexthop;
-      SET_FLAG (api.message, ZAPI_MESSAGE_IFINDEX);
-      api.ifindex_num = 1;
-      api.ifindex = &ifindex;
-
+      api.nexthop[0].type = ZEBRA_NEXTHOP_IPV6|ZEBRA_NEXTHOP_IFINDEX;
+      memcpy (&api.nexthop[0].gw.ipv6, nexthop, sizeof (*nexthop));
+      api.nexthop[0].intf.index = ifindex;
+      
       zapi_ipv6_route (ZEBRA_IPV6_ROUTE_DELETE, zclient, p, &api);
     }
 }
@@ -98,46 +94,35 @@ ripng_zebra_read_ipv6 (int command, struct zclient *zclient,
   unsigned long ifindex;
   struct in6_addr nexthop;
   struct prefix_ipv6 p;
+  int i;
 
   s = zclient->ibuf;
-  ifindex = 0;
-  memset (&nexthop, 0, sizeof (struct in6_addr));
 
-  /* Type, flags, message. */
-  api.type = stream_getc (s);
-  api.flags = stream_getc (s);
-  api.message = stream_getc (s);
-
-  /* IPv6 prefix. */
-  memset (&p, 0, sizeof (struct prefix_ipv6));
-  p.family = AF_INET6;
-  p.prefixlen = stream_getc (s);
-  stream_get (&p.prefix, s, PSIZE (p.prefixlen));
+  zapi_ipv6_read (s, length, &api, &p);
 
   /* Nexthop, ifindex, distance, metric. */
   if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
     {
-      api.nexthop_num = stream_getc (s);
-      stream_get (&nexthop, s, 16);
-    }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_IFINDEX))
-    {
-      api.ifindex_num = stream_getc (s);
-      ifindex = stream_getl (s);
+      for (i = 0; i < api.nexthop_num; i++)
+        {
+          ifindex = 0;
+          memset (&nexthop, 0, sizeof (struct in6_addr));
+
+          if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IPV4))
+            memcpy(&nexthop, &api.nexthop[i].gw.ipv6, sizeof (nexthop));
+
+          if (CHECK_FLAG (api.nexthop[i].type, ZEBRA_NEXTHOP_IFINDEX))
+            ifindex = api.nexthop[i].intf.index;
+
+          if (command == ZEBRA_IPV6_ROUTE_ADD)
+            ripng_redistribute_add (api.type, RIPNG_ROUTE_REDISTRIBUTE,
+                                    &p, ifindex, &nexthop);
+          else
+            ripng_redistribute_delete (api.type, RIPNG_ROUTE_REDISTRIBUTE,
+                                       &p, ifindex);
+
+        }
     }
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))
-    api.distance = stream_getc (s);
-  else
-    api.distance = 0;
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))
-    api.metric = stream_getl (s);
-  else
-    api.metric = 0;
-
-  if (command == ZEBRA_IPV6_ROUTE_ADD)
-    ripng_redistribute_add (api.type, RIPNG_ROUTE_REDISTRIBUTE, &p, ifindex, &nexthop);
-  else
-    ripng_redistribute_delete (api.type, RIPNG_ROUTE_REDISTRIBUTE, &p, ifindex);
 
   return 0;
 }
diff --git a/vtysh/Makefile.am b/vtysh/Makefile.am
index dbd1d3d..6b2a1af 100644
--- a/vtysh/Makefile.am
+++ b/vtysh/Makefile.am
@@ -21,14 +21,18 @@ EXTRA_DIST = extract.pl
 vtysh_cmd_FILES = $(top_srcdir)/bgpd/*.c $(top_srcdir)/isisd/*.c \
 		  $(top_srcdir)/ospfd/*.c $(top_srcdir)/ospf6d/*.c \
 		  $(top_srcdir)/ripd/*.c $(top_srcdir)/ripngd/*.c \
+		  $(top_srcdir)/ldpd/*.c \
 		  $(top_srcdir)/lib/keychain.c $(top_srcdir)/lib/routemap.c \
 		  $(top_srcdir)/lib/filter.c $(top_srcdir)/lib/plist.c \
 		  $(top_srcdir)/lib/distribute.c $(top_srcdir)/lib/if_rmap.c \
 		  $(top_srcdir)/lib/vty.c $(top_srcdir)/zebra/debug.c \
 		  $(top_srcdir)/zebra/interface.c \
+		  $(top_srcdir)/zebra/if_tunnel.c \
+		  $(top_srcdir)/zebra/if_vlan.c \
 		  $(top_srcdir)/zebra/irdp_interface.c \
 		  $(top_srcdir)/zebra/rtadv.c $(top_srcdir)/zebra/zebra_vty.c \
-		  $(top_srcdir)/zebra/zserv.c $(top_srcdir)/zebra/router-id.c
+		  $(top_srcdir)/zebra/zserv.c $(top_srcdir)/zebra/router-id.c \
+		  $(top_srcdir)/zebra/mpls_vty.c
 
 vtysh_cmd.c: $(vtysh_cmd_FILES)
 	./$(EXTRA_DIST) $(vtysh_cmd_FILES) > vtysh_cmd.c
diff --git a/vtysh/extract.pl.in b/vtysh/extract.pl.in
index 789819c..7a34fd6 100755
--- a/vtysh/extract.pl.in
+++ b/vtysh/extract.pl.in
@@ -31,6 +31,8 @@ print <<EOF;
 EOF
 
 $ignore{'"interface IFNAME"'} = "ignore";
+$ignore{'"create tunnel IFNAME"'} = "ignore";
+$ignore{'"tunnel mode mpls"'} = "ignore";
 $ignore{'"ip vrf NAME"'} = "ignore";
 $ignore{'"router rip"'} = "ignore";
 $ignore{'"router ripng"'} = "ignore";
@@ -41,6 +43,9 @@ $ignore{'"router bgp CMD_AS_RANGE"'} = "ignore";
 $ignore{'"router bgp CMD_AS_RANGE view WORD"'} = "ignore";
 $ignore{'"router isis WORD"'} = "ignore";
 $ignore{'"router zebra"'} = "ignore";
+$ignore{'"mpls ldp"'} = "ignore";
+$ignore{'"mpls ip"'} = "ignore";
+$ignore{'"mpls static <0-255>"'} = "ignore";
 $ignore{'"address-family ipv4"'} = "ignore";
 $ignore{'"address-family ipv4 (unicast|multicast)"'} = "ignore";
 $ignore{'"address-family ipv6"'} = "ignore";
diff --git a/vtysh/vtysh.c b/vtysh/vtysh.c
index 9f47515..041b1d7 100644
--- a/vtysh/vtysh.c
+++ b/vtysh/vtysh.c
@@ -57,6 +57,7 @@ struct vtysh_client
   { .fd = -1, .name = "ospf6d", .flag = VTYSH_OSPF6D, .path = OSPF6_VTYSH_PATH},
   { .fd = -1, .name = "bgpd", .flag = VTYSH_BGPD, .path = BGP_VTYSH_PATH},
   { .fd = -1, .name = "isisd", .flag = VTYSH_ISISD, .path = ISIS_VTYSH_PATH},
+  { .fd = -1, .name = "ldpd", .flag = VTYSH_LDPD, .path = LDP_VTYSH_PATH},
 };
 
 #define VTYSH_INDEX_MAX (sizeof(vtysh_client)/sizeof(vtysh_client[0]))
@@ -728,12 +729,44 @@ struct cmd_node isis_node =
   "%s(config-router)# ",
 };
 
+/* LDP node structure. */
+struct cmd_node mpls_ldp_node =
+{
+  LDP_NODE,
+  "%s(config-ldp)# ",
+};
+
+/* MPLS labelspace node structure. */
+struct cmd_node mpls_static_node =
+{
+  MPLS_LABELSPACE_NODE,
+  "%s(config-ls)# ",
+};
+
+struct cmd_node tunnel_node =
+{
+  TUNNEL_NODE,
+  "%s(config-tun)# ",
+};
+
+struct cmd_node mpls_tunnel_node =
+{
+  MPLS_TUNNEL_NODE,
+  "%s(config-tun)# ",
+};
+
 struct cmd_node interface_node =
 {
   INTERFACE_NODE,
   "%s(config-if)# ",
 };
 
+struct cmd_node ldp_if_node =
+{
+  LDP_IF_NODE,
+  "%s(config-if-ldp)# ",
+};
+
 struct cmd_node rmap_node =
 {
   RMAP_NODE,
@@ -952,6 +985,18 @@ DEFUNSH (VTYSH_RIPD,
   return CMD_SUCCESS;
 }
 
+DEFUNSH (VTYSH_ZEBRA,
+	 mpls_static,
+	 mpls_static_cmd,
+	 "mpls static <0-255>",
+	 "Multi-Protocol Label Switching configuration\n"
+	 "Static label information"
+	 "Labelspace number (0 = global)")
+{
+  vty->node = MPLS_LABELSPACE_NODE;
+  return CMD_SUCCESS;
+}
+
 DEFUNSH (VTYSH_RIPD,
 	 router_rip,
 	 router_rip_cmd,
@@ -1008,6 +1053,28 @@ DEFUNSH (VTYSH_ISISD,
   return CMD_SUCCESS;
 }
 
+DEFUNSH (VTYSH_LDPD,
+	 vtysh_mpls_ldp,
+	 vtysh_mpls_ldp_cmd,
+	 "mpls ldp",
+	 "Multi-Protocol Label Switching configuration\n"
+	 "Dynamic label distribution configuration")
+{
+  vty->node = LDP_NODE;
+  return CMD_SUCCESS;
+}
+
+DEFUNSH (VTYSH_LDPD,
+	 vtysh_mpls_ip,
+	 vtysh_mpls_ip_cmd,
+	 "mpls ip",
+	 "MPLS interface configuration\n"
+	 "Dynamic label distribution via LDP\n")
+{
+  vty->node = LDP_IF_NODE;
+  return CMD_SUCCESS;
+}
+
 DEFUNSH (VTYSH_RMAP,
 	 route_map,
 	 route_map_cmd,
@@ -1078,9 +1145,13 @@ vtysh_exit (struct vty *vty)
       vty->node = ENABLE_NODE;
       break;
     case INTERFACE_NODE:
+    case TUNNEL_NODE:
+    case MPLS_TUNNEL_NODE:
     case ZEBRA_NODE:
     case BGP_NODE:
     case RIP_NODE:
+    case LDP_NODE:
+    case MPLS_LABELSPACE_NODE:
     case RIPNG_NODE:
     case OSPF_NODE:
     case OSPF6_NODE:
@@ -1103,6 +1174,9 @@ vtysh_exit (struct vty *vty)
     case KEYCHAIN_KEY_NODE:
       vty->node = KEYCHAIN_NODE;
       break;
+    case LDP_IF_NODE:
+      vty->node = INTERFACE_NODE;
+      break;
     default:
       break;
     }
@@ -1152,6 +1226,21 @@ ALIAS (vtysh_exit_zebra,
        "quit",
        "Exit current mode and down to previous mode\n")
 
+DEFUNSH (VTYSH_ZEBRA,
+	 vtysh_exit_mpls_ls,
+	 vtysh_exit_mpls_ls_cmd,
+	 "exit",
+	 "Exit current mode and down to previous mode\n")
+{
+  return vtysh_exit (vty);
+}
+
+ALIAS (vtysh_exit_mpls_ls,
+       vtysh_quit_mpls_ls_cmd,
+       "quit",
+       "Exit current mode and down to previous mode\n")
+
+
 DEFUNSH (VTYSH_RIPD,
 	 vtysh_exit_ripd,
 	 vtysh_exit_ripd_cmd,
@@ -1250,6 +1339,34 @@ ALIAS (vtysh_exit_isisd,
        "quit",
        "Exit current mode and down to previous mode\n")
 
+DEFUNSH (VTYSH_LDPD,
+	 vtysh_exit_ldpd,
+	 vtysh_exit_ldpd_cmd,
+	 "exit",
+	 "Exit current mode and down to previous mode\n")
+{
+  return vtysh_exit (vty);
+}
+
+ALIAS (vtysh_exit_ldpd,
+       vtysh_quit_ldpd_cmd,
+       "quit",
+       "Exit current mode and down to previous mode\n")
+
+DEFUNSH (VTYSH_LDPD,
+	 vtysh_exit_ldp_if,
+	 vtysh_exit_ldp_if_cmd,
+	 "exit",
+	 "Exit current mode and down to previous mode\n")
+{
+  return vtysh_exit (vty);
+}
+
+ALIAS (vtysh_exit_ldp_if,
+       vtysh_quit_ldp_if_cmd,
+       "quit",
+       "Exit current mode and down to previous mode\n")
+
 DEFUNSH (VTYSH_ALL,
          vtysh_exit_line_vty,
          vtysh_exit_line_vty_cmd,
@@ -1264,6 +1381,52 @@ ALIAS (vtysh_exit_line_vty,
        "quit",
        "Exit current mode and down to previous mode\n")
 
+DEFUNSH (VTYSH_ZEBRA,
+	 vtysh_exit_tunnel,
+	 vtysh_exit_tunnel_cmd,
+	 "exit",
+	 "Exit current mode and down to previous mode\n")
+{
+  return vtysh_exit (vty);
+}
+
+ALIAS (vtysh_exit_tunnel,
+       vtysh_quit_tunnel_cmd,
+       "quit",
+       "Exit current mode and down to previous mode\n")
+
+DEFUNSH (VTYSH_ZEBRA,
+	 vtysh_tunnel,
+	 vtysh_tunnel_cmd,
+	 "create tunnel IFNAME",
+	 "Create virtual interfaces\n"
+	 "Create a tunnel interface\n"
+	 "Interface's name\n")
+{
+  vty->node = TUNNEL_NODE;
+  return CMD_SUCCESS;
+}
+
+DEFUNSH (VTYSH_ZEBRA,
+	 vtysh_tunnel_mode_mpls,
+	 vtysh_tunnel_mode_mpls_cmd,
+         "tunnel mode mpls",
+         "Tunnel configuration\n"
+         "Tunnel mode configuration\n"
+         "MPLS\n")
+{
+  vty->node = MPLS_TUNNEL_NODE;
+  return CMD_SUCCESS;
+}
+
+DEFSH (VTYSH_ZEBRA,
+       vtysh_no_tunnel_cmd,
+       "no create tunnel IFNAME",
+       NO_STR
+       "Delete a virtual interface\n"
+       "Delete a tunnel interface\n"
+       "Interface's name\n")
+
 DEFUNSH (VTYSH_INTERFACE,
 	 vtysh_interface,
 	 vtysh_interface_cmd,
@@ -2224,7 +2387,12 @@ vtysh_init_vty (void)
   /* Install nodes. */
   install_node (&bgp_node, NULL);
   install_node (&rip_node, NULL);
+  install_node (&mpls_ldp_node, NULL);
+  install_node (&mpls_static_node, NULL);
+  install_node (&tunnel_node, NULL);
+  install_node (&mpls_tunnel_node, NULL);
   install_node (&interface_node, NULL);
+  install_node (&ldp_if_node, NULL);
   install_node (&rmap_node, NULL);
   install_node (&zebra_node, NULL);
   install_node (&bgp_vpnv4_node, NULL);
@@ -2249,6 +2417,11 @@ vtysh_init_vty (void)
   vtysh_install_default (CONFIG_NODE);
   vtysh_install_default (BGP_NODE);
   vtysh_install_default (RIP_NODE);
+  vtysh_install_default (LDP_NODE);
+  vtysh_install_default (LDP_IF_NODE);
+  vtysh_install_default (MPLS_LABELSPACE_NODE);
+  vtysh_install_default (TUNNEL_NODE);
+  vtysh_install_default (MPLS_TUNNEL_NODE);
   vtysh_install_default (INTERFACE_NODE);
   vtysh_install_default (RMAP_NODE);
   vtysh_install_default (ZEBRA_NODE);
@@ -2276,6 +2449,16 @@ vtysh_init_vty (void)
   /* install_element (CONFIG_NODE, &vtysh_quit_all_cmd); */
   install_element (ENABLE_NODE, &vtysh_exit_all_cmd);
   install_element (ENABLE_NODE, &vtysh_quit_all_cmd);
+  install_element (TUNNEL_NODE, &vtysh_exit_tunnel_cmd);
+  install_element (TUNNEL_NODE, &vtysh_quit_tunnel_cmd);
+  install_element (MPLS_TUNNEL_NODE, &vtysh_exit_tunnel_cmd);
+  install_element (MPLS_TUNNEL_NODE, &vtysh_quit_tunnel_cmd);
+  install_element (MPLS_LABELSPACE_NODE, &vtysh_exit_mpls_ls_cmd);
+  install_element (MPLS_LABELSPACE_NODE, &vtysh_quit_mpls_ls_cmd);
+  install_element (LDP_NODE, &vtysh_exit_ldpd_cmd);
+  install_element (LDP_NODE, &vtysh_quit_ldpd_cmd);
+  install_element (LDP_IF_NODE, &vtysh_exit_ldpd_cmd);
+  install_element (LDP_IF_NODE, &vtysh_quit_ldpd_cmd);
   install_element (RIP_NODE, &vtysh_exit_ripd_cmd);
   install_element (RIP_NODE, &vtysh_quit_ripd_cmd);
   install_element (RIPNG_NODE, &vtysh_exit_ripngd_cmd);
@@ -2310,6 +2493,9 @@ vtysh_init_vty (void)
   /* "end" command. */
   install_element (CONFIG_NODE, &vtysh_end_all_cmd);
   install_element (ENABLE_NODE, &vtysh_end_all_cmd);
+  install_element (MPLS_LABELSPACE_NODE, &vtysh_end_all_cmd);
+  install_element (LDP_NODE, &vtysh_end_all_cmd);
+  install_element (LDP_IF_NODE, &vtysh_end_all_cmd);
   install_element (RIP_NODE, &vtysh_end_all_cmd);
   install_element (RIPNG_NODE, &vtysh_end_all_cmd);
   install_element (OSPF_NODE, &vtysh_end_all_cmd);
@@ -2325,12 +2511,17 @@ vtysh_init_vty (void)
   install_element (KEYCHAIN_KEY_NODE, &vtysh_end_all_cmd);
   install_element (RMAP_NODE, &vtysh_end_all_cmd);
   install_element (VTY_NODE, &vtysh_end_all_cmd);
+  install_element (TUNNEL_NODE, &vtysh_end_all_cmd);
+  install_element (MPLS_TUNNEL_NODE, &vtysh_end_all_cmd);
 
   install_element (INTERFACE_NODE, &interface_desc_cmd);
   install_element (INTERFACE_NODE, &no_interface_desc_cmd);
   install_element (INTERFACE_NODE, &vtysh_end_all_cmd);
   install_element (INTERFACE_NODE, &vtysh_exit_interface_cmd);
   install_element (INTERFACE_NODE, &vtysh_quit_interface_cmd);
+  install_element (INTERFACE_NODE, &vtysh_mpls_ip_cmd);
+  install_element (CONFIG_NODE, &mpls_static_cmd);
+  install_element (CONFIG_NODE, &vtysh_mpls_ldp_cmd);
   install_element (CONFIG_NODE, &router_rip_cmd);
 #ifdef HAVE_IPV6
   install_element (CONFIG_NODE, &router_ripng_cmd);
@@ -2360,6 +2551,10 @@ vtysh_init_vty (void)
   install_element (KEYCHAIN_NODE, &key_cmd);
   install_element (KEYCHAIN_NODE, &key_chain_cmd);
   install_element (KEYCHAIN_KEY_NODE, &key_chain_cmd);
+  install_element (CONFIG_NODE, &vtysh_tunnel_cmd);
+  install_element (TUNNEL_NODE, &vtysh_tunnel_mode_mpls_cmd);
+  install_element (MPLS_TUNNEL_NODE, &vtysh_tunnel_mode_mpls_cmd);
+  install_element (CONFIG_NODE, &vtysh_no_tunnel_cmd);
   install_element (CONFIG_NODE, &vtysh_interface_cmd);
   install_element (CONFIG_NODE, &vtysh_no_interface_cmd);
   install_element (ENABLE_NODE, &vtysh_show_running_config_cmd);
diff --git a/vtysh/vtysh.h b/vtysh/vtysh.h
index 3ed0dd3..c294a19 100644
--- a/vtysh/vtysh.h
+++ b/vtysh/vtysh.h
@@ -29,9 +29,10 @@
 #define VTYSH_OSPF6D 0x10
 #define VTYSH_BGPD   0x20
 #define VTYSH_ISISD  0x40
-#define VTYSH_ALL	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_BGPD|VTYSH_ISISD
+#define VTYSH_LDPD   0x80
+#define VTYSH_ALL	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_BGPD|VTYSH_ISISD|VTYSH_LDPD
 #define VTYSH_RMAP	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_BGPD
-#define VTYSH_INTERFACE	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_ISISD
+#define VTYSH_INTERFACE	  VTYSH_ZEBRA|VTYSH_RIPD|VTYSH_RIPNGD|VTYSH_OSPFD|VTYSH_OSPF6D|VTYSH_ISISD|VTYSH_LDPD
 
 /* vtysh local configuration file. */
 #define VTYSH_DEFAULT_CONFIG "vtysh.conf"
diff --git a/vtysh/vtysh_config.c b/vtysh/vtysh_config.c
index 70c3746..a827f98 100644
--- a/vtysh/vtysh_config.c
+++ b/vtysh/vtysh_config.c
@@ -190,6 +190,8 @@ vtysh_config_parse_line (const char *line)
 	config = config_get (INTERFACE_NODE, line);
       else if (strncmp (line, "router-id", strlen ("router-id")) == 0)
 	config = config_get (ZEBRA_NODE, line);
+      else if (strncmp(line, "mpls static", strlen("mpls static")) == 0)
+	config = config_get (MPLS_LABELSPACE_NODE, line);
       else if (strncmp (line, "router rip", strlen ("router rip")) == 0)
 	config = config_get (RIP_NODE, line);
       else if (strncmp (line, "router ripng", strlen ("router ripng")) == 0)
@@ -204,6 +206,8 @@ vtysh_config_parse_line (const char *line)
   	config = config_get (ISIS_NODE, line);
       else if (strncmp (line, "router bgp", strlen ("router bgp")) == 0)
 	config = config_get (BGP_NODE, line);
+      else if (strncmp (line, "mpls ldp", strlen ("mpls ldp")) == 0)
+	config = config_get (LDP_NODE, line);
       else if (strncmp (line, "route-map", strlen ("route-map")) == 0)
 	config = config_get (RMAP_NODE, line);
       else if (strncmp (line, "access-list", strlen ("access-list")) == 0)
diff --git a/zebra/Makefile.am b/zebra/Makefile.am
index 5d8db41..297226b 100644
--- a/zebra/Makefile.am
+++ b/zebra/Makefile.am
@@ -15,39 +15,50 @@ rtread_method = @RTREAD_METHOD@
 kernel_method = @KERNEL_METHOD@
 other_method = @OTHER_METHOD@
 ioctl_method = @IOCTL_METHOD@
+mpls_method = @MPLS_METHOD@
 
 otherobj = $(ioctl_method) $(ipforward) $(if_method) $(if_proc) \
-	$(rt_method) $(rtread_method) $(kernel_method) $(other_method)
+	$(rt_method) $(rtread_method) $(kernel_method) $(other_method) \
+	$(mpls_method)
 
 sbin_PROGRAMS = zebra
 
-noinst_PROGRAMS = testzebra
+#noinst_PROGRAMS = testzebra
+
+mpls_sources=
+mpls_headers=
+if MPLS_ENABLED
+mpls_sources+=mpls_vty.c mpls_lib.c
+mpls_headers+=mpls_vty.h mpls_lib.h
+endif
 
 zebra_SOURCES = \
 	zserv.c main.c interface.c connected.c zebra_rib.c zebra_routemap.c \
 	redistribute.c debug.c rtadv.c zebra_snmp.c zebra_vty.c \
-	irdp_main.c irdp_interface.c irdp_packet.c router-id.c
+	irdp_main.c irdp_interface.c irdp_packet.c router-id.c if_vlan.c \
+	if_tunnel.c $(mpls_sources)
 
-testzebra_SOURCES = test_main.c zebra_rib.c interface.c connected.c debug.c \
-	zebra_vty.c \
-	kernel_null.c  redistribute_null.c ioctl_null.c misc_null.c
+#testzebra_SOURCES = test_main.c zebra_rib.c interface.c connected.c debug.c \
+#	zebra_vty.c \
+#	kernel_null.c  redistribute_null.c ioctl_null.c misc_null.c
 
 noinst_HEADERS = \
 	connected.h ioctl.h rib.h rt.h zserv.h redistribute.h debug.h rtadv.h \
-	interface.h ipforward.h irdp.h router-id.h kernel_socket.h
+	interface.h ipforward.h irdp.h router-id.h kernel_socket.h netlink.h \
+	$(mpls_headers)
 
 zebra_LDADD = $(otherobj) $(LIBCAP) $(LIB_IPV6) ../lib/libzebra.la
 
-testzebra_LDADD = $(LIBCAP) $(LIB_IPV6) ../lib/libzebra.la
+#testzebra_LDADD = $(LIBCAP) $(LIB_IPV6) ../lib/libzebra.la
 
 zebra_DEPENDENCIES = $(otherobj)
 
 EXTRA_DIST = if_ioctl.c if_ioctl_solaris.c if_netlink.c if_proc.c \
         if_sysctl.c ipforward_aix.c ipforward_ews.c ipforward_proc.c \
-	ipforward_solaris.c ipforward_sysctl.c rt_ioctl.c rt_netlink.c \
+	ipforward_solaris.c ipforward_sysctl.c rt_ioctl.c netlink.c \
 	rt_socket.c rtread_netlink.c rtread_proc.c rtread_sysctl.c \
 	rtread_getmsg.c kernel_socket.c kernel_netlink.c mtu_kvm.c \
-	ioctl.c ioctl_solaris.c \
+	ioctl.c ioctl_solaris.c netlink.c\
 	GNOME-SMI GNOME-PRODUCT-ZEBRA-MIB
 
 #client : client_main.o ../lib/libzebra.la
diff --git a/zebra/connected.c b/zebra/connected.c
index ad3e960..c1388ed 100644
--- a/zebra/connected.c
+++ b/zebra/connected.c
@@ -174,6 +174,7 @@ void
 connected_up_ipv4 (struct interface *ifp, struct connected *ifc)
 {
   struct prefix_ipv4 p;
+  struct zapi_nexthop nh;
 
   if (! CHECK_FLAG (ifc->conf, ZEBRA_IFC_REAL))
     return;
@@ -188,8 +189,12 @@ connected_up_ipv4 (struct interface *ifp, struct connected *ifc)
   if (prefix_ipv4_any (&p))
     return;
 
-  rib_add_ipv4 (ZEBRA_ROUTE_CONNECT, 0, &p, NULL, NULL, ifp->ifindex,
-	RT_TABLE_MAIN, ifp->metric, 0);
+  memset (&nh, 0, sizeof (struct zapi_nexthop));
+  SET_FLAG(nh.type, ZEBRA_NEXTHOP_IFINDEX);
+  nh.intf.index = ifp->ifindex;
+
+  rib_add_route (ZEBRA_ROUTE_CONNECT, 0, (struct prefix*)&p,
+                 &nh, RT_TABLE_MAIN, ifp->metric, 0);
 
   rib_update ();
 }
@@ -280,6 +285,7 @@ void
 connected_down_ipv4 (struct interface *ifp, struct connected *ifc)
 {
   struct prefix_ipv4 p;
+  struct zapi_nexthop nh;
 
   if (! CHECK_FLAG (ifc->conf, ZEBRA_IFC_REAL))
     return;
@@ -294,8 +300,11 @@ connected_down_ipv4 (struct interface *ifp, struct connected *ifc)
   if (prefix_ipv4_any (&p))
     return;
 
-  /* Same logic as for connected_up_ipv4(): push the changes into the head. */
-  rib_delete_ipv4 (ZEBRA_ROUTE_CONNECT, 0, &p, NULL, ifp->ifindex, 0);
+  memset (&nh, 0, sizeof (struct zapi_nexthop));
+  SET_FLAG (nh.type, ZEBRA_NEXTHOP_IFINDEX);
+  nh.intf.index = ifp->ifindex;
+
+  rib_delete_route (ZEBRA_ROUTE_CONNECT, 0, (struct prefix*)&p, &nh, 0);
 
   rib_update ();
 }
@@ -325,6 +334,7 @@ void
 connected_up_ipv6 (struct interface *ifp, struct connected *ifc)
 {
   struct prefix_ipv6 p;
+  struct zapi_nexthop nh;
 
   if (! CHECK_FLAG (ifc->conf, ZEBRA_IFC_REAL))
     return;
@@ -335,13 +345,17 @@ connected_up_ipv6 (struct interface *ifp, struct connected *ifc)
   apply_mask_ipv6 (&p);
 
 #if ! defined (MUSICA) && ! defined (LINUX)
-  /* XXX: It is already done by rib_bogus_ipv6 within rib_add_ipv6 */
+  /* XXX: It is already done by rib_bogus_ipv6 within rib_add_route */
   if (IN6_IS_ADDR_UNSPECIFIED (&p.prefix))
     return;
 #endif
 
-  rib_add_ipv6 (ZEBRA_ROUTE_CONNECT, 0, &p, NULL, ifp->ifindex, 0,
-                ifp->metric, 0);
+  memset (&nh, 0, sizeof (struct zapi_nexthop));
+  SET_FLAG (nh.type, ZEBRA_NEXTHOP_IFINDEX);
+  nh.intf.index = ifp->ifindex;
+
+  rib_add_route (ZEBRA_ROUTE_CONNECT, 0, (struct prefix*)&p,
+                 &nh, 0, ifp->metric, 0);
 
   rib_update ();
 }
@@ -404,6 +418,7 @@ void
 connected_down_ipv6 (struct interface *ifp, struct connected *ifc)
 {
   struct prefix_ipv6 p;
+  struct zapi_nexthop nh;
 
   if (! CHECK_FLAG (ifc->conf, ZEBRA_IFC_REAL))
     return;
@@ -415,7 +430,11 @@ connected_down_ipv6 (struct interface *ifp, struct connected *ifc)
   if (IN6_IS_ADDR_UNSPECIFIED (&p.prefix))
     return;
 
-  rib_delete_ipv6 (ZEBRA_ROUTE_CONNECT, 0, &p, NULL, ifp->ifindex, 0);
+  memset (&nh, 0, sizeof (struct zapi_nexthop));
+  SET_FLAG (nh.type, ZEBRA_NEXTHOP_IFINDEX);
+  nh.intf.index = ifp->ifindex;
+
+  rib_delete_route (ZEBRA_ROUTE_CONNECT, 0, (struct prefix*)&p, &nh, 0);
 
   rib_update ();
 }
diff --git a/zebra/if_netlink.c b/zebra/if_netlink.c
index c9c1476..3cd6513 100644
--- a/zebra/if_netlink.c
+++ b/zebra/if_netlink.c
@@ -22,8 +22,7 @@
 
 #include <zebra.h>
 
-/* Extern from rt_netlink.c */  
-void interface_lookup_netlink ();  
+#include "zebra/rt_netlink.h"
 
 /* Interface information read by netlink. */
 void
diff --git a/zebra/interface.c b/zebra/interface.c
index 184b42a..34f06a6 100644
--- a/zebra/interface.c
+++ b/zebra/interface.c
@@ -88,6 +88,28 @@ if_zebra_new_hook (struct interface *ifp)
   return 0;
 }
 
+void
+if_zebra_delete_ops (struct interface *ifp)
+{
+  struct zebra_if *zebra_if = ifp->info;
+
+  if (!zebra_if)
+    return;
+
+  if (zebra_if->ops)
+    {
+      if (zebra_if->ops->free)
+	{
+          zebra_if->ops->free(ifp);
+	}
+      else
+	{
+	  XFREE (MTYPE_TMP, zebra_if->ops);
+	  zebra_if->ops = NULL;
+	}
+    }
+}
+
 /* Called when interface is deleted. */
 static int
 if_zebra_delete_hook (struct interface *ifp)
@@ -98,6 +120,20 @@ if_zebra_delete_hook (struct interface *ifp)
     {
       zebra_if = ifp->info;
 
+      /* Free interface specific ops block. */
+      if (zebra_if->ops)
+	{
+ 	  if (zebra_if->ops->free)
+	    {
+              zebra_if->ops->free(ifp);
+	    }
+	  else
+	    {
+	      XFREE (MTYPE_TMP, zebra_if->ops);
+	      zebra_if->ops = NULL;
+	    }
+	}
+
       /* Free installed address chains tree. */
       if (zebra_if->ipv4_subnets)
 	route_table_finish (zebra_if->ipv4_subnets);
@@ -673,6 +709,10 @@ if_dump_vty (struct vty *vty, struct interface *ifp)
   if (ifp->desc)
     vty_out (vty, "  Description: %s%s", ifp->desc,
 	     VTY_NEWLINE);
+
+  if (zebra_if->ops && zebra_if->ops->show)
+    zebra_if->ops->show (vty, ifp);
+
   if (ifp->ifindex == IFINDEX_INTERNAL)
     {
       vty_out(vty, "  pseudo interface%s", VTY_NEWLINE);
@@ -727,6 +767,14 @@ if_dump_vty (struct vty *vty, struct interface *ifp)
       vty_out(vty, "%s", VTY_NEWLINE);
     }
 
+#ifdef HAVE_MPLS
+  /* MPLS labelspace */
+  if (ifp->mpls_labelspace != -1)
+    {
+      vty_out(vty, "  MPLS labelspace %u", ifp->mpls_labelspace);
+      vty_out(vty, "%s", VTY_NEWLINE);
+    }
+#endif
   for (rn = route_top (zebra_if->ipv4_subnets); rn; rn = route_next (rn))
     {
       if (! rn->info)
@@ -1519,6 +1567,18 @@ if_config_write (struct vty *vty)
   for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))
     {
       struct zebra_if *if_data;
+
+      if_data = ifp->info;
+      
+      if (if_data->ops && if_data->ops->config)
+	if_data->ops->config (vty, ifp);
+
+      vty_out (vty, "!%s", VTY_NEWLINE);
+    }
+
+  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))
+    {
+      struct zebra_if *if_data;
       struct listnode *addrnode;
       struct connected *ifc;
       struct prefix *p;
@@ -1536,7 +1596,10 @@ if_config_write (struct vty *vty)
 	 while processing config script */
       if (ifp->bandwidth != 0)
 	vty_out(vty, " bandwidth %u%s", ifp->bandwidth, VTY_NEWLINE); 
-
+#ifdef HAVE_MPLS
+      if (ifp->mpls_labelspace != -1)
+	vty_out(vty, " mpls labelspace %u%s",ifp->mpls_labelspace,VTY_NEWLINE);
+#endif
       if (CHECK_FLAG(ifp->status, ZEBRA_INTERFACE_LINKDETECTION))
 	vty_out(vty, " link-detect%s", VTY_NEWLINE);
 
diff --git a/zebra/interface.h b/zebra/interface.h
index 0a6b036..f9f33bf 100644
--- a/zebra/interface.h
+++ b/zebra/interface.h
@@ -27,6 +27,7 @@
 #ifdef HAVE_IRDP
 #include "zebra/irdp.h"
 #endif
+#include "vty.h"
 
 /* For interface multicast configuration. */
 #define IF_ZEBRA_MULTICAST_UNSPEC 0
@@ -175,6 +176,26 @@ struct rtadvconf
 
 #endif /* RTADV */
 
+enum interface_type
+{
+  INTERFACE_TYPE_VLAN = 1,
+  INTERFACE_TYPE_TUNNEL,
+  INTERFACE_TYPE_MAX
+};
+
+struct interface_ops
+{
+  enum interface_type type;
+  void (*config)(struct vty*, struct interface*);
+  void (*show)(struct vty*, struct interface*);
+  int (*create)(struct interface*);
+  int (*delete)(struct interface*);
+  int (*create_check)(struct interface*);
+  int (*delete_check)(struct interface*);
+  void (*free)(struct interface*);
+  void *info;
+};
+
 /* `zebra' daemon local interface structure. */
 struct zebra_if
 {
@@ -193,6 +214,9 @@ struct zebra_if
   /* Installed addresses chains tree. */
   struct route_table *ipv4_subnets;
 
+  /* Interface specific operations. */
+  struct interface_ops *ops;
+
 #ifdef RTADV
   struct rtadvconf rtadv;
 #endif /* RTADV */
@@ -217,6 +241,7 @@ extern void if_up (struct interface *);
 extern void if_down (struct interface *);
 extern void if_refresh (struct interface *);
 extern void if_flags_update (struct interface *, uint64_t);
+extern void if_zebra_delete_ops (struct interface *);
 extern int if_subnet_add (struct interface *, struct connected *);
 extern int if_subnet_delete (struct interface *, struct connected *);
 
@@ -238,4 +263,7 @@ extern int ifaddr_proc_ipv6 (void);
 extern int if_kvm_get_mtu (struct interface *);
 #endif /* BSDI */
 
+extern void if_vlan_init();
+extern void if_tunnel_init();
+
 #endif /* _ZEBRA_INTERFACE_H */
diff --git a/zebra/ioctl.c b/zebra/ioctl.c
index d536771..c09476a 100644
--- a/zebra/ioctl.c
+++ b/zebra/ioctl.c
@@ -52,7 +52,7 @@ if_ioctl (u_long request, caddr_t buffer)
 {
   int sock;
   int ret;
-  int err;
+  int err = 0;
 
   if (zserv_privs.change(ZPRIVS_RAISE))
     zlog (NULL, LOG_ERR, "Can't raise privileges");
@@ -85,7 +85,7 @@ if_ioctl_ipv6 (u_long request, caddr_t buffer)
 {
   int sock;
   int ret;
-  int err;
+  int err = 0;
 
   if (zserv_privs.change(ZPRIVS_RAISE))
     zlog (NULL, LOG_ERR, "Can't raise privileges");
diff --git a/zebra/kernel_socket.c b/zebra/kernel_socket.c
index 2e04b03..9d5cccd 100644
--- a/zebra/kernel_socket.c
+++ b/zebra/kernel_socket.c
@@ -761,11 +761,13 @@ void
 rtm_read (struct rt_msghdr *rtm)
 {
   int flags;
-  u_char zebra_flags;
+  u_short zebra_flags;
   union sockunion dest, mask, gate;
   char ifname[INTERFACE_NAMSIZ + 1];
   short ifnlen = 0;
+  struct zapi_nexthop nh;
 
+  memset(&nh, 0, sizeof(struct zapi_nexthop));
   zebra_flags = 0;
 
   /* Read destination and netmask and gateway from rtm message
@@ -802,13 +804,20 @@ rtm_read (struct rt_msghdr *rtm)
 
   /* This is a reject or blackhole route */
   if (flags & RTF_REJECT)
-    SET_FLAG (zebra_flags, ZEBRA_FLAG_REJECT);
-  if (flags & RTF_BLACKHOLE)
-    SET_FLAG (zebra_flags, ZEBRA_FLAG_BLACKHOLE);
+    {
+      SET_FLAG (nh.type, ZEBRA_NEXTHOP_DROP);
+      nh.gw.drop = ZEBRA_DROP_REJECT;
+    }
+  else if (flags & RTF_BLACKHOLE)
+    {
+      SET_FLAG (nh.type, ZEBRA_NEXTHOP_DROP);
+      nh.gw.drop = ZEBRA_DROP_BLACKHOLE;
+    }
 
   if (dest.sa.sa_family == AF_INET)
     {
       struct prefix_ipv4 p;
+      struct zapi_nexthop znh;
 
       p.family = AF_INET;
       p.prefix = dest.sin.sin_addr;
@@ -816,6 +825,10 @@ rtm_read (struct rt_msghdr *rtm)
 	p.prefixlen = IPV4_MAX_PREFIXLEN;
       else
 	p.prefixlen = ip_masklen (mask.sin.sin_addr);
+
+      memset (&znh, 0, sizeof (struct zapi_nexthop));
+      znh.type = ZEBRA_NEXTHOP_IPV4;
+      znh.gw.ipv4 = gate.sin;
       
       /* Catch self originated messages and match them against our current RIB.
        * At the same time, ignore unconfirmed messages, they should be tracked
@@ -827,7 +840,7 @@ rtm_read (struct rt_msghdr *rtm)
         int ret;
         if (! IS_ZEBRA_DEBUG_RIB)
           return;
-        ret = rib_lookup_ipv4_route (&p, &gate); 
+        ret = rib_lookup_route_nexthop ((struct prefix*)&p, &znh); 
         inet_ntop (AF_INET, &p.prefix, buf, INET_ADDRSTRLEN);
         switch (rtm->rtm_type)
         {
@@ -891,17 +904,20 @@ rtm_read (struct rt_msghdr *rtm)
        * to specify the route really
        */
       if (rtm->rtm_type == RTM_CHANGE)
-        rib_delete_ipv4 (ZEBRA_ROUTE_KERNEL, zebra_flags, &p,
-                         NULL, 0, 0);
+        rib_delete_route (ZEBRA_ROUTE_KERNEL, zebra_flags,
+                          (struct prefix*)&p, &nh, 0);
+
+      nh.gw.ipv4 = gate.sin.sin_addr;
+      SET_FLAG (nh.type, ZEBRA_NEXTHOP_IPV4);
       
       if (rtm->rtm_type == RTM_GET 
           || rtm->rtm_type == RTM_ADD
           || rtm->rtm_type == RTM_CHANGE)
-	rib_add_ipv4 (ZEBRA_ROUTE_KERNEL, zebra_flags, 
-		      &p, &gate.sin.sin_addr, NULL, 0, 0, 0, 0);
+	rib_add_route (ZEBRA_ROUTE_KERNEL, zebra_flags, (struct prefix*)&p,
+                       &nh, NULL, 0, 0, 0);
       else
-	rib_delete_ipv4 (ZEBRA_ROUTE_KERNEL, zebra_flags, 
-		      &p, &gate.sin.sin_addr, 0, 0);
+	rib_delete_route (ZEBRA_ROUTE_KERNEL, zebra_flags,
+                          (struct prefix*)&p, &nh, 0);
     }
 #ifdef HAVE_IPV6
   if (dest.sa.sa_family == AF_INET6)
@@ -933,17 +949,26 @@ rtm_read (struct rt_msghdr *rtm)
        * to specify the route really
        */
       if (rtm->rtm_type == RTM_CHANGE)
-        rib_delete_ipv6 (ZEBRA_ROUTE_KERNEL, zebra_flags, &p,
+        rib_delete_route (ZEBRA_ROUTE_KERNEL, zebra_flags, (struct prefix*)&p,
                          NULL, 0, 0);
+
+      nh.gw.ipv6 = gate.sin6.sin_addr6;
+      SET_FLAG (nh.type, ZEBRA_NEXTHOP_IPV6);
+
+      if (ifindex)
+        {
+          nh.intf.index = ifindex;
+          SET_FLAG (nh.type, ZEBRA_NEXTHOP_IFINDEX);
+        }
       
       if (rtm->rtm_type == RTM_GET 
           || rtm->rtm_type == RTM_ADD
           || rtm->rtm_type == RTM_CHANGE)
-	rib_add_ipv6 (ZEBRA_ROUTE_KERNEL, zebra_flags,
-		      &p, &gate.sin6.sin6_addr, ifindex, 0, 0, 0);
+	rib_add_route (ZEBRA_ROUTE_KERNEL, zebra_flags, (struct prefix*)&p,
+                       &nh, 0, 0, 0);
       else
-	rib_delete_ipv6 (ZEBRA_ROUTE_KERNEL, zebra_flags,
-			 &p, &gate.sin6.sin6_addr, ifindex, 0);
+	rib_delete_route (ZEBRA_ROUTE_KERNEL, zebra_flags,
+                          (struct prefix*)&p, &nh, 0);
     }
 #endif /* HAVE_IPV6 */
 }
diff --git a/zebra/main.c b/zebra/main.c
index 61750f1..3785429 100644
--- a/zebra/main.c
+++ b/zebra/main.c
@@ -39,6 +39,7 @@
 #include "zebra/router-id.h"
 #include "zebra/irdp.h"
 #include "zebra/rtadv.h"
+#include "zebra/interface.h"
 
 /* Zebra instance */
 struct zebra_t zebrad =
@@ -169,6 +170,9 @@ sigint (void)
 
   if (!retain_mode)
     rib_close ();
+#ifdef HAVE_MPLS
+  mpls_close ();
+#endif
 #ifdef HAVE_IRDP
   irdp_finish();
 #endif
@@ -320,16 +324,24 @@ main (int argc, char **argv)
   /* Zebra related initialize. */
   zebra_init ();
   rib_init ();
+#ifdef HAVE_MPLS
+  mpls_init ();
+#endif
   zebra_if_init ();
   zebra_debug_init ();
   router_id_init();
   zebra_vty_init ();
+#ifdef HAVE_MPLS
+  mpls_vty_init ();
+#endif
   access_list_init ();
   prefix_list_init ();
   rtadv_init ();
 #ifdef HAVE_IRDP
   irdp_init();
 #endif
+  if_vlan_init();
+  if_tunnel_init();
 
   /* For debug purpose. */
   /* SET_FLAG (zebra_debug_event, ZEBRA_DEBUG_EVENT); */
@@ -338,6 +350,10 @@ main (int argc, char **argv)
   kernel_init ();
   interface_list ();
   route_read ();
+#ifdef HAVE_MPLS
+  mpls_kernel_init ();
+  mpls_read ();
+#endif
 
   /* Sort VTY commands. */
   sort_node ();
diff --git a/zebra/redistribute.c b/zebra/redistribute.c
index b7bd567..dfe8c6d 100644
--- a/zebra/redistribute.c
+++ b/zebra/redistribute.c
@@ -166,6 +166,38 @@ zebra_redistribute (struct zserv *client, int type)
 	    && zebra_check_addr (&rn->p))
 	  zsend_route_multipath (ZEBRA_IPV6_ROUTE_ADD, client, &rn->p, newrib);
 #endif /* HAVE_IPV6 */
+
+#ifdef HAVE_MPLS
+  {
+    struct listnode *node;
+    struct zmpls_in_segment *in;
+    struct zmpls_out_segment *out;
+    struct zmpls_ftn *ftn;
+    struct zmpls_xc *xc;
+    struct interface *ifp;
+
+    for (ALL_LIST_ELEMENTS_RO(iflist, node, ifp))
+      if (type == ZEBRA_ROUTE_STATIC &&
+          ifp->mpls_labelspace > -1)
+          zsend_mpls_labelspace_add (client, ifp);
+
+    for (ALL_LIST_ELEMENTS_RO(&mpls_in_segment_list, node, in))
+      if (type == in->owner)
+        zsend_mpls_in_segment_add (client, in);
+
+    for (ALL_LIST_ELEMENTS_RO(&mpls_out_segment_list, node, out))
+      if (type == out->owner)
+        zsend_mpls_out_segment_add (client, out);
+
+    for (ALL_LIST_ELEMENTS_RO(&mpls_xc_list, node, xc))
+      if (type == xc->owner)
+        zsend_mpls_xc_add (client, xc);
+
+    for (ALL_LIST_ELEMENTS_RO(&mpls_ftn_list, node, ftn))
+      if (type == ftn->owner)
+        zsend_mpls_ftn_add (client, ftn);
+  }
+#endif /* HAVE_MPLS */
 }
 
 void
@@ -174,6 +206,8 @@ redistribute_add (struct prefix *p, struct rib *rib)
   struct listnode *node, *nnode;
   struct zserv *client;
 
+  /* MPLS: check is there are any FTN waiting for this */
+
   for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))
     {
       if (is_default (p))
@@ -210,6 +244,8 @@ redistribute_delete (struct prefix *p, struct rib *rib)
   if (rib->distance == DISTANCE_INFINITY)
     return;
 
+  /* MPLS: check is there are any FTN depending on this */
+
   for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))
     {
       if (is_default (p))
@@ -255,6 +291,7 @@ zebra_redistribute_add (int command, struct zserv *client, int length)
     case ZEBRA_ROUTE_OSPF:
     case ZEBRA_ROUTE_OSPF6:
     case ZEBRA_ROUTE_BGP:
+    case ZEBRA_ROUTE_LDP:
       if (! client->redist[type])
 	{
 	  client->redist[type] = 1;
@@ -283,6 +320,7 @@ zebra_redistribute_delete (int command, struct zserv *client, int length)
     case ZEBRA_ROUTE_OSPF:
     case ZEBRA_ROUTE_OSPF6:
     case ZEBRA_ROUTE_BGP:
+    case ZEBRA_ROUTE_LDP:
       client->redist[type] = 0;
       break;
     default:
@@ -316,6 +354,29 @@ zebra_interface_up_update (struct interface *ifp)
 
   for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))
     zsend_interface_update (ZEBRA_INTERFACE_UP, client, ifp);
+
+#ifdef HAVE_MPLS
+  if (ifp->mpls_labelspace >= 0)
+    mpls_ctrl_set_interface_labelspace(ifp, ifp->mpls_labelspace);
+
+  /* MPLS: check if there are any NHLFE waiting for this */
+  if (if_is_operative(ifp))
+  {
+    struct zmpls_out_segment *out;
+    for (ALL_LIST_ELEMENTS_RO(&mpls_out_segment_list, node, out))
+    {
+      if ((out->installed) ||
+          !mpls_nexthop_ready(&out->nh))
+        continue;
+
+      out->installed = 1;
+      mpls_ctrl_nhlfe_register(out);
+      redistribute_add_mpls_out_segment (out);
+    }
+  } else {
+    assert(0);
+  }
+#endif /* HAVE_MPLS */
 }
 
 /* Interface down information. */
@@ -328,6 +389,21 @@ zebra_interface_down_update (struct interface *ifp)
   if (IS_ZEBRA_DEBUG_EVENT)
     zlog_debug ("MESSAGE: ZEBRA_INTERFACE_DOWN %s", ifp->name);
 
+#ifdef HAVE_MPLS
+  /* MPLS: check if there are any NHLFE depending on this */
+  struct zmpls_out_segment *out;
+  for (ALL_LIST_ELEMENTS_RO(&mpls_out_segment_list, node, out))
+  {
+    if ((!out->installed) ||
+        mpls_nexthop_ready(&out->nh))
+      continue;
+
+    redistribute_delete_mpls_out_segment (out);
+    mpls_ctrl_nhlfe_unregister(out);
+    out->installed = 0;
+  }
+#endif /* HAVE_MPLS */
+
   for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))
     zsend_interface_update (ZEBRA_INTERFACE_DOWN, client, ifp);
 }
@@ -345,6 +421,24 @@ zebra_interface_add_update (struct interface *ifp)
   for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))
     if (client->ifinfo)
       zsend_interface_add (client, ifp);
+
+#ifdef HAVE_MPLS
+  /* MPLS: check if there are any NHLFE waiting for this */
+  if (if_is_operative(ifp))
+  {
+    struct zmpls_out_segment *out;
+    for (ALL_LIST_ELEMENTS_RO(&mpls_out_segment_list, node, out))
+    {
+      if ((out->installed) ||
+          !mpls_nexthop_ready(&out->nh))
+        continue;
+
+      out->installed = 1;
+      mpls_ctrl_nhlfe_register(out);
+      redistribute_add_mpls_out_segment (out);
+    }
+  }
+#endif /* HAVE_MPLS */
 }
 
 void
@@ -356,6 +450,21 @@ zebra_interface_delete_update (struct interface *ifp)
   if (IS_ZEBRA_DEBUG_EVENT)
     zlog_debug ("MESSAGE: ZEBRA_INTERFACE_DELETE %s", ifp->name);
 
+#ifdef HAVE_MPLS
+  /* MPLS: check if there are any NHLFE depending on this */
+  struct zmpls_out_segment *out;
+  for (ALL_LIST_ELEMENTS_RO(&mpls_out_segment_list, node, out))
+  {
+    if ((!out->installed) ||
+        mpls_nexthop_ready(&out->nh))
+      continue;
+
+    out->installed = 0;
+    redistribute_delete_mpls_out_segment (out);
+    mpls_ctrl_nhlfe_unregister(out);
+  }
+#endif /* HAVE_MPLS */
+
   for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))
     if (client->ifinfo)
       zsend_interface_delete (client, ifp);
@@ -379,11 +488,29 @@ zebra_interface_address_add_update (struct interface *ifp,
 		  p->prefixlen, ifc->ifp->name);
     }
 
-  router_id_add_address(ifc);
-
   for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))
     if (client->ifinfo && CHECK_FLAG (ifc->conf, ZEBRA_IFC_REAL))
       zsend_interface_address (ZEBRA_INTERFACE_ADDRESS_ADD, client, ifp, ifc);
+
+  router_id_add_address(ifc);
+
+#ifdef HAVE_MPLS
+  /* MPLS: check if there are any NHLFE waiting for this */
+  if (if_is_operative(ifp))
+  {
+    struct zmpls_out_segment *out;
+    for (ALL_LIST_ELEMENTS_RO(&mpls_out_segment_list, node, out))
+    {
+      if ((out->installed) ||
+          !mpls_nexthop_ready(&out->nh))
+        continue;
+
+      out->installed = 1;
+      mpls_ctrl_nhlfe_register(out);
+      redistribute_add_mpls_out_segment (out);
+    }
+  }
+#endif /* HAVE_MPLS */
 }
 
 /* Interface address deletion. */
@@ -404,9 +531,240 @@ zebra_interface_address_delete_update (struct interface *ifp,
 		 p->prefixlen, ifc->ifp->name);
     }
 
+#ifdef HAVE_MPLS
+  /* MPLS: check if there are any NHLFE depending on this */
+  struct zmpls_out_segment *out;
+  for (ALL_LIST_ELEMENTS_RO(&mpls_out_segment_list, node, out))
+  {
+    if ((!out->installed) ||
+        mpls_nexthop_ready(&out->nh))
+      continue;
+
+    redistribute_delete_mpls_out_segment (out);
+    mpls_ctrl_nhlfe_unregister(out);
+    out->installed = 0;
+  }
+#endif /* HAVE_MPLS */
+
   router_id_del_address(ifc);
 
   for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))
     if (client->ifinfo && CHECK_FLAG (ifc->conf, ZEBRA_IFC_REAL))
       zsend_interface_address (ZEBRA_INTERFACE_ADDRESS_DELETE, client, ifp, ifc);
 }
+
+#ifdef HAVE_MPLS
+void
+redistribute_add_mpls_xc (struct zmpls_xc *xc)
+{
+  struct listnode *node;
+  struct zserv *client;
+
+  /* Check to see and and ILM are waiting for this xc */
+  struct zmpls_in_segment *in;
+  for (ALL_LIST_ELEMENTS_RO(&mpls_in_segment_list, node, in))
+  {
+    if (in->installed || in->xc != xc->index)
+      continue;
+
+    in->installed = 1;
+    mpls_ctrl_ilm_register (in);
+    redistribute_add_mpls_in_segment (in);
+  }
+
+  for (ALL_LIST_ELEMENTS_RO(zebrad.client_list, node, client))
+     if (client->redist[xc->owner])
+	zsend_mpls_xc_add (client, xc);
+}
+
+void
+redistribute_delete_mpls_xc (struct zmpls_xc *xc)
+{
+  struct listnode *node;
+  struct zserv *client;
+
+  for (ALL_LIST_ELEMENTS_RO(zebrad.client_list, node, client))
+     if (client->redist[xc->owner])
+	zsend_mpls_xc_delete (client, xc);
+
+  /* Check to see and and ILM depend on this xc */
+  struct zmpls_in_segment *in;
+  for (ALL_LIST_ELEMENTS_RO(&mpls_in_segment_list, node, in))
+  {
+    if ((!in->installed) || in->xc != xc->index)
+      continue;
+
+    in->installed = 0;
+    mpls_ctrl_ilm_unregister (in);
+    redistribute_delete_mpls_in_segment (in);
+  }
+}
+
+void
+redistribute_add_mpls_in_segment (struct zmpls_in_segment *in)
+{
+  struct listnode *node;
+  struct zserv *client;
+
+  /* MPLS: check is there are any XC waiting for this */
+  struct zmpls_xc *xc;
+  for (ALL_LIST_ELEMENTS_RO(&mpls_xc_list, node, xc))
+  {
+    struct zmpls_out_segment *out;
+    struct zmpls_in_segment tmp;
+
+    tmp.labelspace = xc->in_labelspace;
+    memcpy(&tmp.label, &xc->in_label, sizeof(struct zmpls_label));
+
+    if (xc->installed || !mpls_in_segment_match(in, &tmp))
+      continue;
+
+    out = mpls_out_segment_find (xc->out_index);
+
+    xc->installed = 1;
+    mpls_ctrl_xc_register (in, out);
+    redistribute_add_mpls_xc (xc);
+  }
+
+  for (ALL_LIST_ELEMENTS_RO(zebrad.client_list, node, client))
+     if (client->redist[in->owner])
+	zsend_mpls_in_segment_add (client, in);
+}
+
+void
+redistribute_delete_mpls_in_segment (struct zmpls_in_segment *in)
+{
+  struct listnode *node;
+  struct zserv *client;
+
+  for (ALL_LIST_ELEMENTS_RO(zebrad.client_list, node, client))
+     if (client->redist[in->owner])
+	zsend_mpls_in_segment_delete (client, in);
+
+  /* MPLS: check is there are any XC depending on this */
+  struct zmpls_xc *xc;
+  for (ALL_LIST_ELEMENTS_RO(&mpls_xc_list, node, xc))
+  {
+    struct zmpls_out_segment *out;
+    struct zmpls_in_segment tmp;
+
+    tmp.labelspace = xc->in_labelspace;
+    memcpy(&tmp.label, &xc->in_label, sizeof(struct zmpls_label));
+
+    if ((!xc->installed) || !mpls_in_segment_match(in, &tmp))
+      continue;
+
+    out = mpls_out_segment_find (xc->out_index);
+
+    xc->installed = 0;
+    mpls_ctrl_xc_unregister (in, out);
+    redistribute_delete_mpls_xc (xc);
+  }
+}
+
+void
+redistribute_add_mpls_out_segment (struct zmpls_out_segment *out)
+{
+  struct listnode *node;
+  struct zserv *client;
+
+  /* MPLS: check is there are any FTN waiting for this */
+  /* MPLS: check is there are any XC waiting for this */
+  struct zmpls_xc *xc;
+  for (ALL_LIST_ELEMENTS_RO(&mpls_xc_list, node, xc))
+  {
+    struct zmpls_in_segment tmp;
+    struct zmpls_in_segment *in;
+
+    if (xc->installed || xc->out_index != out->index)
+      continue;
+
+    tmp.labelspace = xc->in_labelspace;
+    memcpy(&tmp.label, &xc->in_label, sizeof(struct zmpls_label));
+    in = mpls_in_segment_find (&tmp);
+
+    xc->installed = 1;
+    redistribute_add_mpls_xc (xc);
+    mpls_ctrl_xc_register (in, out);
+  }
+
+  for (ALL_LIST_ELEMENTS_RO(zebrad.client_list, node, client))
+     if (client->redist[out->owner])
+	zsend_mpls_out_segment_add (client, out);
+}
+
+void
+redistribute_delete_mpls_out_segment (struct zmpls_out_segment *out)
+{
+  struct listnode *node;
+  struct zserv *client;
+
+  for (ALL_LIST_ELEMENTS_RO(zebrad.client_list, node, client))
+     if (client->redist[out->owner])
+	zsend_mpls_out_segment_delete (client, out);
+
+  /* MPLS: check is there are any FTN depending on this */
+  /* MPLS: check is there are any XC depending on this */
+  struct zmpls_xc *xc;
+  for (ALL_LIST_ELEMENTS_RO(&mpls_xc_list, node, xc))
+  {
+    struct zmpls_in_segment tmp;
+    struct zmpls_in_segment *in;
+
+    if ((!xc->installed) || xc->out_index != out->index)
+      continue;
+
+    tmp.labelspace = xc->in_labelspace;
+    memcpy(&tmp.label, &xc->in_label, sizeof(struct zmpls_label));
+    in = mpls_in_segment_find (&tmp);
+
+    xc->installed = 0;
+    mpls_ctrl_xc_unregister (in, out);
+    redistribute_delete_mpls_xc (xc);
+  }
+}
+
+void
+redistribute_add_mpls_labelspace (struct interface *ifp)
+{
+  struct listnode *node;
+  struct zserv *client;
+
+  for (ALL_LIST_ELEMENTS_RO(zebrad.client_list, node, client))
+     if (client->redist[ZEBRA_ROUTE_STATIC])
+	zsend_mpls_labelspace_add (client, ifp);
+}
+
+void
+redistribute_delete_mpls_labelspace (struct interface *ifp)
+{
+  struct listnode *node;
+  struct zserv *client;
+
+  for (ALL_LIST_ELEMENTS_RO(zebrad.client_list, node, client))
+     if (client->redist[ZEBRA_ROUTE_STATIC])
+	zsend_mpls_labelspace_delete (client, ifp);
+}
+
+void
+redistribute_add_mpls_ftn (struct zmpls_ftn *ftn)
+{
+  struct listnode *node;
+  struct zserv *client;
+
+  for (ALL_LIST_ELEMENTS_RO(zebrad.client_list, node, client))
+     if (client->redist[ftn->owner])
+	zsend_mpls_ftn_add (client, ftn);
+}
+
+void
+redistribute_delete_mpls_ftn (struct zmpls_ftn *ftn)
+{
+  struct listnode *node;
+  struct zserv *client;
+
+  for (ALL_LIST_ELEMENTS_RO(zebrad.client_list, node, client))
+     if (client->redist[ftn->owner])
+	zsend_mpls_ftn_delete (client, ftn);
+}
+#endif /* HAVE_MPLS */
diff --git a/zebra/redistribute.h b/zebra/redistribute.h
index 9ed99bc..35ae796 100644
--- a/zebra/redistribute.h
+++ b/zebra/redistribute.h
@@ -47,6 +47,17 @@ extern void zebra_interface_address_delete_update (struct interface *,
 						   struct connected *c);
 
 extern int zebra_check_addr (struct prefix *);
+#ifdef HAVE_MPLS
+void redistribute_add_mpls_xc (struct zmpls_xc *xc);
+void redistribute_delete_mpls_xc (struct zmpls_xc *xc);
+void redistribute_add_mpls_ftn (struct zmpls_ftn *ftn);
+void redistribute_delete_mpls_ftn (struct zmpls_ftn *ftn);
+void redistribute_add_mpls_in_segment (struct zmpls_in_segment *in);
+void redistribute_delete_mpls_in_segment (struct zmpls_in_segment *in);
+void redistribute_add_mpls_out_segment (struct zmpls_out_segment *out);
+void redistribute_delete_mpls_out_segment (struct zmpls_out_segment *out);
+void redistribute_add_mpls_labelspace (struct interface *ifp);
+void redistribute_delete_mpls_labelspace (struct interface *ifp);
+#endif
 
 #endif /* _ZEBRA_REDISTRIBUTE_H */
-
diff --git a/zebra/rib.h b/zebra/rib.h
index 887ed3c..6b2f707 100644
--- a/zebra/rib.h
+++ b/zebra/rib.h
@@ -24,9 +24,12 @@
 #define _ZEBRA_RIB_H
 
 #include "prefix.h"
+#include "zclient.h"
 
 #define DISTANCE_INFINITY  255
 
+#include "table.h"
+
 /* Routing information base. */
 
 union g_addr {
@@ -71,7 +74,7 @@ struct rib
    * This flag's definition is in lib/zebra.h ZEBRA_FLAG_* and is exposed
    * to clients via Zserv
    */
-  u_char flags;
+  u_short flags;
 
   /* RIB internal status */
   u_char status;
@@ -98,77 +101,15 @@ struct meta_queue
 };
 
 /* Static route information. */
-struct static_ipv4
+struct static_route
 {
   /* For linked list. */
-  struct static_ipv4 *prev;
-  struct static_ipv4 *next;
+  struct static_route *prev;
+  struct static_route *next;
 
   /* Administrative distance. */
   u_char distance;
-
-  /* Flag for this static route's type. */
-  u_char type;
-#define STATIC_IPV4_GATEWAY     1
-#define STATIC_IPV4_IFNAME      2
-#define STATIC_IPV4_BLACKHOLE   3
-
-  /* Nexthop value. */
-  union 
-  {
-    struct in_addr ipv4;
-    char *ifname;
-  } gate;
-
-  /* bit flags */
-  u_char flags;
-/*
- see ZEBRA_FLAG_REJECT
-     ZEBRA_FLAG_BLACKHOLE
- */
-};
-
-#ifdef HAVE_IPV6
-/* Static route information. */
-struct static_ipv6
-{
-  /* For linked list. */
-  struct static_ipv6 *prev;
-  struct static_ipv6 *next;
-
-  /* Administrative distance. */
-  u_char distance;
-
-  /* Flag for this static route's type. */
-  u_char type;
-#define STATIC_IPV6_GATEWAY          1
-#define STATIC_IPV6_GATEWAY_IFNAME   2
-#define STATIC_IPV6_IFNAME           3
-
-  /* Nexthop value. */
-  struct in6_addr ipv6;
-  char *ifname;
-
-  /* bit flags */
-  u_char flags;
-/*
- see ZEBRA_FLAG_REJECT
-     ZEBRA_FLAG_BLACKHOLE
- */
-};
-#endif /* HAVE_IPV6 */
-
-enum nexthop_types_t
-{
-  NEXTHOP_TYPE_IFINDEX = 1,      /* Directly connected.  */
-  NEXTHOP_TYPE_IFNAME,           /* Interface route.  */
-  NEXTHOP_TYPE_IPV4,             /* IPv4 nexthop.  */
-  NEXTHOP_TYPE_IPV4_IFINDEX,     /* IPv4 nexthop with ifindex.  */
-  NEXTHOP_TYPE_IPV4_IFNAME,      /* IPv4 nexthop with ifname.  */
-  NEXTHOP_TYPE_IPV6,             /* IPv6 nexthop.  */
-  NEXTHOP_TYPE_IPV6_IFINDEX,     /* IPv6 nexthop with ifindex.  */
-  NEXTHOP_TYPE_IPV6_IFNAME,      /* IPv6 nexthop with ifname.  */
-  NEXTHOP_TYPE_BLACKHOLE,        /* Null0 nexthop.  */
+  struct zapi_nexthop nh;
 };
 
 /* Nexthop structure. */
@@ -176,17 +117,24 @@ struct nexthop
 {
   struct nexthop *next;
   struct nexthop *prev;
+  struct nexthop *tied;
 
   /* Interface index. */
   char *ifname;
   unsigned int ifindex;
   
-  enum nexthop_types_t type;
+  unsigned int mpls;
+  unsigned int type;
+  unsigned int advmss;
 
   u_char flags;
 #define NEXTHOP_FLAG_ACTIVE     (1 << 0) /* This nexthop is alive. */
 #define NEXTHOP_FLAG_FIB        (1 << 1) /* FIB nexthop. */
 #define NEXTHOP_FLAG_RECURSIVE  (1 << 2) /* Recursive nexthop. */
+#define NEXTHOP_FLAG_IGNORE     (1 << 3) /* Ignore this nexthop */
+
+  /* the type of drop (REJECT, BLACKHOLE, NULL) */
+  u_char drop;
 
   /* Nexthop address or interface name. */
   union g_addr gate;
@@ -196,6 +144,7 @@ struct nexthop
   unsigned int rifindex;
   union g_addr rgate;
   union g_addr src;
+  unsigned int rmpls;
 };
 
 /* Routing table instance.  */
@@ -220,86 +169,72 @@ struct vrf
   struct route_table *stable[AFI_MAX][SAFI_MAX];
 };
 
-extern struct nexthop *nexthop_ifindex_add (struct rib *, unsigned int);
-extern struct nexthop *nexthop_ifname_add (struct rib *, char *);
-extern struct nexthop *nexthop_blackhole_add (struct rib *);
-extern struct nexthop *nexthop_ipv4_add (struct rib *, struct in_addr *,
-					 struct in_addr *);
+extern void
+nexthop_delete (struct rib *rib, struct nexthop *nexthop);
+
+extern void
+nexthop_free (struct nexthop *nexthop);
+
+extern struct nexthop *nexthop_zapi_nexthop_add(struct rib *rib,
+  struct zapi_nexthop* znh);
+extern void zapi_nexthop2nexthop(struct zapi_nexthop* znh, struct nexthop *nh);
+
 extern void rib_lookup_and_dump (struct prefix_ipv4 *);
 extern void rib_lookup_and_pushup (struct prefix_ipv4 *);
 extern void rib_dump (const char *, const struct prefix_ipv4 *, const struct rib *);
-extern int rib_lookup_ipv4_route (struct prefix_ipv4 *, union sockunion *);
+extern int rib_lookup_route_nexthop (struct prefix *, struct zapi_nexthop *);
 #define ZEBRA_RIB_LOOKUP_ERROR -1
 #define ZEBRA_RIB_FOUND_EXACT 0
 #define ZEBRA_RIB_FOUND_NOGATE 1
 #define ZEBRA_RIB_FOUND_CONNECTED 2
 #define ZEBRA_RIB_NOTFOUND 3
 
-#ifdef HAVE_IPV6
-extern struct nexthop *nexthop_ipv6_add (struct rib *, struct in6_addr *);
-#endif /* HAVE_IPV6 */
-
 extern struct vrf *vrf_lookup (u_int32_t);
 extern struct route_table *vrf_table (afi_t afi, safi_t safi, u_int32_t id);
 extern struct route_table *vrf_static_table (afi_t afi, safi_t safi, u_int32_t id);
 
 /* NOTE:
- * All rib_add_ipv[46]* functions will not just add prefix into RIB, but
+ * All rib_add_route function will not just add prefix into RIB, but
  * also implicitly withdraw equal prefix of same type. */
-extern int rib_add_ipv4 (int type, int flags, struct prefix_ipv4 *p, 
-			 struct in_addr *gate, struct in_addr *src,
-			 unsigned int ifindex, u_int32_t vrf_id,
-			 u_int32_t, u_char);
+extern int rib_add_route (int type, int flags, struct prefix *p, 
+			  struct zapi_nexthop *nh, u_int32_t vrf_id,
+			  u_int32_t, u_char);
 
-extern int rib_add_ipv4_multipath (struct prefix_ipv4 *, struct rib *);
+extern int rib_delete_route (int type, int flags, struct prefix *p,
+			     struct zapi_nexthop *nh, u_int32_t);
+extern int
+rib_find_nexthop2 (int owner, struct rib *rib_in, struct nexthop *nh_in,
+		   struct rib **rib_out, struct nexthop **nh_out);
 
-extern int rib_delete_ipv4 (int type, int flags, struct prefix_ipv4 *p,
-		            struct in_addr *gate, unsigned int ifindex, 
-		            u_int32_t);
+extern int
+rib_find_nexthop (int owner, struct prefix *p_in, struct nexthop *nh_in,
+		  struct route_node **rn_out, struct rib **rib_out,
+		  struct nexthop **nh_out);
 
-extern struct rib *rib_match_ipv4 (struct in_addr);
+extern int rib_add_multipath (struct prefix *, struct rib *);
 
-extern struct rib *rib_lookup_ipv4 (struct prefix_ipv4 *);
+extern struct rib *rib_match_route (struct prefix *p);
 
+extern struct rib *rib_lookup_route (struct prefix *);
+
+extern int rib_check_drop (struct rib *);
 extern void rib_update (void);
 extern void rib_weed_tables (void);
 extern void rib_sweep_route (void);
 extern void rib_close (void);
 extern void rib_init (void);
+extern int rib_uninstall_kernel (struct route_node *rn, struct rib *rib);
 
 extern int
-static_add_ipv4 (struct prefix *p, struct in_addr *gate, const char *ifname,
-       u_char flags, u_char distance, u_int32_t vrf_id);
+static_add_route (struct prefix *p, struct zapi_nexthop *nh,
+		  u_char distance, u_int32_t vrf_id);
 
 extern int
-static_delete_ipv4 (struct prefix *p, struct in_addr *gate, const char *ifname,
-		    u_char distance, u_int32_t vrf_id);
+static_delete_route (struct prefix *p, struct zapi_nexthop *nh,
+		     u_char distance, u_int32_t vrf_id);
 
 #ifdef HAVE_IPV6
-extern int
-rib_add_ipv6 (int type, int flags, struct prefix_ipv6 *p,
-	      struct in6_addr *gate, unsigned int ifindex, u_int32_t vrf_id,
-	      u_int32_t metric, u_char distance);
-
-extern int
-rib_delete_ipv6 (int type, int flags, struct prefix_ipv6 *p,
-		 struct in6_addr *gate, unsigned int ifindex, u_int32_t vrf_id);
-
-extern struct rib *rib_lookup_ipv6 (struct in6_addr *);
-
-extern struct rib *rib_match_ipv6 (struct in6_addr *);
-
 extern struct route_table *rib_table_ipv6;
-
-extern int
-static_add_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
-		 const char *ifname, u_char flags, u_char distance,
-		 u_int32_t vrf_id);
-
-extern int
-static_delete_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
-		    const char *ifname, u_char distance, u_int32_t vrf_id);
-
 #endif /* HAVE_IPV6 */
 
 #endif /*_ZEBRA_RIB_H */
diff --git a/zebra/rt_ioctl.c b/zebra/rt_ioctl.c
index a5d588c..5afd368 100644
--- a/zebra/rt_ioctl.c
+++ b/zebra/rt_ioctl.c
@@ -206,8 +206,7 @@ kernel_ioctl_ipv4 (u_long cmd, struct prefix *p, struct rib *rib, int family)
 	{
 	  if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_RECURSIVE))
 	    {
-	      if (nexthop->rtype == NEXTHOP_TYPE_IPV4 ||
-		  nexthop->rtype == NEXTHOP_TYPE_IPV4_IFINDEX)
+	      if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV4))
 		{
 		  sin_gate.sin_family = AF_INET;
 #ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
@@ -216,8 +215,16 @@ kernel_ioctl_ipv4 (u_long cmd, struct prefix *p, struct rib *rib, int family)
 		  sin_gate.sin_addr = nexthop->rgate.ipv4;
 		  rtentry.rt_flags |= RTF_GATEWAY;
 		}
-	      if (nexthop->rtype == NEXTHOP_TYPE_IFINDEX
-		  || nexthop->rtype == NEXTHOP_TYPE_IFNAME)
+	      else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV6))
+		{
+		  assert (0);
+		}
+	      else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_DROP))
+		{
+		  SET_FLAG (rtentry.rt_flags, RTF_REJECT);
+		}
+
+	      if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IFINDEX))
 		{
 		  ifp = if_lookup_by_index (nexthop->rifindex);
 		  if (ifp)
@@ -225,11 +232,14 @@ kernel_ioctl_ipv4 (u_long cmd, struct prefix *p, struct rib *rib, int family)
 		  else
 		    return -1;
 		}
+	      else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IFNAME))
+		{
+		  assert (0);
+		}
 	    }
 	  else
 	    {
-	      if (nexthop->type == NEXTHOP_TYPE_IPV4 ||
-		  nexthop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
+	      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
 		{
 		  sin_gate.sin_family = AF_INET;
 #ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
@@ -238,8 +248,16 @@ kernel_ioctl_ipv4 (u_long cmd, struct prefix *p, struct rib *rib, int family)
 		  sin_gate.sin_addr = nexthop->gate.ipv4;
 		  rtentry.rt_flags |= RTF_GATEWAY;
 		}
-	      if (nexthop->type == NEXTHOP_TYPE_IFINDEX
-		  || nexthop->type == NEXTHOP_TYPE_IFNAME)
+	      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
+		{
+		  assert (0);
+		}
+	      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_DROP))
+		{
+		  SET_FLAG (rtentry.rt_flags, RTF_REJECT);
+		}
+
+	      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
 		{
 		  ifp = if_lookup_by_index (nexthop->ifindex);
 		  if (ifp)
@@ -247,6 +265,10 @@ kernel_ioctl_ipv4 (u_long cmd, struct prefix *p, struct rib *rib, int family)
 		  else
 		    return -1;
 		}
+	      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
+		{
+		  assert (0);
+		}
 	    }
 
 	  if (cmd == SIOCADDRT)
@@ -465,17 +487,21 @@ kernel_ioctl_ipv6_multipath (u_long cmd, struct prefix *p, struct rib *rib,
 	{
 	  if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_RECURSIVE))
 	    {
-	      if (nexthop->rtype == NEXTHOP_TYPE_IPV6
-		  || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFNAME
-		  || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFINDEX)
+	      if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV6))
 		{
 		  memcpy (&rtm.rtmsg_gateway, &nexthop->rgate.ipv6,
 			  sizeof (struct in6_addr));
 		}
-	      if (nexthop->rtype == NEXTHOP_TYPE_IFINDEX
-		  || nexthop->rtype == NEXTHOP_TYPE_IFNAME
-		  || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFNAME
-		  || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFINDEX)
+	      else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV4))
+		{
+		  assert (0);
+		}
+	      else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_DROP))
+		{
+		  SET_FLAG (rtentry.rt_flags, RTF_REJECT);
+		}
+
+	      if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IFINDEX))
 		rtm.rtmsg_ifindex = nexthop->rifindex;
 	      else
 		rtm.rtmsg_ifindex = 0;
@@ -483,17 +509,21 @@ kernel_ioctl_ipv6_multipath (u_long cmd, struct prefix *p, struct rib *rib,
 	    }
 	  else
 	    {
-	      if (nexthop->type == NEXTHOP_TYPE_IPV6
-		  || nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME
-		  || nexthop->type == NEXTHOP_TYPE_IPV6_IFINDEX)
+	      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
 		{
 		  memcpy (&rtm.rtmsg_gateway, &nexthop->gate.ipv6,
 			  sizeof (struct in6_addr));
 		}
-	      if (nexthop->type == NEXTHOP_TYPE_IFINDEX
-		  || nexthop->type == NEXTHOP_TYPE_IFNAME
-		  || nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME
-		  || nexthop->type == NEXTHOP_TYPE_IPV6_IFINDEX)
+	      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
+		{
+		  assert (0);
+		}
+	      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_DROP))
+		{
+		  SET_FLAG (rtentry.rt_flags, RTF_REJECT);
+		}
+
+	      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
 		rtm.rtmsg_ifindex = nexthop->ifindex;
 	      else
 		rtm.rtmsg_ifindex = 0;
diff --git a/zebra/rt_netlink.c b/zebra/rt_netlink.c
index 0bf2d9e..7a11c42 100644
--- a/zebra/rt_netlink.c
+++ b/zebra/rt_netlink.c
@@ -35,56 +35,26 @@
 #include "rib.h"
 #include "thread.h"
 #include "privs.h"
+#ifdef HAVE_MPLS
+#include "mpls_lib.h"
+#ifdef LINUX_MPLS
+#include <linux/shim.h>
+#endif
+#endif /* HAVE_MPLS */
 
+#include "zebra/rt.h"
 #include "zebra/zserv.h"
 #include "zebra/rt.h"
 #include "zebra/redistribute.h"
 #include "zebra/interface.h"
 #include "zebra/debug.h"
+#include "zebra/netlink.h"
+#include "zebra/rt_netlink.h"
 
 /* Socket interface to kernel */
-struct nlsock
-{
-  int sock;
-  int seq;
-  struct sockaddr_nl snl;
-  const char *name;
-} netlink      = { -1, 0, {0}, "netlink-listen"},     /* kernel messages */
-  netlink_cmd  = { -1, 0, {0}, "netlink-cmd"};        /* command channel */
-
-struct message nlmsg_str[] = {
-  {RTM_NEWROUTE, "RTM_NEWROUTE"},
-  {RTM_DELROUTE, "RTM_DELROUTE"},
-  {RTM_GETROUTE, "RTM_GETROUTE"},
-  {RTM_NEWLINK,  "RTM_NEWLINK"},
-  {RTM_DELLINK,  "RTM_DELLINK"},
-  {RTM_GETLINK,  "RTM_GETLINK"},
-  {RTM_NEWADDR,  "RTM_NEWADDR"},
-  {RTM_DELADDR,  "RTM_DELADDR"},
-  {RTM_GETADDR,  "RTM_GETADDR"},
-  {0, NULL}
-};
-
-const char *nexthop_types_desc[] =  
-{
-  "none",
-  "Directly connected",
-  "Interface route",
-  "IPv4 nexthop",
-  "IPv4 nexthop with ifindex",
-  "IPv4 nexthop with ifname",
-  "IPv6 nexthop",
-  "IPv6 nexthop with ifindex",
-  "IPv6 nexthop with ifname",
-  "Null0 nexthop",
-};
-
-
-extern struct zebra_t zebrad;
-
-extern struct zebra_privs_t zserv_privs;
-
-extern u_int32_t nl_rcvbufsize;
+static struct nlsock
+  netlink      = { -1, 0, {0}, "netlink-listen", 0},	/* kernel messages */
+  netlink_cmd  = { -1, 0, {0}, "netlink-cmd", 1};	/* command channel */
 
 /* Note: on netlink systems, there should be a 1-to-1 mapping between interface
    names and ifindex values. */
@@ -113,388 +83,10 @@ set_ifindex(struct interface *ifp, unsigned int ifi_index)
   ifp->ifindex = ifi_index;
 }
 
-/* Make socket for Linux netlink interface. */
-static int
-netlink_socket (struct nlsock *nl, unsigned long groups)
-{
-  int ret;
-  struct sockaddr_nl snl;
-  int sock;
-  int namelen;
-  int save_errno;
-
-  sock = socket (AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
-  if (sock < 0)
-    {
-      zlog (NULL, LOG_ERR, "Can't open %s socket: %s", nl->name,
-            safe_strerror (errno));
-      return -1;
-    }
-
-  ret = fcntl (sock, F_SETFL, O_NONBLOCK);
-  if (ret < 0)
-    {
-      zlog (NULL, LOG_ERR, "Can't set %s socket flags: %s", nl->name,
-            safe_strerror (errno));
-      close (sock);
-      return -1;
-    }
-
-  /* Set receive buffer size if it's set from command line */
-  if (nl_rcvbufsize)
-    {
-      u_int32_t oldsize, oldlen;
-      u_int32_t newsize, newlen;
-
-      oldlen = sizeof(oldsize);
-      newlen = sizeof(newsize);
-
-      ret = getsockopt(sock, SOL_SOCKET, SO_RCVBUF, &oldsize, &oldlen);
-      if (ret < 0)
-	{
-	  zlog (NULL, LOG_ERR, "Can't get %s receive buffer size: %s", nl->name,
-		safe_strerror (errno));
-	  close (sock);
-	  return -1;
-	}
-
-      ret = setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &nl_rcvbufsize,
-		       sizeof(nl_rcvbufsize));
-      if (ret < 0)
-	{
-	  zlog (NULL, LOG_ERR, "Can't set %s receive buffer size: %s", nl->name,
-		safe_strerror (errno));
-	  close (sock);
-	  return -1;
-	}
-
-      ret = getsockopt(sock, SOL_SOCKET, SO_RCVBUF, &newsize, &newlen);
-      if (ret < 0)
-	{
-	  zlog (NULL, LOG_ERR, "Can't get %s receive buffer size: %s", nl->name,
-		safe_strerror (errno));
-	  close (sock);
-	  return -1;
-	}
-
-      zlog (NULL, LOG_INFO,
-	    "Setting netlink socket receive buffer size: %u -> %u",
-	    oldsize, newsize);
-    }
-
-  memset (&snl, 0, sizeof snl);
-  snl.nl_family = AF_NETLINK;
-  snl.nl_groups = groups;
-
-  /* Bind the socket to the netlink structure for anything. */
-  if (zserv_privs.change (ZPRIVS_RAISE))
-    {
-      zlog (NULL, LOG_ERR, "Can't raise privileges");
-      return -1;
-    }
-
-  ret = bind (sock, (struct sockaddr *) &snl, sizeof snl);
-  save_errno = errno;
-  if (zserv_privs.change (ZPRIVS_LOWER))
-    zlog (NULL, LOG_ERR, "Can't lower privileges");
-
-  if (ret < 0)
-    {
-      zlog (NULL, LOG_ERR, "Can't bind %s socket to group 0x%x: %s",
-            nl->name, snl.nl_groups, safe_strerror (save_errno));
-      close (sock);
-      return -1;
-    }
-
-  /* multiple netlink sockets will have different nl_pid */
-  namelen = sizeof snl;
-  ret = getsockname (sock, (struct sockaddr *) &snl, (socklen_t *) &namelen);
-  if (ret < 0 || namelen != sizeof snl)
-    {
-      zlog (NULL, LOG_ERR, "Can't get %s socket name: %s", nl->name,
-            safe_strerror (errno));
-      close (sock);
-      return -1;
-    }
-
-  nl->snl = snl;
-  nl->sock = sock;
-  return ret;
-}
-
-int
-set_netlink_blocking (struct nlsock *nl, int *flags)
-{
-
-  /* Change socket flags for blocking I/O.  */
-  if ((*flags = fcntl (nl->sock, F_GETFL, 0)) < 0)
-    {
-      zlog (NULL, LOG_ERR, "%s:%i F_GETFL error: %s",
-            __FUNCTION__, __LINE__, safe_strerror (errno));
-      return -1;
-    }
-  *flags &= ~O_NONBLOCK;
-  if (fcntl (nl->sock, F_SETFL, *flags) < 0)
-    {
-      zlog (NULL, LOG_ERR, "%s:%i F_SETFL error: %s",
-            __FUNCTION__, __LINE__, safe_strerror (errno));
-      return -1;
-    }
-  return 0;
-}
-
-int
-set_netlink_nonblocking (struct nlsock *nl, int *flags)
-{
-  /* Restore socket flags for nonblocking I/O */
-  *flags |= O_NONBLOCK;
-  if (fcntl (nl->sock, F_SETFL, *flags) < 0)
-    {
-      zlog (NULL, LOG_ERR, "%s:%i F_SETFL error: %s",
-            __FUNCTION__, __LINE__, safe_strerror (errno));
-      return -1;
-    }
-  return 0;
-}
-
-/* Get type specified information from netlink. */
-static int
-netlink_request (int family, int type, struct nlsock *nl)
-{
-  int ret;
-  struct sockaddr_nl snl;
-  int save_errno;
-
-  struct
-  {
-    struct nlmsghdr nlh;
-    struct rtgenmsg g;
-  } req;
-
-
-  /* Check netlink socket. */
-  if (nl->sock < 0)
-    {
-      zlog (NULL, LOG_ERR, "%s socket isn't active.", nl->name);
-      return -1;
-    }
-
-  memset (&snl, 0, sizeof snl);
-  snl.nl_family = AF_NETLINK;
-
-  memset (&req, 0, sizeof req);
-  req.nlh.nlmsg_len = sizeof req;
-  req.nlh.nlmsg_type = type;
-  req.nlh.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;
-  req.nlh.nlmsg_pid = 0;
-  req.nlh.nlmsg_seq = ++nl->seq;
-  req.g.rtgen_family = family;
-
-  /* linux appears to check capabilities on every message 
-   * have to raise caps for every message sent
-   */
-  if (zserv_privs.change (ZPRIVS_RAISE))
-    {
-      zlog (NULL, LOG_ERR, "Can't raise privileges");
-      return -1;
-    }
-
-  ret = sendto (nl->sock, (void *) &req, sizeof req, 0,
-                (struct sockaddr *) &snl, sizeof snl);
-  save_errno = errno;
-
-  if (zserv_privs.change (ZPRIVS_LOWER))
-    zlog (NULL, LOG_ERR, "Can't lower privileges");
-
-  if (ret < 0)
-    {
-      zlog (NULL, LOG_ERR, "%s sendto failed: %s", nl->name,
-            safe_strerror (save_errno));
-      return -1;
-    }
-
-  return 0;
-}
-
-/* Receive message from netlink interface and pass those information
-   to the given function. */
-static int
-netlink_parse_info (int (*filter) (struct sockaddr_nl *, struct nlmsghdr *),
-                    struct nlsock *nl)
-{
-  int status;
-  int ret = 0;
-  int error;
-
-  while (1)
-    {
-      char buf[4096];
-      struct iovec iov = { buf, sizeof buf };
-      struct sockaddr_nl snl;
-      struct msghdr msg = { (void *) &snl, sizeof snl, &iov, 1, NULL, 0, 0 };
-      struct nlmsghdr *h;
-      int save_errno;
-
-      if (zserv_privs.change (ZPRIVS_RAISE))
-        zlog (NULL, LOG_ERR, "Can't raise privileges");
-
-      status = recvmsg (nl->sock, &msg, 0);
-      save_errno = errno;
-
-      if (zserv_privs.change (ZPRIVS_LOWER))
-        zlog (NULL, LOG_ERR, "Can't lower privileges");
-
-      if (status < 0)
-        {
-          if (save_errno == EINTR)
-            continue;
-          if (save_errno == EWOULDBLOCK || save_errno == EAGAIN)
-            break;
-          zlog (NULL, LOG_ERR, "%s recvmsg overrun: %s",
-	  	nl->name, safe_strerror(save_errno));
-          continue;
-        }
-
-      if (status == 0)
-        {
-          zlog (NULL, LOG_ERR, "%s EOF", nl->name);
-          return -1;
-        }
-
-      if (msg.msg_namelen != sizeof snl)
-        {
-          zlog (NULL, LOG_ERR, "%s sender address length error: length %d",
-                nl->name, msg.msg_namelen);
-          return -1;
-        }
-      
-      /* JF: Ignore messages that aren't from the kernel */
-      if ( snl.nl_pid != 0 )
-        {
-          zlog ( NULL, LOG_ERR, "Ignoring message from pid %u", snl.nl_pid );
-          continue;
-        }
-
-      for (h = (struct nlmsghdr *) buf; NLMSG_OK (h, (unsigned int) status);
-           h = NLMSG_NEXT (h, status))
-        {
-          /* Finish of reading. */
-          if (h->nlmsg_type == NLMSG_DONE)
-            return ret;
-
-          /* Error handling. */
-          if (h->nlmsg_type == NLMSG_ERROR)
-            {
-              struct nlmsgerr *err = (struct nlmsgerr *) NLMSG_DATA (h);
-
-              /* If the error field is zero, then this is an ACK */
-              if (err->error == 0)
-                {
-                  if (IS_ZEBRA_DEBUG_KERNEL)
-                    {
-                      zlog_debug ("%s: %s ACK: type=%s(%u), seq=%u, pid=%u",
-                                 __FUNCTION__, nl->name,
-                                 lookup (nlmsg_str, err->msg.nlmsg_type),
-                                 err->msg.nlmsg_type, err->msg.nlmsg_seq,
-                                 err->msg.nlmsg_pid);
-                    }
-
-                  /* return if not a multipart message, otherwise continue */
-                  if (!(h->nlmsg_flags & NLM_F_MULTI))
-                    {
-                      return 0;
-                    }
-                  continue;
-                }
-
-              if (h->nlmsg_len < NLMSG_LENGTH (sizeof (struct nlmsgerr)))
-                {
-                  zlog (NULL, LOG_ERR, "%s error: message truncated",
-                        nl->name);
-                  return -1;
-                }
-
-              /* Deal with Error Noise  - MAG */
-              {
-                int loglvl = LOG_ERR;
-                int errnum = err->error;
-                int msg_type = err->msg.nlmsg_type;
-
-                if (nl == &netlink_cmd
-                    && (-errnum == ENODEV || -errnum == ESRCH)
-                    && (msg_type == RTM_NEWROUTE || msg_type == RTM_DELROUTE))
-                  loglvl = LOG_DEBUG;
-
-                zlog (NULL, loglvl, "%s error: %s, type=%s(%u), "
-                      "seq=%u, pid=%u",
-                      nl->name, safe_strerror (-errnum),
-                      lookup (nlmsg_str, msg_type),
-                      msg_type, err->msg.nlmsg_seq, err->msg.nlmsg_pid);
-              }
-              /*
-                 ret = -1;
-                 continue;
-               */
-              return -1;
-            }
-
-          /* OK we got netlink message. */
-          if (IS_ZEBRA_DEBUG_KERNEL)
-            zlog_debug ("netlink_parse_info: %s type %s(%u), seq=%u, pid=%u",
-                       nl->name,
-                       lookup (nlmsg_str, h->nlmsg_type), h->nlmsg_type,
-                       h->nlmsg_seq, h->nlmsg_pid);
-
-          /* skip unsolicited messages originating from command socket */
-          if (nl != &netlink_cmd && h->nlmsg_pid == netlink_cmd.snl.nl_pid)
-            {
-              if (IS_ZEBRA_DEBUG_KERNEL)
-                zlog_debug ("netlink_parse_info: %s packet comes from %s",
-                            netlink_cmd.name, nl->name);
-              continue;
-            }
-
-          error = (*filter) (&snl, h);
-          if (error < 0)
-            {
-              zlog (NULL, LOG_ERR, "%s filter function error", nl->name);
-              ret = error;
-            }
-        }
-
-      /* After error care. */
-      if (msg.msg_flags & MSG_TRUNC)
-        {
-          zlog (NULL, LOG_ERR, "%s error: message truncated", nl->name);
-          continue;
-        }
-      if (status)
-        {
-          zlog (NULL, LOG_ERR, "%s error: data remnant size %d", nl->name,
-                status);
-          return -1;
-        }
-    }
-  return ret;
-}
-
-/* Utility function for parse rtattr. */
-static void
-netlink_parse_rtattr (struct rtattr **tb, int max, struct rtattr *rta,
-                      int len)
-{
-  while (RTA_OK (rta, len))
-    {
-      if (rta->rta_type <= max)
-        tb[rta->rta_type] = rta;
-      rta = RTA_NEXT (rta, len);
-    }
-}
-
 /* Called from interface_lookup_netlink().  This function is only used
    during bootstrap. */
-int
-netlink_interface (struct sockaddr_nl *snl, struct nlmsghdr *h)
+static int
+netlink_interface (struct nlsock *nl, struct sockaddr_nl *snl, struct nlmsghdr *h)
 {
   int len;
   struct ifinfomsg *ifi;
@@ -503,6 +95,15 @@ netlink_interface (struct sockaddr_nl *snl, struct nlmsghdr *h)
   char *name;
   int i;
 
+  /* skip unsolicited messages originating from command socket */
+  if ((!nl->cmd) && h->nlmsg_pid == netlink_cmd.snl.nl_pid)
+    {
+      if (IS_ZEBRA_DEBUG_KERNEL)
+        zlog_debug ("netlink_parse_info: %s packet comes from %s",
+                    netlink_cmd.name, nl->name);
+      return 0;
+    }
+
   ifi = NLMSG_DATA (h);
 
   if (h->nlmsg_type != RTM_NEWLINK)
@@ -570,8 +171,8 @@ netlink_interface (struct sockaddr_nl *snl, struct nlmsghdr *h)
 }
 
 /* Lookup interface IPv4/IPv6 address. */
-int
-netlink_interface_addr (struct sockaddr_nl *snl, struct nlmsghdr *h)
+static int
+netlink_interface_addr (struct nlsock *nl, struct sockaddr_nl *snl, struct nlmsghdr *h)
 {
   int len;
   struct ifaddrmsg *ifa;
@@ -582,6 +183,15 @@ netlink_interface_addr (struct sockaddr_nl *snl, struct nlmsghdr *h)
   u_char flags = 0;
   char *label = NULL;
 
+  /* skip unsolicited messages originating from command socket */
+  if ((!nl->cmd) && h->nlmsg_pid == netlink_cmd.snl.nl_pid)
+    {
+      if (IS_ZEBRA_DEBUG_KERNEL)
+        zlog_debug ("netlink_parse_info: %s packet comes from %s",
+                    netlink_cmd.name, nl->name);
+      return 0;
+    }
+
   ifa = NLMSG_DATA (h);
 
   if (ifa->ifa_family != AF_INET
@@ -705,13 +315,14 @@ netlink_interface_addr (struct sockaddr_nl *snl, struct nlmsghdr *h)
 }
 
 /* Looking up routing table by netlink interface. */
-int
-netlink_routing_table (struct sockaddr_nl *snl, struct nlmsghdr *h)
+static int
+netlink_routing_table (struct nlsock *nl, struct sockaddr_nl *snl, struct nlmsghdr *h)
 {
   int len;
   struct rtmsg *rtm;
   struct rtattr *tb[RTA_MAX + 1];
-  u_char flags = 0;
+  u_short zebra_flags = 0;
+  struct zapi_nexthop nh;
 
   char anyaddr[16] = { 0 };
 
@@ -723,6 +334,17 @@ netlink_routing_table (struct sockaddr_nl *snl, struct nlmsghdr *h)
   void *gate;
   void *src;
 
+  memset(&nh, 0, sizeof(struct zapi_nexthop));
+
+  /* skip unsolicited messages originating from command socket */
+  if ((!nl->cmd) && h->nlmsg_pid == netlink_cmd.snl.nl_pid)
+    {
+      if (IS_ZEBRA_DEBUG_KERNEL)
+        zlog_debug ("netlink_parse_info: %s packet comes from %s",
+                    netlink_cmd.name, nl->name);
+      return 0;
+    }
+
   rtm = NLMSG_DATA (h);
 
   if (h->nlmsg_type != RTM_NEWROUTE)
@@ -755,7 +377,7 @@ netlink_routing_table (struct sockaddr_nl *snl, struct nlmsghdr *h)
 
   /* Route which inserted by Zebra. */
   if (rtm->rtm_protocol == RTPROT_ZEBRA)
-    flags |= ZEBRA_FLAG_SELFROUTE;
+    zebra_flags |= ZEBRA_FLAG_SELFROUTE;
 
   index = 0;
   metric = 0;
@@ -764,7 +386,11 @@ netlink_routing_table (struct sockaddr_nl *snl, struct nlmsghdr *h)
   src = NULL;
 
   if (tb[RTA_OIF])
-    index = *(int *) RTA_DATA (tb[RTA_OIF]);
+    {
+      index = *(int *) RTA_DATA (tb[RTA_OIF]);
+      nh.intf.index = index;
+      SET_FLAG(nh.type, ZEBRA_NEXTHOP_IFINDEX);
+    }
 
   if (tb[RTA_DST])
     dest = RTA_DATA (tb[RTA_DST]);
@@ -776,7 +402,9 @@ netlink_routing_table (struct sockaddr_nl *snl, struct nlmsghdr *h)
 
   /* Multipath treatment is needed. */
   if (tb[RTA_GATEWAY])
-    gate = RTA_DATA (tb[RTA_GATEWAY]);
+    {
+      gate = RTA_DATA (tb[RTA_GATEWAY]);
+    }
 
   if (tb[RTA_PRIORITY])
     metric = *(int *) RTA_DATA(tb[RTA_PRIORITY]);
@@ -788,7 +416,20 @@ netlink_routing_table (struct sockaddr_nl *snl, struct nlmsghdr *h)
       memcpy (&p.prefix, dest, 4);
       p.prefixlen = rtm->rtm_dst_len;
 
-      rib_add_ipv4 (ZEBRA_ROUTE_KERNEL, flags, &p, gate, src, index, table, metric, 0);
+      if (gate)
+        {
+          memcpy(&nh.gw.ipv4, gate, sizeof(struct in_addr));
+          SET_FLAG(nh.type, ZEBRA_NEXTHOP_IPV4);
+        }
+
+      if (src)
+        {
+          memcpy(&nh.src.ipv4, src, sizeof(struct in_addr));
+          SET_FLAG(nh.type, ZEBRA_NEXTHOP_SRC_IPV4);
+        }
+
+      rib_add_route (ZEBRA_ROUTE_KERNEL, zebra_flags, (struct prefix*)&p,
+                     &nh, table, metric, 0);
     }
 #ifdef HAVE_IPV6
   if (rtm->rtm_family == AF_INET6)
@@ -798,8 +439,14 @@ netlink_routing_table (struct sockaddr_nl *snl, struct nlmsghdr *h)
       memcpy (&p.prefix, dest, 16);
       p.prefixlen = rtm->rtm_dst_len;
 
-      rib_add_ipv6 (ZEBRA_ROUTE_KERNEL, flags, &p, gate, index, table,
-		    metric, 0);
+      if (gate)
+        {
+          memcpy(&nh.gw.ipv6, gate, sizeof(struct in6_addr));
+          SET_FLAG(nh.type, ZEBRA_NEXTHOP_IPV6);
+        }
+
+      rib_add_route (ZEBRA_ROUTE_KERNEL, zebra_flags, (struct prefix*)&p,
+                     &nh, table, metric, 0);
     }
 #endif /* HAVE_IPV6 */
 
@@ -822,12 +469,13 @@ struct message rtproto_str[] = {
 };
 
 /* Routing information change from the kernel. */
-int
-netlink_route_change (struct sockaddr_nl *snl, struct nlmsghdr *h)
+static int
+netlink_route_change (struct nlsock *nl, struct sockaddr_nl *snl, struct nlmsghdr *h)
 {
   int len;
   struct rtmsg *rtm;
   struct rtattr *tb[RTA_MAX + 1];
+  struct zapi_nexthop nh;
 
   char anyaddr[16] = { 0 };
 
@@ -837,6 +485,17 @@ netlink_route_change (struct sockaddr_nl *snl, struct nlmsghdr *h)
   void *gate;
   void *src;
 
+  memset(&nh, 0, sizeof(struct zapi_nexthop));
+
+  /* skip unsolicited messages originating from command socket */
+  if ((!nl->cmd) && h->nlmsg_pid == netlink_cmd.snl.nl_pid)
+    {
+      if (IS_ZEBRA_DEBUG_KERNEL)
+        zlog_debug ("netlink_parse_info: %s packet comes from %s",
+                    netlink_cmd.name, nl->name);
+      return 0;
+    }
+
   rtm = NLMSG_DATA (h);
 
   if (!(h->nlmsg_type == RTM_NEWROUTE || h->nlmsg_type == RTM_DELROUTE))
@@ -895,7 +554,11 @@ netlink_route_change (struct sockaddr_nl *snl, struct nlmsghdr *h)
   src = NULL;
 
   if (tb[RTA_OIF])
-    index = *(int *) RTA_DATA (tb[RTA_OIF]);
+    {
+      index = *(int *) RTA_DATA (tb[RTA_OIF]);
+      nh.intf.index = index;
+      SET_FLAG(nh.type, ZEBRA_NEXTHOP_IFINDEX);
+    }
 
   if (tb[RTA_DST])
     dest = RTA_DATA (tb[RTA_DST]);
@@ -925,10 +588,24 @@ netlink_route_change (struct sockaddr_nl *snl, struct nlmsghdr *h)
                        inet_ntoa (p.prefix), p.prefixlen);
         }
 
+      if (gate)
+        {
+          memcpy(&nh.gw.ipv4, gate, sizeof(struct in_addr));
+          SET_FLAG(nh.type, ZEBRA_NEXTHOP_IPV4);
+        }
+
+      if (src)
+        {
+          memcpy(&nh.src.ipv4, src, sizeof(struct in_addr));
+          SET_FLAG(nh.type, ZEBRA_NEXTHOP_SRC_IPV4);
+        }
+
       if (h->nlmsg_type == RTM_NEWROUTE)
-        rib_add_ipv4 (ZEBRA_ROUTE_KERNEL, 0, &p, gate, src, index, table, 0, 0);
+        rib_add_route (ZEBRA_ROUTE_KERNEL, 0, (struct prefix*)&p,
+                       &nh, table, 0, 0);
       else
-        rib_delete_ipv4 (ZEBRA_ROUTE_KERNEL, 0, &p, gate, index, table);
+        rib_delete_route (ZEBRA_ROUTE_KERNEL, 0, (struct prefix*)&p,
+                          &nh, table);
     }
 
 #ifdef HAVE_IPV6
@@ -953,18 +630,24 @@ netlink_route_change (struct sockaddr_nl *snl, struct nlmsghdr *h)
                        p.prefixlen);
         }
 
+      if (gate)
+        {
+          memcpy(&nh.gw.ipv6, gate, sizeof(struct in6_addr));
+          SET_FLAG(nh.type, ZEBRA_NEXTHOP_IPV6);
+        }
+
       if (h->nlmsg_type == RTM_NEWROUTE)
-        rib_add_ipv6 (ZEBRA_ROUTE_KERNEL, 0, &p, gate, index, 0, 0, 0);
+        rib_add_route (ZEBRA_ROUTE_KERNEL, 0, (struct prefix*)&p, &nh, 0, 0, 0);
       else
-        rib_delete_ipv6 (ZEBRA_ROUTE_KERNEL, 0, &p, gate, index, 0);
+        rib_delete_route (ZEBRA_ROUTE_KERNEL, 0, (struct prefix*)&p, &nh, 0);
     }
 #endif /* HAVE_IPV6 */
 
   return 0;
 }
 
-int
-netlink_link_change (struct sockaddr_nl *snl, struct nlmsghdr *h)
+static int
+netlink_link_change (struct nlsock *nl, struct sockaddr_nl *snl, struct nlmsghdr *h)
 {
   int len;
   struct ifinfomsg *ifi;
@@ -974,6 +657,15 @@ netlink_link_change (struct sockaddr_nl *snl, struct nlmsghdr *h)
 
   ifi = NLMSG_DATA (h);
 
+  /* skip unsolicited messages originating from command socket */
+  if ((!nl->cmd) && h->nlmsg_pid == netlink_cmd.snl.nl_pid)
+    {
+      if (IS_ZEBRA_DEBUG_KERNEL)
+        zlog_debug ("netlink_parse_info: %s packet comes from %s",
+                    netlink_cmd.name, nl->name);
+      return 0;
+    }
+
   if (!(h->nlmsg_type == RTM_NEWLINK || h->nlmsg_type == RTM_DELLINK))
     {
       /* If this is not link add/delete message so print warning. */
@@ -1064,28 +756,37 @@ netlink_link_change (struct sockaddr_nl *snl, struct nlmsghdr *h)
   return 0;
 }
 
-int
-netlink_information_fetch (struct sockaddr_nl *snl, struct nlmsghdr *h)
+static int
+netlink_information_fetch (struct nlsock *nl, struct sockaddr_nl *snl, struct nlmsghdr *h)
 {
+  /* skip unsolicited messages originating from command socket */
+  if ((!nl->cmd) && h->nlmsg_pid == netlink_cmd.snl.nl_pid)
+    {
+      if (IS_ZEBRA_DEBUG_KERNEL)
+        zlog_debug ("netlink_parse_info: %s packet comes from %s",
+                    netlink_cmd.name, nl->name);
+      return 0;
+    }
+
   switch (h->nlmsg_type)
     {
     case RTM_NEWROUTE:
-      return netlink_route_change (snl, h);
+      return netlink_route_change (nl, snl, h);
       break;
     case RTM_DELROUTE:
-      return netlink_route_change (snl, h);
+      return netlink_route_change (nl, snl, h);
       break;
     case RTM_NEWLINK:
-      return netlink_link_change (snl, h);
+      return netlink_link_change (nl, snl, h);
       break;
     case RTM_DELLINK:
-      return netlink_link_change (snl, h);
+      return netlink_link_change (nl, snl, h);
       break;
     case RTM_NEWADDR:
-      return netlink_interface_addr (snl, h);
+      return netlink_interface_addr (nl, snl, h);
       break;
     case RTM_DELADDR:
-      return netlink_interface_addr (snl, h);
+      return netlink_interface_addr (nl, snl, h);
       break;
     default:
       zlog_warn ("Unknown netlink nlmsg_type %d\n", h->nlmsg_type);
@@ -1116,7 +817,7 @@ interface_lookup_netlink (void)
   ret = netlink_request (AF_PACKET, RTM_GETLINK, &netlink_cmd);
   if (ret < 0)
     return ret;
-  ret = netlink_parse_info (netlink_interface, &netlink_cmd);
+  ret = netlink_parse_info (netlink_interface, &netlink_cmd, NULL, 0);
   if (ret < 0)
     return ret;
 
@@ -1124,7 +825,7 @@ interface_lookup_netlink (void)
   ret = netlink_request (AF_INET, RTM_GETADDR, &netlink_cmd);
   if (ret < 0)
     return ret;
-  ret = netlink_parse_info (netlink_interface_addr, &netlink_cmd);
+  ret = netlink_parse_info (netlink_interface_addr, &netlink_cmd, NULL, 0);
   if (ret < 0)
     return ret;
 
@@ -1133,7 +834,7 @@ interface_lookup_netlink (void)
   ret = netlink_request (AF_INET6, RTM_GETADDR, &netlink_cmd);
   if (ret < 0)
     return ret;
-  ret = netlink_parse_info (netlink_interface_addr, &netlink_cmd);
+  ret = netlink_parse_info (netlink_interface_addr, &netlink_cmd, NULL, 0);
   if (ret < 0)
     return ret;
 #endif /* HAVE_IPV6 */
@@ -1167,7 +868,7 @@ netlink_route_read (void)
   ret = netlink_request (AF_INET, RTM_GETROUTE, &netlink_cmd);
   if (ret < 0)
     return ret;
-  ret = netlink_parse_info (netlink_routing_table, &netlink_cmd);
+  ret = netlink_parse_info (netlink_routing_table, &netlink_cmd, NULL, 0);
   if (ret < 0)
     return ret;
 
@@ -1176,7 +877,7 @@ netlink_route_read (void)
   ret = netlink_request (AF_INET6, RTM_GETROUTE, &netlink_cmd);
   if (ret < 0)
     return ret;
-  ret = netlink_parse_info (netlink_routing_table, &netlink_cmd);
+  ret = netlink_parse_info (netlink_routing_table, &netlink_cmd, NULL, 0);
   if (ret < 0)
     return ret;
 #endif /* HAVE_IPV6 */
@@ -1187,142 +888,8 @@ netlink_route_read (void)
   return 0;
 }
 
-/* Utility function  comes from iproute2. 
-   Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru> */
-int
-addattr_l (struct nlmsghdr *n, int maxlen, int type, void *data, int alen)
-{
-  int len;
-  struct rtattr *rta;
-
-  len = RTA_LENGTH (alen);
-
-  if (NLMSG_ALIGN (n->nlmsg_len) + len > maxlen)
-    return -1;
-
-  rta = (struct rtattr *) (((char *) n) + NLMSG_ALIGN (n->nlmsg_len));
-  rta->rta_type = type;
-  rta->rta_len = len;
-  memcpy (RTA_DATA (rta), data, alen);
-  n->nlmsg_len = NLMSG_ALIGN (n->nlmsg_len) + len;
-
-  return 0;
-}
-
-int
-rta_addattr_l (struct rtattr *rta, int maxlen, int type, void *data, int alen)
-{
-  int len;
-  struct rtattr *subrta;
-
-  len = RTA_LENGTH (alen);
-
-  if (RTA_ALIGN (rta->rta_len) + len > maxlen)
-    return -1;
-
-  subrta = (struct rtattr *) (((char *) rta) + RTA_ALIGN (rta->rta_len));
-  subrta->rta_type = type;
-  subrta->rta_len = len;
-  memcpy (RTA_DATA (subrta), data, alen);
-  rta->rta_len = NLMSG_ALIGN (rta->rta_len) + len;
-
-  return 0;
-}
-
-/* Utility function comes from iproute2. 
-   Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru> */
-int
-addattr32 (struct nlmsghdr *n, int maxlen, int type, int data)
-{
-  int len;
-  struct rtattr *rta;
-
-  len = RTA_LENGTH (4);
-
-  if (NLMSG_ALIGN (n->nlmsg_len) + len > maxlen)
-    return -1;
-
-  rta = (struct rtattr *) (((char *) n) + NLMSG_ALIGN (n->nlmsg_len));
-  rta->rta_type = type;
-  rta->rta_len = len;
-  memcpy (RTA_DATA (rta), &data, 4);
-  n->nlmsg_len = NLMSG_ALIGN (n->nlmsg_len) + len;
-
-  return 0;
-}
-
-static int
-netlink_talk_filter (struct sockaddr_nl *snl, struct nlmsghdr *h)
-{
-  zlog_warn ("netlink_talk: ignoring message type 0x%04x", h->nlmsg_type);
-  return 0;
-}
-
-/* sendmsg() to netlink socket then recvmsg(). */
-int
-netlink_talk (struct nlmsghdr *n, struct nlsock *nl)
-{
-  int status;
-  struct sockaddr_nl snl;
-  struct iovec iov = { (void *) n, n->nlmsg_len };
-  struct msghdr msg = { (void *) &snl, sizeof snl, &iov, 1, NULL, 0, 0 };
-  int flags = 0;
-  int snb_ret;
-  int save_errno;
-
-  memset (&snl, 0, sizeof snl);
-  snl.nl_family = AF_NETLINK;
-
-  n->nlmsg_seq = ++nl->seq;
-
-  /* Request an acknowledgement by setting NLM_F_ACK */
-  n->nlmsg_flags |= NLM_F_ACK;
-
-  if (IS_ZEBRA_DEBUG_KERNEL)
-    zlog_debug ("netlink_talk: %s type %s(%u), seq=%u", nl->name,
-               lookup (nlmsg_str, n->nlmsg_type), n->nlmsg_type,
-               n->nlmsg_seq);
-
-  /* Send message to netlink interface. */
-  if (zserv_privs.change (ZPRIVS_RAISE))
-    zlog (NULL, LOG_ERR, "Can't raise privileges");
-  status = sendmsg (nl->sock, &msg, 0);
-  save_errno = errno;
-  if (zserv_privs.change (ZPRIVS_LOWER))
-    zlog (NULL, LOG_ERR, "Can't lower privileges");
-
-  if (status < 0)
-    {
-      zlog (NULL, LOG_ERR, "netlink_talk sendmsg() error: %s",
-            safe_strerror (save_errno));
-      return -1;
-    }
-
-  /* 
-   * Change socket flags for blocking I/O. 
-   * This ensures we wait for a reply in netlink_parse_info().
-   */
-  snb_ret = set_netlink_blocking (nl, &flags);
-  if (snb_ret < 0)
-    zlog (NULL, LOG_WARNING,
-          "%s:%i Warning: Could not set netlink socket to blocking.",
-          __FUNCTION__, __LINE__);
-
-  /* 
-   * Get reply from netlink socket. 
-   * The reply should either be an acknowlegement or an error.
-   */
-  status = netlink_parse_info (netlink_talk_filter, nl);
-
-  /* Restore socket flags for nonblocking I/O */
-  if (snb_ret == 0)
-    set_netlink_nonblocking (nl, &flags);
-
-  return status;
-}
-
 /* Routing table change via netlink interface. */
-int
+static int
 netlink_route (int cmd, int family, void *dest, int length, void *gate,
                int index, int zebra_flags, int table)
 {
@@ -1389,7 +956,7 @@ netlink_route (int cmd, int family, void *dest, int length, void *gate,
   snl.nl_family = AF_NETLINK;
 
   /* Talk to netlink socket. */
-  ret = netlink_talk (&req.n, &netlink_cmd);
+  ret = netlink_talk (&req.n, &netlink_cmd, NULL, 0);
   if (ret < 0)
     return -1;
 
@@ -1397,7 +964,7 @@ netlink_route (int cmd, int family, void *dest, int length, void *gate,
 }
 
 /* Routing table change via netlink interface. */
-int
+static int
 netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
                          int family)
 {
@@ -1406,6 +973,7 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
   struct nexthop *nexthop = NULL;
   int nexthop_num = 0;
   int discard;
+  int advmss = 0;
 
   struct
   {
@@ -1456,8 +1024,11 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
   if (discard)
     {
       if (cmd == RTM_NEWROUTE)
-        for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
+        for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next) {
+          if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_IGNORE))
+	      continue;
           SET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
+        }
       goto skip;
     }
 
@@ -1466,8 +1037,11 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
     {
       for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
         {
+	  if (nexthop->advmss && nexthop->advmss > advmss)
+	    advmss = nexthop->advmss;
 
           if ((cmd == RTM_NEWROUTE
+               && !CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_IGNORE)
                && CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE))
               || (cmd == RTM_DELROUTE
                   && CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB)))
@@ -1487,17 +1061,18 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 			 inet_ntoa (p->u.prefix4),
 #endif /* HAVE_IPV6 */
 			 
-			 p->prefixlen, nexthop_types_desc[nexthop->rtype]);
+			 p->prefixlen, nexthop_types_desc(nexthop->rtype));
                     }
 
-                  if (nexthop->rtype == NEXTHOP_TYPE_IPV4
-                      || nexthop->rtype == NEXTHOP_TYPE_IPV4_IFINDEX)
+                  if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV4))
 		    {
 		      addattr_l (&req.n, sizeof req, RTA_GATEWAY,
 				 &nexthop->rgate.ipv4, bytelen);
+
                       if (nexthop->src.ipv4.s_addr)
 		          addattr_l(&req.n, sizeof req, RTA_PREFSRC,
 				     &nexthop->src.ipv4, bytelen);
+
 		      if (IS_ZEBRA_DEBUG_KERNEL)
 			zlog_debug("netlink_route_multipath() (recursive, "
 				   "1 hop): nexthop via %s if %u",
@@ -1505,9 +1080,7 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 				   nexthop->rifindex);
 		    }
 #ifdef HAVE_IPV6
-                  if (nexthop->rtype == NEXTHOP_TYPE_IPV6
-                      || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFINDEX
-                      || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFNAME)
+                  else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV6))
 		    {
 		      addattr_l (&req.n, sizeof req, RTA_GATEWAY,
 				 &nexthop->rgate.ipv6, bytelen);
@@ -1519,25 +1092,50 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 				   nexthop->rifindex);
 		    }
 #endif /* HAVE_IPV6 */
-                  if (nexthop->rtype == NEXTHOP_TYPE_IFINDEX
-                      || nexthop->rtype == NEXTHOP_TYPE_IFNAME
-                      || nexthop->rtype == NEXTHOP_TYPE_IPV4_IFINDEX
-                      || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFINDEX
-                      || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFNAME)
+		  else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_DROP))
+		    {
+		      if (IS_ZEBRA_DEBUG_KERNEL)
+			zlog_debug("netlink_route_multipath() (recursive, "
+				   "1 hop): nexthop DROP(%d)", nexthop->drop);
+		    }
+
+                  if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IFINDEX) &&
+		      !(CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV4) ||
+		        CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV6)))
 		    {
 		      addattr32 (&req.n, sizeof req, RTA_OIF,
 				 nexthop->rifindex);
-                      if ((nexthop->rtype == NEXTHOP_TYPE_IPV4_IFINDEX
-                           || nexthop->rtype == NEXTHOP_TYPE_IFINDEX)
-                          && nexthop->src.ipv4.s_addr)
-                        addattr_l (&req.n, sizeof req, RTA_PREFSRC,
-				 &nexthop->src.ipv4, bytelen);
 
 		      if (IS_ZEBRA_DEBUG_KERNEL)
 			zlog_debug("netlink_route_multipath() (recursive, "
 				   "1 hop): nexthop via if %u",
 				   nexthop->rifindex);
 		    }
+
+#ifdef HAVE_MPLS
+                  if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_MPLS))
+                    {
+#ifdef LINUX_MPLS
+		      struct zmpls_out_segment *out;
+		      char buf[sizeof(struct rtshim) + sizeof(unsigned int)];
+		      struct rtshim *shim = (struct rtshim*)buf;
+		      out = mpls_out_segment_find(nexthop->rmpls);
+		      if (out) {
+		        strcpy(shim->name, "mpls");
+		        shim->datalen = sizeof(unsigned int);
+		        *((unsigned int*)(shim->data)) = out->out_key;
+                        addattr_l(&req.n, sizeof(req), RTA_SHIM,
+			  shim, sizeof(buf));
+		        if (IS_ZEBRA_DEBUG_KERNEL)
+			  zlog_debug("netlink_route_multipath() (recursive, "
+				     "1 hop): MPLS info %08x", out->out_key);
+		      } else {
+		        zlog_debug("netlink_route_multipath() (multihop): "
+				   "unable to find NHLFE %d", nexthop->rmpls);
+		      }
+#endif
+                    }
+#endif /* HAVE_MPLS */
                 }
               else
                 {
@@ -1552,14 +1150,14 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 #else
 			 inet_ntoa (p->u.prefix4),
 #endif /* HAVE_IPV6 */
-			 p->prefixlen, nexthop_types_desc[nexthop->type]);
+			 p->prefixlen, nexthop_types_desc(nexthop->type));
                     }
 
-                  if (nexthop->type == NEXTHOP_TYPE_IPV4
-                      || nexthop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
+                  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
 		    {
 		      addattr_l (&req.n, sizeof req, RTA_GATEWAY,
 				 &nexthop->gate.ipv4, bytelen);
+
 		      if (nexthop->src.ipv4.s_addr)
                         addattr_l (&req.n, sizeof req, RTA_PREFSRC,
 				 &nexthop->src.ipv4, bytelen);
@@ -1571,9 +1169,7 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 				   nexthop->ifindex);
 		    }
 #ifdef HAVE_IPV6
-                  if (nexthop->type == NEXTHOP_TYPE_IPV6
-                      || nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME
-                      || nexthop->type == NEXTHOP_TYPE_IPV6_IFINDEX)
+                  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
 		    {
 		      addattr_l (&req.n, sizeof req, RTA_GATEWAY,
 				 &nexthop->gate.ipv6, bytelen);
@@ -1585,22 +1181,16 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 				   nexthop->ifindex);
 		    }
 #endif /* HAVE_IPV6 */
-                  if (nexthop->type == NEXTHOP_TYPE_IFINDEX
-                      || nexthop->type == NEXTHOP_TYPE_IFNAME
-                      || nexthop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
+                  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_DROP))
 		    {
-		      addattr32 (&req.n, sizeof req, RTA_OIF, nexthop->ifindex);
-
-		      if (nexthop->src.ipv4.s_addr)
-                        addattr_l (&req.n, sizeof req, RTA_PREFSRC,
-				 &nexthop->src.ipv4, bytelen);
-
 		      if (IS_ZEBRA_DEBUG_KERNEL)
 			zlog_debug("netlink_route_multipath() (single hop): "
-				   "nexthop via if %u", nexthop->ifindex);
+				   "nexthop DROP(%d)", nexthop->drop);
 		    }
-                  else if (nexthop->type == NEXTHOP_TYPE_IPV6_IFINDEX
-                      || nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME)
+
+                  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX) &&
+		      !(CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4) ||
+		        CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6)))
 		    {
 		      addattr32 (&req.n, sizeof req, RTA_OIF, nexthop->ifindex);
 
@@ -1608,6 +1198,31 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 			zlog_debug("netlink_route_multipath() (single hop): "
 				   "nexthop via if %u", nexthop->ifindex);
 		    }
+
+#ifdef HAVE_MPLS
+                  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_MPLS))
+                    {
+#ifdef LINUX_MPLS
+		      struct zmpls_out_segment *out;
+		      char buf[sizeof(struct rtshim) + sizeof(unsigned int)];
+		      struct rtshim *shim = (struct rtshim*)buf;
+		      out = mpls_out_segment_find(nexthop->mpls);
+		      if (out) {
+		        strcpy(shim->name, "mpls");
+		        shim->datalen = sizeof(unsigned int);
+		        *((unsigned int*)(shim->data)) = out->out_key;
+                        addattr_l(&req.n, sizeof(req), RTA_SHIM,
+			  shim, sizeof(buf));
+		        if (IS_ZEBRA_DEBUG_KERNEL)
+			  zlog_debug("netlink_route_multipath() (single hop): "
+				     "MPLS info %08x", out->out_key);
+		      } else {
+		        zlog_debug("netlink_route_multipath() (single hop): "
+				   "unable to find NHLFE %d", nexthop->mpls);
+		      }
+#endif
+                    }
+#endif /* HAVE_MPLS */
                 }
 
               if (cmd == RTM_NEWROUTE)
@@ -1634,7 +1249,11 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
            nexthop && (MULTIPATH_NUM == 0 || nexthop_num < MULTIPATH_NUM);
            nexthop = nexthop->next)
         {
+          if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_IGNORE))
+	      continue;
+
           if ((cmd == RTM_NEWROUTE
+               && !CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_IGNORE)
                && CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE))
               || (cmd == RTM_DELROUTE
                   && CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB)))
@@ -1659,10 +1278,9 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 #else
 			 inet_ntoa (p->u.prefix4),
 #endif /* HAVE_IPV6 */
-                         p->prefixlen, nexthop_types_desc[nexthop->rtype]);
+                         p->prefixlen, nexthop_types_desc(nexthop->type));
                     }
-                  if (nexthop->rtype == NEXTHOP_TYPE_IPV4
-                      || nexthop->rtype == NEXTHOP_TYPE_IPV4_IFINDEX)
+                  if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV4))
                     {
                       rta_addattr_l (rta, 4096, RTA_GATEWAY,
                                      &nexthop->rgate.ipv4, bytelen);
@@ -1678,9 +1296,7 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 				   nexthop->rifindex);
                     }
 #ifdef HAVE_IPV6
-                  if (nexthop->rtype == NEXTHOP_TYPE_IPV6
-                      || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFNAME
-                      || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFINDEX)
+                  else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV6))
 		    {
 		      rta_addattr_l (rta, 4096, RTA_GATEWAY,
 				     &nexthop->rgate.ipv6, bytelen);
@@ -1692,22 +1308,16 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 				   nexthop->rifindex);
 		    }
 #endif /* HAVE_IPV6 */
-                  /* ifindex */
-                  if (nexthop->rtype == NEXTHOP_TYPE_IPV4_IFINDEX
-		      || nexthop->rtype == NEXTHOP_TYPE_IFINDEX
-                      || nexthop->rtype == NEXTHOP_TYPE_IFNAME)
+		  else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_DROP))
 		    {
-		      rtnh->rtnh_ifindex = nexthop->rifindex;
-                      if (nexthop->src.ipv4.s_addr)
-                        src = &nexthop->src;
-
-		      if (IS_ZEBRA_DEBUG_KERNEL)
 			zlog_debug("netlink_route_multipath() (recursive, "
-				   "multihop): nexthop via if %u",
-				   nexthop->rifindex);
+				   "multihop): nexthop DROP %d", nexthop->drop);
 		    }
-		  else if (nexthop->rtype == NEXTHOP_TYPE_IPV6_IFINDEX
-                      || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFNAME)
+
+                  /* ifindex */
+                  if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IFINDEX) &&
+		      !(CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV4) ||
+		        CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV6)))
 		    {
 		      rtnh->rtnh_ifindex = nexthop->rifindex;
 
@@ -1720,6 +1330,32 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 		    {
 		      rtnh->rtnh_ifindex = 0;
 		    }
+
+#ifdef HAVE_MPLS
+                  if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_MPLS))
+                    {
+#ifdef LINUX_MPLS
+		      struct zmpls_out_segment *out;
+		      char buf[sizeof(struct rtshim) + sizeof(unsigned int)];
+		      struct rtshim *shim = (struct rtshim*)buf;
+		      out = mpls_out_segment_find(nexthop->rmpls);
+		      if (out) {
+		        strcpy(shim->name, "mpls");
+		        shim->datalen = sizeof(unsigned int);
+		        *((unsigned int*)(shim->data)) = out->out_key;
+                        addattr_l(&req.n, sizeof(req), RTA_SHIM,
+			  shim, sizeof(buf));
+		        if (IS_ZEBRA_DEBUG_KERNEL)
+			  zlog_debug("netlink_route_multipath() (recursive "
+                                     "multihop): MPLS info %08x", out->out_key);
+		      } else {
+		        zlog_debug("netlink_route_multipath() (recursive "
+                                   "multihop): unable to find NHLFE %d",
+                                   nexthop->rmpls);
+		      }
+#endif
+                    }
+#endif /* HAVE_MPLS */
                 }
               else
                 {
@@ -1733,10 +1369,9 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 #else
 			 inet_ntoa (p->u.prefix4),
 #endif /* HAVE_IPV6 */
-			 p->prefixlen, nexthop_types_desc[nexthop->type]);
+			 p->prefixlen, nexthop_types_desc(nexthop->type));
                     }
-                  if (nexthop->type == NEXTHOP_TYPE_IPV4
-                      || nexthop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
+                  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
                     {
 		      rta_addattr_l (rta, 4096, RTA_GATEWAY,
 				     &nexthop->gate.ipv4, bytelen);
@@ -1752,9 +1387,7 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 				   nexthop->ifindex);
                     }
 #ifdef HAVE_IPV6
-                  if (nexthop->type == NEXTHOP_TYPE_IPV6
-                      || nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME
-                      || nexthop->type == NEXTHOP_TYPE_IPV6_IFINDEX)
+                  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
 		    { 
 		      rta_addattr_l (rta, 4096, RTA_GATEWAY,
 				     &nexthop->gate.ipv6, bytelen);
@@ -1766,20 +1399,16 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 				   nexthop->ifindex);
 		    }
 #endif /* HAVE_IPV6 */
-                  /* ifindex */
-                  if (nexthop->type == NEXTHOP_TYPE_IPV4_IFINDEX
-		      || nexthop->type == NEXTHOP_TYPE_IFINDEX
-                      || nexthop->type == NEXTHOP_TYPE_IFNAME)
-                    {
-		      rtnh->rtnh_ifindex = nexthop->ifindex;
-		      if (nexthop->src.ipv4.s_addr)
-			src = &nexthop->src;
-		      if (IS_ZEBRA_DEBUG_KERNEL)
+		  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_DROP))
+		    {
 			zlog_debug("netlink_route_multipath() (multihop): "
-				   "nexthop via if %u", nexthop->ifindex);
+				   "nexthop DROP %d", nexthop->drop);
 		    }
-                  else if (nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME
-                      || nexthop->type == NEXTHOP_TYPE_IPV6_IFINDEX)
+
+                  /* ifindex */
+                  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX) &&
+		      !(CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4) ||
+		        CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6)))
 		    {
 		      rtnh->rtnh_ifindex = nexthop->ifindex;
 
@@ -1791,6 +1420,31 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 		    {
 		      rtnh->rtnh_ifindex = 0;
 		    }
+
+#ifdef HAVE_MPLS
+                  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_MPLS))
+                    {
+#ifdef LINUX_MPLS
+		      struct zmpls_out_segment *out;
+		      char buf[sizeof(struct rtshim) + sizeof(unsigned int)];
+		      struct rtshim *shim = (struct rtshim*)buf;
+		      out = mpls_out_segment_find(nexthop->mpls);
+		      if (out) {
+		        strcpy(shim->name, "mpls");
+		        shim->datalen = sizeof(unsigned int);
+		        *((unsigned int*)(shim->data)) = out->out_key;
+                        addattr_l(&req.n, sizeof(req), RTA_SHIM,
+			  shim, sizeof(buf));
+		        if (IS_ZEBRA_DEBUG_KERNEL)
+			  zlog_debug("netlink_route_multipath() (multihop): "
+                                     "MPLS info %08x", out->out_key);
+		      } else {
+		        zlog_debug("netlink_route_multipath() (multihop): "
+				   "unable to find NHLFE %d", nexthop->mpls);
+		      }
+#endif
+                    }
+#endif /* HAVE_MPLS */
                 }
               rtnh = RTNH_NEXT (rtnh);
 
@@ -1806,6 +1460,20 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
                    RTA_PAYLOAD (rta));
     }
 
+  if (advmss)
+    {
+      char buf[1024];
+      struct rtattr *rta = (void *) buf;
+      unsigned int mss = advmss;
+
+      rta->rta_type = RTA_METRICS;
+      rta->rta_len = RTA_LENGTH (0);
+
+      rta_addattr_l (rta, sizeof (buf), RTAX_ADVMSS, &mss, sizeof (mss));
+      addattr_l(&req.n, sizeof (buf), RTA_METRICS, RTA_DATA (rta),
+	        RTA_PAYLOAD (rta));
+   }
+
   /* If there is no useful nexthop then return. */
   if (nexthop_num == 0)
     {
@@ -1821,7 +1489,7 @@ skip:
   snl.nl_family = AF_NETLINK;
 
   /* Talk to netlink socket. */
-  return netlink_talk (&req.n, &netlink_cmd);
+  return netlink_talk (&req.n, &netlink_cmd, NULL, 0);
 }
 
 int
@@ -1860,7 +1528,7 @@ kernel_delete_ipv6_old (struct prefix_ipv6 *dest, struct in6_addr *gate,
 #endif /* HAVE_IPV6 */
 
 /* Interface address modification. */
-int
+static int
 netlink_address (int cmd, int family, struct interface *ifp,
                  struct connected *ifc)
 {
@@ -1897,6 +1565,12 @@ netlink_address (int cmd, int family, struct interface *ifp,
           addattr_l (&req.n, sizeof req, IFA_BROADCAST, &p->u.prefix,
                      bytelen);
         }
+      else if (if_is_pointopoint (ifp) && ifc->destination)
+        {
+          p = ifc->destination;
+          addattr_l (&req.n, sizeof req, IFA_ADDRESS, &p->u.prefix,
+                     bytelen);
+        }
     }
 
   if (CHECK_FLAG (ifc->flags, ZEBRA_IFA_SECONDARY))
@@ -1906,7 +1580,7 @@ netlink_address (int cmd, int family, struct interface *ifp,
     addattr_l (&req.n, sizeof req, IFA_LABEL, ifc->label,
                strlen (ifc->label) + 1);
 
-  return netlink_talk (&req.n, &netlink_cmd);
+  return netlink_talk (&req.n, &netlink_cmd, NULL, 0);
 }
 
 int
@@ -1925,14 +1599,14 @@ kernel_address_delete_ipv4 (struct interface *ifp, struct connected *ifc)
 extern struct thread_master *master;
 
 /* Kernel route reflection. */
-int
+static int
 kernel_read (struct thread *thread)
 {
   int ret;
   int sock;
 
   sock = THREAD_FD (thread);
-  ret = netlink_parse_info (netlink_information_fetch, &netlink);
+  ret = netlink_parse_info (netlink_information_fetch, &netlink, NULL, 0);
   thread_add_read (zebrad.master, kernel_read, NULL, netlink.sock);
 
   return 0;
@@ -1999,8 +1673,8 @@ kernel_init (void)
 #ifdef HAVE_IPV6
   groups |= RTMGRP_IPV6_ROUTE | RTMGRP_IPV6_IFADDR;
 #endif /* HAVE_IPV6 */
-  netlink_socket (&netlink, groups);
-  netlink_socket (&netlink_cmd, 0);
+  netlink_socket (&netlink, NETLINK_ROUTE, groups);
+  netlink_socket (&netlink_cmd, NETLINK_ROUTE, 0);
 
   /* Register kernel socket. */
   if (netlink.sock > 0)
diff --git a/zebra/rt_socket.c b/zebra/rt_socket.c
index 1b8ded7..42e8d6d 100644
--- a/zebra/rt_socket.c
+++ b/zebra/rt_socket.c
@@ -114,37 +114,46 @@ kernel_rtm_ipv4 (int cmd, struct prefix *p, struct rib *rib, int family)
 	{
 	  if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_RECURSIVE))
 	    {
-	      if (nexthop->rtype == NEXTHOP_TYPE_IPV4 ||
-		  nexthop->rtype == NEXTHOP_TYPE_IPV4_IFINDEX)
+	      if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV4))
 		{
 		  sin_gate.sin_addr = nexthop->rgate.ipv4;
 		  gate = 1;
 		}
-	      if (nexthop->rtype == NEXTHOP_TYPE_IFINDEX
-		  || nexthop->rtype == NEXTHOP_TYPE_IFNAME
-		  || nexthop->rtype == NEXTHOP_TYPE_IPV4_IFINDEX)
+	      else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV6))
+		assert (0);
+	      else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_DROP))
+	        {
+	          struct in_addr loopback;
+	          loopback.s_addr = htonl (INADDR_LOOPBACK);
+	          sin_gate.sin_addr = loopback;
+	          gate = 1;
+	        }
+
+	      if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IFINDEX))
 		ifindex = nexthop->rifindex;
 	    }
 	  else
 	    {
-	      if (nexthop->type == NEXTHOP_TYPE_IPV4 ||
-		  nexthop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
+	      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
 		{
 		  sin_gate.sin_addr = nexthop->gate.ipv4;
 		  gate = 1;
 		}
-	      if (nexthop->type == NEXTHOP_TYPE_IFINDEX
-		  || nexthop->type == NEXTHOP_TYPE_IFNAME
-		  || nexthop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
+	      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
+		assert (0);
+	      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_DROP))
+	        {
+	          struct in_addr loopback;
+	          loopback.s_addr = htonl (INADDR_LOOPBACK);
+	          sin_gate.sin_addr = loopback;
+	          gate = 1;
+	        }
+
+	      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
 		ifindex = nexthop->ifindex;
-	      if (nexthop->type == NEXTHOP_TYPE_BLACKHOLE)
-		{
-		  struct in_addr loopback;
-		  loopback.s_addr = htonl (INADDR_LOOPBACK);
-		  sin_gate.sin_addr = loopback;
-		  gate = 1;
-		}
-	    }
+
+	  if (cmd == RTM_ADD)
+	    SET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
 
 	  if (gate && p->prefixlen == 32)
 	    mask = NULL;
@@ -390,32 +399,28 @@ kernel_rtm_ipv6_multipath (int cmd, struct prefix *p, struct rib *rib,
 	{
 	  if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_RECURSIVE))
 	    {
-	      if (nexthop->rtype == NEXTHOP_TYPE_IPV6
-		  || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFNAME
-		  || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFINDEX)
+	      if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV6))
 		{
 		  sin_gate.sin6_addr = nexthop->rgate.ipv6;
 		  gate = 1;
 		}
-	      if (nexthop->rtype == NEXTHOP_TYPE_IFINDEX
-		  || nexthop->rtype == NEXTHOP_TYPE_IFNAME
-		  || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFNAME
-		  || nexthop->rtype == NEXTHOP_TYPE_IPV6_IFINDEX)
+	      else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV4))
+		assert (0);
+
+	      if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IFINDEX))
 		ifindex = nexthop->rifindex;
 	    }
 	  else
 	    {
-	      if (nexthop->type == NEXTHOP_TYPE_IPV6
-		  || nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME
-		  || nexthop->type == NEXTHOP_TYPE_IPV6_IFINDEX)
+	      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
 		{
 		  sin_gate.sin6_addr = nexthop->gate.ipv6;
 		  gate = 1;
 		}
-	      if (nexthop->type == NEXTHOP_TYPE_IFINDEX
-		  || nexthop->type == NEXTHOP_TYPE_IFNAME
-		  || nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME
-		  || nexthop->type == NEXTHOP_TYPE_IPV6_IFINDEX)
+	      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
+		assert (0);
+
+	      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
 		ifindex = nexthop->ifindex;
 	    }
 
diff --git a/zebra/rtread_getmsg.c b/zebra/rtread_getmsg.c
index 3e065c6..40a48aa 100644
--- a/zebra/rtread_getmsg.c
+++ b/zebra/rtread_getmsg.c
@@ -71,7 +71,8 @@ handle_route_entry (mib2_ipRouteEntry_t *routeEntry)
 {
 	struct prefix_ipv4	prefix;
  	struct in_addr		tmpaddr, gateway;
-	u_char			zebra_flags = 0;
+	u_short			zebra_flags = 0;
+	struct zapi_nexthop	nh;
 
 	if (routeEntry->ipRouteInfo.re_ire_type & IRE_CACHETABLE)
 		return;
@@ -79,6 +80,8 @@ handle_route_entry (mib2_ipRouteEntry_t *routeEntry)
 	if (routeEntry->ipRouteInfo.re_ire_type & IRE_HOST_REDIRECT)
 		zebra_flags |= ZEBRA_FLAG_SELFROUTE;
 
+	memset(&nh, 0, sizeof(struct zapi_nexthop));
+
 	prefix.family = AF_INET;
 
 	tmpaddr.s_addr = routeEntry->ipRouteDest;
@@ -88,9 +91,11 @@ handle_route_entry (mib2_ipRouteEntry_t *routeEntry)
 	prefix.prefixlen = ip_masklen (tmpaddr);
 
 	gateway.s_addr = routeEntry->ipRouteNextHop;
+	nh.gw.ipv4 = gateway;
+	SET_FLAG(nh.type, ZEBRA_NEXTHOP_IPV4);
 
-	rib_add_ipv4 (ZEBRA_ROUTE_KERNEL, zebra_flags, &prefix,
-		      &gateway, NULL, 0, 0, 0, 0);
+	rib_add_route (ZEBRA_ROUTE_KERNEL, zebra_flags,
+                       (struct prefix*)&prefix, &nh, 0, 0, 0);
 }
 
 void
diff --git a/zebra/rtread_netlink.c b/zebra/rtread_netlink.c
index 0b255a5..ac1cd1f 100644
--- a/zebra/rtread_netlink.c
+++ b/zebra/rtread_netlink.c
@@ -22,8 +22,12 @@
 
 #include <zebra.h>
 
-/* Extern from rt_netlink.c */
-void netlink_route_read ();
+#include "if.h"
+#include "prefix.h"
+#include "rib.h"
+
+#include "zebra/zserv.h"
+#include "zebra/rt_netlink.h"
 
 void route_read ()
 {
diff --git a/zebra/rtread_proc.c b/zebra/rtread_proc.c
index 1de435a..adc4c96 100644
--- a/zebra/rtread_proc.c
+++ b/zebra/rtread_proc.c
@@ -72,7 +72,8 @@ proc_route_read (void)
       struct prefix_ipv4 p;
       struct in_addr tmpmask;
       struct in_addr gateway;
-      u_char zebra_flags = 0;
+      struct zapi_nexthop nh;
+      u_short zebra_flags = 0;
 
       n = sscanf (buf, "%s %s %s %x %d %d %d %s %d %d %d",
 		  iface, dest, gate, &flags, &refcnt, &use, &metric, 
@@ -87,6 +88,8 @@ proc_route_read (void)
       if (! (flags & RTF_GATEWAY))
 	continue;
 
+      memset(&nh, 0, sizeof(struct zapi_nexthop));
+
       if (flags & RTF_DYNAMIC)
 	zebra_flags |= ZEBRA_FLAG_SELFROUTE;
 
@@ -96,7 +99,11 @@ proc_route_read (void)
       p.prefixlen = ip_masklen (tmpmask);
       sscanf (gate, "%lX", (unsigned long *)&gateway);
 
-      rib_add_ipv4 (ZEBRA_ROUTE_KERNEL, zebra_flags, &p, &gateway, NULL, 0, 0, 0, 0);
+      SET_FLAG(nh.type, ZEBRA_NEXTHOP_IPV4);
+      nh.gw.ipv4 = gateway;
+
+      rib_add_route (ZEBRA_ROUTE_KERNEL, zebra_flags, (struct prefix*)&p,
+                     &nh, 0, 0, 0);
     }
 
   fclose (fp);
@@ -129,7 +136,8 @@ proc_ipv6_route_read ()
       int metric, use, refcnt, flags;
       struct prefix_ipv6 p;
       struct in6_addr gateway;
-      u_char zebra_flags = 0;
+      u_short zebra_flags = 0;
+      struct zapi_nexthop nh;
 
       /* Linux 2.1.x write this information at net/ipv6/route.c
          rt6_info_node () */
@@ -148,6 +156,8 @@ proc_ipv6_route_read ()
       if (! (flags & RTF_GATEWAY))
 	continue;
 
+      memset(&nh, 0, sizeof(struct zapi_nexthop));
+
       if (flags & RTF_DYNAMIC)
 	zebra_flags |= ZEBRA_FLAG_SELFROUTE;
 
@@ -156,8 +166,11 @@ proc_ipv6_route_read ()
       str2in6_addr (gate, &gateway);
       p.prefixlen = dest_plen;
 
-      rib_add_ipv6 (ZEBRA_ROUTE_KERNEL, zebra_flags, &p, &gateway, 0, 0,
-		    metric, 0);
+      SET_FLAG(nh.type, ZEBRA_NEXTHOP_IPV4);
+      nh.gw.ipv4 = gateway;
+
+      rib_add_route (ZEBRA_ROUTE_KERNEL, zebra_flags, (struct prefix*)&p,
+                     &nh, 0, metric, 0);
     }
 
   fclose (fp);
diff --git a/zebra/zebra_rib.c b/zebra/zebra_rib.c
index 4cb72ba..59fd9b4 100644
--- a/zebra/zebra_rib.c
+++ b/zebra/zebra_rib.c
@@ -72,6 +72,11 @@ struct
 /* Vector for routing table.  */
 vector vrf_vector;
 
+#ifdef HAVE_IPV6
+static int
+rib_bogus_ipv6 (int, struct prefix_ipv6*, struct in6_addr*, unsigned int, int);
+#endif
+
 /* Allocate new VRF.  */
 static struct vrf *
 vrf_alloc (const char *name)
@@ -165,173 +170,432 @@ vrf_static_table (afi_t afi, safi_t safi, u_int32_t id)
   return vrf->stable[afi][safi];
 }
 
-/* Add nexthop to the end of the list.  */
-static void
-nexthop_add (struct rib *rib, struct nexthop *nexthop)
+static int
+zapi_nexthop_str(struct zapi_nexthop *nh, char *buf, int size)
 {
-  struct nexthop *last;
+  struct interface *ifp = NULL;
+  char buf1[BUFSIZ];
+  char *ptr = buf;
+  int len = 0;
 
-  for (last = rib->nexthop; last && last->next; last = last->next)
-    ;
-  if (last)
-    last->next = nexthop;
-  else
-    rib->nexthop = nexthop;
-  nexthop->prev = last;
+  if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_DROP))
+    {
+      switch (nh->gw.drop)
+        {
+	  case ZEBRA_DROP_NULL:
+	    len = snprintf(buf, size, " Null0");
+	    break;
+	  case ZEBRA_DROP_REJECT:
+	    len = snprintf(buf, size, " reject");
+	    break;
+	  case ZEBRA_DROP_BLACKHOLE:
+	    len = snprintf(buf, size, " blackhole");
+	    break;
+	  default:
+	    assert(0);
+        }
+    }
 
-  rib->nexthop_num++;
-}
+  if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_IPV4))
+    {
+      inet_ntop (AF_INET, &nh->gw.ipv4, buf1, BUFSIZ),
+      len += snprintf(ptr, size, " via %s", buf1);
+      ptr = &buf[len];
+    }
+#ifdef HAVE_IPV6
+  else if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_IPV6))
+    {
+      inet_ntop (AF_INET6, &nh->gw.ipv6, buf1, BUFSIZ),
+      len += snprintf(ptr, size, " via %s", buf1);
+      ptr = &buf[len];
+    }
+#endif
 
-/* Delete specified nexthop from the list. */
-static void
-nexthop_delete (struct rib *rib, struct nexthop *nexthop)
-{
-  if (nexthop->next)
-    nexthop->next->prev = nexthop->prev;
-  if (nexthop->prev)
-    nexthop->prev->next = nexthop->next;
-  else
-    rib->nexthop = nexthop->next;
-  rib->nexthop_num--;
-}
+  if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_IFINDEX))
+    {
+      ifp = if_lookup_by_index (nh->intf.index);
+    }
+  else if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_IFNAME))
+    {
+      ifp = if_lookup_by_name (nh->intf.name);
+    }
 
-/* Free nexthop. */
-static void
-nexthop_free (struct nexthop *nexthop)
-{
-  if (nexthop->ifname)
-    XFREE (0, nexthop->ifname);
-  XFREE (MTYPE_NEXTHOP, nexthop);
+  if (ifp)
+    {
+      len += snprintf(ptr, size - len, " intf %s(%d)", ifp->name, ifp->ifindex);
+      ptr = &buf[len];
+    }
+#ifdef HAVE_MPLS
+  if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_MPLS))
+    {
+      struct zmpls_out_segment *out;
+      out = mpls_out_segment_find(&nh->mpls);
+      if (out)
+	{
+	  len += snprintf(ptr, size - len, " mpls 0x%08x", nh->mpls);
+	  ptr = &buf[len];
+	}
+    }
+#endif
+  return len;  
 }
 
-struct nexthop *
-nexthop_ifindex_add (struct rib *rib, unsigned int ifindex)
+static int
+nexthop_str(struct nexthop *nh, char *buf, int size)
 {
-  struct nexthop *nexthop;
+  struct interface *ifp = NULL;
+  char buf1[BUFSIZ];
+  char *ptr = buf;
+  int len = 0;
 
-  nexthop = XMALLOC (MTYPE_NEXTHOP, sizeof (struct nexthop));
-  memset (nexthop, 0, sizeof (struct nexthop));
-  nexthop->type = NEXTHOP_TYPE_IFINDEX;
-  nexthop->ifindex = ifindex;
+  if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_DROP))
+    {
+      switch (nh->drop)
+        {
+	  case ZEBRA_DROP_NULL:
+	    len = snprintf(buf, size, " Null0");
+	    break;
+	  case ZEBRA_DROP_REJECT:
+	    len = snprintf(buf, size, " reject");
+	    break;
+	  case ZEBRA_DROP_BLACKHOLE:
+	    len = snprintf(buf, size, " blackhole");
+	    break;
+	  default:
+	    assert(0);
+        }
+    }
 
-  nexthop_add (rib, nexthop);
+  if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_IPV4))
+    {
+      inet_ntop (AF_INET, &nh->gate.ipv4, buf1, BUFSIZ),
+      len += snprintf(ptr, size, " via %s", buf1);
+      ptr = &buf[len];
+    }
+#ifdef HAVE_IPV6
+  else if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_IPV6))
+    {
+      inet_ntop (AF_INET6, &nh->gate.ipv6, buf1, BUFSIZ),
+      len += snprintf(ptr, size, " via %s", buf1);
+      ptr = &buf[len];
+    }
+#endif
 
-  return nexthop;
+  if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_IFINDEX))
+    {
+      ifp = if_lookup_by_index (nh->ifindex);
+    }
+  else if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_IFNAME))
+    {
+      ifp = if_lookup_by_name (nh->ifname);
+    }
+
+  if (ifp)
+    {
+      len += snprintf(ptr, size - len, " intf %s(%d)", ifp->name, ifp->ifindex);
+      ptr = &buf[len];
+    }
+#ifdef HAVE_MPLS
+  if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_MPLS))
+    {
+      struct zmpls_out_segment *out;
+      out = mpls_out_segment_find(&nh->mpls);
+      if (out)
+	{
+	  len += snprintf(ptr, size - len, " mpls 0x%08x", nh->mpls);
+	  ptr = &buf[len];
+	}
+    }
+#endif
+  return len;  
 }
 
-struct nexthop *
-nexthop_ifname_add (struct rib *rib, char *ifname)
+static int
+zapi_nexthop_match_nexthop(struct zapi_nexthop *znh, struct nexthop *nh, int mask)
 {
-  struct nexthop *nexthop;
+  int either = (nh->type | znh->type) & mask;
+  int both = (nh->type & znh->type) & mask;
+  int try = 0;
+  int match = 0;
+  int v4_gate_match = 0;
 
-  nexthop = XMALLOC (MTYPE_NEXTHOP, sizeof (struct nexthop));
-  memset (nexthop, 0, sizeof (struct nexthop));
-  nexthop->type = NEXTHOP_TYPE_IFNAME;
-  nexthop->ifname = XSTRDUP (0, ifname);
+  try++;
+  if (nh->advmss == znh->advmss)
+    match++;
+
+  if (CHECK_FLAG(either, ZEBRA_NEXTHOP_DROP))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_DROP) &&
+	  nh->drop == znh->gw.drop)
+        match++;
+    }
+  else if (CHECK_FLAG(either, ZEBRA_NEXTHOP_IPV4))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_IPV4) &&
+         (IPV4_ADDR_SAME (&nh->gate.ipv4, &znh->gw.ipv4) ||
+          IPV4_ADDR_SAME (&nh->rgate.ipv4, &znh->gw.ipv4)))
+	{
+	  match++;
+	  v4_gate_match = 1;
+	}
+    }
+#ifdef HAVE_IPV6
+  else if (CHECK_FLAG(either, ZEBRA_NEXTHOP_IPV6))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_IPV6) &&
+         (IPV6_ADDR_SAME (&nh->gate.ipv6, &znh->gw.ipv6) ||
+          IPV6_ADDR_SAME (&nh->rgate.ipv6, &znh->gw.ipv6)))
+        match++;
+    }
+#endif
 
-  nexthop_add (rib, nexthop);
+  if (CHECK_FLAG(either, ZEBRA_NEXTHOP_IFINDEX))
+    {
+      if (!v4_gate_match)
+        {
+          try++;
+          if (CHECK_FLAG (both, ZEBRA_NEXTHOP_IFINDEX) &&
+            (nh->ifindex == znh->intf.index))
+            match++;
+        }
+      else if (CHECK_FLAG (both, ZEBRA_NEXTHOP_IFINDEX))
+        {
+            try++;
+            if (nh->ifindex == znh->intf.index)
+              match++;
+        }
+    }
+  else if (CHECK_FLAG(either, ZEBRA_NEXTHOP_IFNAME))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_IFNAME) &&
+         (!strncmp(nh->ifname, znh->intf.name, IFNAMSIZ)))
+        match++;
+    }
 
-  return nexthop;
+  if (CHECK_FLAG(either, ZEBRA_NEXTHOP_SRC_IPV4))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_SRC_IPV4) &&
+          IPV4_ADDR_SAME (&nh->src.ipv4, &znh->src.ipv4))
+        match++;
+    }
+#ifdef HAVE_IPV6
+  else if (CHECK_FLAG(either, ZEBRA_NEXTHOP_SRC_IPV6))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_SRC_IPV6) &&
+          IPV6_ADDR_SAME (&nh->src.ipv6, &znh->src.ipv6))
+        match++;
+    }
+#endif
+#ifdef HAVE_MPLS
+  if (CHECK_FLAG(either, ZEBRA_NEXTHOP_MPLS))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_MPLS) &&
+          nh->mpls == mpls_out_segment_find_index_by_nexthop(znh))
+        match++;
+    }
+#endif
+  return (try && try == match) ? 1 : 0;
 }
 
-struct nexthop *
-nexthop_ipv4_add (struct rib *rib, struct in_addr *ipv4, struct in_addr *src)
+static int
+zapi_nexthop_match_static_route(u_char distance, struct zapi_nexthop *znh,
+                                struct static_route *si)
 {
-  struct nexthop *nexthop;
+  int try = 0;
+  int match = 0;
 
-  nexthop = XMALLOC (MTYPE_NEXTHOP, sizeof (struct nexthop));
-  memset (nexthop, 0, sizeof (struct nexthop));
-  nexthop->type = NEXTHOP_TYPE_IPV4;
-  nexthop->gate.ipv4 = *ipv4;
-  if (src)
-    nexthop->src.ipv4 = *src;
+  try++;
+  if (distance == si->distance)
+    match++;
 
-  nexthop_add (rib, nexthop);
+  try++;
+  if (zapi_nexthop_match(znh, &si->nh, ZEBRA_NEXTHOP_ALL))
+    match++;
 
-  return nexthop;
+  return (try && try == match) ? 1 : 0;
 }
 
-static struct nexthop *
-nexthop_ipv4_ifindex_add (struct rib *rib, struct in_addr *ipv4, 
-                          struct in_addr *src, unsigned int ifindex)
+void
+zapi_nexthop2nexthop(struct zapi_nexthop* znh, struct nexthop *nh)
 {
-  struct nexthop *nexthop;
+  nh->type = znh->type;
+  nh->advmss = znh->advmss;
 
-  nexthop = XMALLOC (MTYPE_NEXTHOP, sizeof (struct nexthop));
-  memset (nexthop, 0, sizeof (struct nexthop));
-  nexthop->type = NEXTHOP_TYPE_IPV4_IFINDEX;
-  nexthop->gate.ipv4 = *ipv4;
-  if (src)
-    nexthop->src.ipv4 = *src;
-  nexthop->ifindex = ifindex;
+  if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_DROP))
+    nh->drop = znh->gw.drop;
+  else if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_SRC_IPV4))
+    nh->src.ipv4 = znh->src.ipv4;
+#ifdef HAVE_IPV6
+  else if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_SRC_IPV6))
+    nh->src.ipv6 = znh->src.ipv6;
+#endif
 
-  nexthop_add (rib, nexthop);
+  if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_IPV4))
+    nh->gate.ipv4 = znh->gw.ipv4;
+#ifdef HAVE_IPV6
+  else if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_IPV6))
+    nh->gate.ipv6 = znh->gw.ipv6;
+#endif
 
-  return nexthop;
+  if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_IFINDEX))
+    nh->ifindex = znh->intf.index;
+  else if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_IFNAME))
+    nh->ifname = XSTRDUP (0, znh->intf.name);
+#ifdef HAVE_MPLS
+  if (CHECK_FLAG(nh->type, ZEBRA_NEXTHOP_MPLS))
+    nh->mpls = mpls_out_segment_find_index_by_nexthop(znh);
+#endif
 }
 
-#ifdef HAVE_IPV6
-struct nexthop *
-nexthop_ipv6_add (struct rib *rib, struct in6_addr *ipv6)
+static int
+nexthop_match(struct nexthop *znh, struct nexthop *nh, int mask)
 {
-  struct nexthop *nexthop;
+  int either = (nh->type | znh->type) & mask;
+  int both = (nh->type & znh->type) & mask;
+  int try = 0;
+  int match = 0;
+  int v4_gate_match = 0;
 
-  nexthop = XMALLOC (MTYPE_NEXTHOP, sizeof (struct nexthop));
-  memset (nexthop, 0, sizeof (struct nexthop));
-  nexthop->type = NEXTHOP_TYPE_IPV6;
-  nexthop->gate.ipv6 = *ipv6;
+  try++;
+  if (nh->advmss == znh->advmss)
+    match++;
 
-  nexthop_add (rib, nexthop);
+  if (CHECK_FLAG(either, ZEBRA_NEXTHOP_DROP))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_DROP) &&
+	  nh->drop == znh->drop)
+        match++;
+    }
+  else if (CHECK_FLAG(either, ZEBRA_NEXTHOP_IPV4))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_IPV4) &&
+         (IPV4_ADDR_SAME (&nh->gate.ipv4, &znh->gate.ipv4) ||
+          IPV4_ADDR_SAME (&nh->rgate.ipv4, &znh->rgate.ipv4)))
+	{
+	  match++;
+	  v4_gate_match = 1;
+	}
+    }
+#ifdef HAVE_IPV6
+  else if (CHECK_FLAG(either, ZEBRA_NEXTHOP_IPV6))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_IPV6) &&
+         (IPV6_ADDR_SAME (&nh->gate.ipv6, &znh->gate.ipv6) ||
+          IPV6_ADDR_SAME (&nh->rgate.ipv6, &znh->rgate.ipv6)))
+        match++;
+    }
+#endif
 
-  return nexthop;
-}
+  if (CHECK_FLAG(either, ZEBRA_NEXTHOP_IFINDEX))
+    {
+      if (!v4_gate_match)
+        {
+          try++;
+          if (CHECK_FLAG (both, ZEBRA_NEXTHOP_IFINDEX) &&
+            (nh->ifindex == znh->ifindex))
+            match++;
+        }
+      else if (CHECK_FLAG (both, ZEBRA_NEXTHOP_IFINDEX))
+        {
+            try++;
+            if (nh->ifindex == znh->ifindex)
+              match++;
+        }
+    }
+  else if (CHECK_FLAG(either, ZEBRA_NEXTHOP_IFNAME))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_IFNAME) &&
+         (!strncmp(nh->ifname, znh->ifname, IFNAMSIZ)))
+        match++;
+    }
 
-static struct nexthop *
-nexthop_ipv6_ifname_add (struct rib *rib, struct in6_addr *ipv6,
-			 char *ifname)
+  if (CHECK_FLAG(either, ZEBRA_NEXTHOP_SRC_IPV4))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_SRC_IPV4) &&
+          IPV4_ADDR_SAME (&nh->src.ipv4, &znh->src.ipv4))
+        match++;
+    }
+#ifdef HAVE_IPV6
+  else if (CHECK_FLAG(either, ZEBRA_NEXTHOP_SRC_IPV6))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_SRC_IPV6) &&
+          IPV6_ADDR_SAME (&nh->src.ipv6, &znh->src.ipv6))
+        match++;
+    }
+#endif
+#ifdef HAVE_MPLS
+  if (CHECK_FLAG(either, ZEBRA_NEXTHOP_MPLS))
+    {
+      try++;
+      if (CHECK_FLAG(both, ZEBRA_NEXTHOP_MPLS) &&
+          nh->mpls == znh->mpls)
+        match++;
+    }
+#endif
+  return (try && try == match) ? 1 : 0;
+}
+/* Add nexthop to the end of the list.  */
+static void
+nexthop_add (struct rib *rib, struct nexthop *nexthop)
 {
-  struct nexthop *nexthop;
-
-  nexthop = XMALLOC (MTYPE_NEXTHOP, sizeof (struct nexthop));
-  memset (nexthop, 0, sizeof (struct nexthop));
-  nexthop->type = NEXTHOP_TYPE_IPV6_IFNAME;
-  nexthop->gate.ipv6 = *ipv6;
-  nexthop->ifname = XSTRDUP (0, ifname);
+  struct nexthop *last;
 
-  nexthop_add (rib, nexthop);
+  for (last = rib->nexthop; last && last->next; last = last->next)
+    ;
+  if (last)
+    last->next = nexthop;
+  else
+    rib->nexthop = nexthop;
+  nexthop->prev = last;
 
-  return nexthop;
+  rib->nexthop_num++;
 }
 
-static struct nexthop *
-nexthop_ipv6_ifindex_add (struct rib *rib, struct in6_addr *ipv6,
-			  unsigned int ifindex)
+/* Delete specified nexthop from the list. */
+void
+nexthop_delete (struct rib *rib, struct nexthop *nexthop)
 {
-  struct nexthop *nexthop;
-
-  nexthop = XMALLOC (MTYPE_NEXTHOP, sizeof (struct nexthop));
-  memset (nexthop, 0, sizeof (struct nexthop));
-  nexthop->type = NEXTHOP_TYPE_IPV6_IFINDEX;
-  nexthop->gate.ipv6 = *ipv6;
-  nexthop->ifindex = ifindex;
-
-  nexthop_add (rib, nexthop);
+  if (nexthop->next)
+    nexthop->next->prev = nexthop->prev;
+  if (nexthop->prev)
+    nexthop->prev->next = nexthop->next;
+  else
+    rib->nexthop = nexthop->next;
+  rib->nexthop_num--;
+}
 
-  return nexthop;
+/* Free nexthop. */
+void
+nexthop_free (struct nexthop *nexthop)
+{
+  if (nexthop->ifname)
+    XFREE (0, nexthop->ifname);
+  XFREE (MTYPE_NEXTHOP, nexthop);
 }
-#endif /* HAVE_IPV6 */
 
 struct nexthop *
-nexthop_blackhole_add (struct rib *rib)
+nexthop_zapi_nexthop_add(struct rib *rib, struct zapi_nexthop* znh)
 {
   struct nexthop *nexthop;
 
   nexthop = XMALLOC (MTYPE_NEXTHOP, sizeof (struct nexthop));
   memset (nexthop, 0, sizeof (struct nexthop));
-  nexthop->type = NEXTHOP_TYPE_BLACKHOLE;
-  SET_FLAG (rib->flags, ZEBRA_FLAG_BLACKHOLE);
 
-  nexthop_add (rib, nexthop);
+  zapi_nexthop2nexthop(znh, nexthop);
+  nexthop_add(rib, nexthop);
 
   return nexthop;
 }
@@ -339,33 +603,54 @@ nexthop_blackhole_add (struct rib *rib)
 /* If force flag is not set, do not modify falgs at all for uninstall
    the route from FIB. */
 static int
-nexthop_active_ipv4 (struct rib *rib, struct nexthop *nexthop, int set,
-		     struct route_node *top)
+nexthop_active_route (struct rib *rib, struct nexthop *nexthop, int set,
+		      struct route_node *top)
 {
-  struct prefix_ipv4 p;
+  struct prefix p;
   struct route_table *table;
   struct route_node *rn;
   struct rib *match;
   struct nexthop *newhop;
+  int afi;
 
-  if (nexthop->type == NEXTHOP_TYPE_IPV4)
-    nexthop->ifindex = 0;
+  memset (&p, 0, sizeof (struct prefix));
+
+  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
+    {
+      nexthop->ifindex = 0;
+      UNSET_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX);
+
+      /* Make lookup prefix. */
+      p.family = AF_INET;
+      p.prefixlen = IPV4_MAX_PREFIXLEN;
+      p.u.prefix4 = nexthop->gate.ipv4;
+      afi = AFI_IP;
+    }
+#ifdef HAVE_IPV6
+  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
+    {
+      nexthop->ifindex = 0;
+      UNSET_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX);
+
+      /* Make lookup prefix. */
+      p.family = AF_INET6;
+      p.prefixlen = IPV6_MAX_PREFIXLEN;
+      p.u.prefix6 = nexthop->gate.ipv6;
+      afi = AFI_IP6;
+    }
+#endif
+  else
+    return 0;
 
   if (set)
     UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_RECURSIVE);
 
-  /* Make lookup prefix. */
-  memset (&p, 0, sizeof (struct prefix_ipv4));
-  p.family = AF_INET;
-  p.prefixlen = IPV4_MAX_PREFIXLEN;
-  p.prefix = nexthop->gate.ipv4;
-
   /* Lookup table.  */
-  table = vrf_table (AFI_IP, SAFI_UNICAST, 0);
+  table = vrf_table (afi, SAFI_UNICAST, 0);
   if (! table)
     return 0;
 
-  rn = route_node_match (table, (struct prefix *) &p);
+  rn = route_node_match (table, &p);
   while (rn)
     {
       route_unlock_node (rn);
@@ -396,8 +681,11 @@ nexthop_active_ipv4 (struct rib *rib, struct nexthop *nexthop, int set,
 	    {
 	      /* Directly point connected route. */
 	      newhop = match->nexthop;
-	      if (newhop && nexthop->type == NEXTHOP_TYPE_IPV4)
-		nexthop->ifindex = newhop->ifindex;
+	      if (newhop)
+		{
+		  SET_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX);
+		  nexthop->ifindex = newhop->ifindex;
+		}
 	      
 	      return 1;
 	    }
@@ -405,19 +693,29 @@ nexthop_active_ipv4 (struct rib *rib, struct nexthop *nexthop, int set,
 	    {
 	      for (newhop = match->nexthop; newhop; newhop = newhop->next)
 		if (CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_FIB)
+		    && ! CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_IGNORE)
 		    && ! CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_RECURSIVE))
 		  {
 		    if (set)
 		      {
 			SET_FLAG (nexthop->flags, NEXTHOP_FLAG_RECURSIVE);
 			nexthop->rtype = newhop->type;
-			if (newhop->type == NEXTHOP_TYPE_IPV4 ||
-			    newhop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
+
+			if (CHECK_FLAG (newhop->type, ZEBRA_NEXTHOP_IPV4))
 			  nexthop->rgate.ipv4 = newhop->gate.ipv4;
-			if (newhop->type == NEXTHOP_TYPE_IFINDEX
-			    || newhop->type == NEXTHOP_TYPE_IFNAME
-			    || newhop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
+#ifdef HAVE_IPV6
+			else if (CHECK_FLAG (newhop->type, ZEBRA_NEXTHOP_IPV6))
+			  nexthop->rgate.ipv6 = newhop->gate.ipv6;
+#endif
+			else
+			  assert (0);
+
+			if (CHECK_FLAG (newhop->type, ZEBRA_NEXTHOP_IFINDEX))
 			  nexthop->rifindex = newhop->ifindex;
+#ifdef HAVE_MPLS
+			if (CHECK_FLAG (newhop->type, ZEBRA_NEXTHOP_MPLS))
+			    nexthop->rmpls = newhop->mpls;
+#endif
 		      }
 		    return 1;
 		  }
@@ -432,127 +730,73 @@ nexthop_active_ipv4 (struct rib *rib, struct nexthop *nexthop, int set,
   return 0;
 }
 
-#ifdef HAVE_IPV6
-/* If force flag is not set, do not modify falgs at all for uninstall
-   the route from FIB. */
-static int
-nexthop_active_ipv6 (struct rib *rib, struct nexthop *nexthop, int set,
-		     struct route_node *top)
+int
+rib_check_drop (struct rib *rib)
+{
+  struct nexthop *nexthop;
+  int flags = 0;
+  int drop = 0;
+
+  for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
+    {
+      if ((CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE) ||
+           CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB)) &&
+           ((CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_RECURSIVE) &&
+	     CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_DROP)) ||
+	     CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_DROP)))
+	{
+	  drop = nexthop->drop;
+	  break;
+	}
+    }
+
+  switch (drop)
+    {
+      case 0:
+	break;
+      case ZEBRA_DROP_NULL:
+      case ZEBRA_DROP_BLACKHOLE:
+        flags = ZEBRA_FLAG_BLACKHOLE;
+        break;
+      case ZEBRA_DROP_REJECT:
+        flags = ZEBRA_FLAG_REJECT;
+        break;
+      default:
+        assert(0);
+    }
+
+  return flags;
+}
+
+struct rib *
+rib_match_route (struct prefix *p)
 {
-  struct prefix_ipv6 p;
   struct route_table *table;
   struct route_node *rn;
   struct rib *match;
   struct nexthop *newhop;
+  int afi;
 
-  if (nexthop->type == NEXTHOP_TYPE_IPV6)
-    nexthop->ifindex = 0;
-
-  if (set)
-    UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_RECURSIVE);
-
-  /* Make lookup prefix. */
-  memset (&p, 0, sizeof (struct prefix_ipv6));
-  p.family = AF_INET6;
-  p.prefixlen = IPV6_MAX_PREFIXLEN;
-  p.prefix = nexthop->gate.ipv6;
+  switch (p->family)
+    {
+      case AF_INET:
+        afi = AFI_IP;
+	p->prefixlen = IPV4_MAX_PREFIXLEN;
+        break;
+      case AF_INET6:
+        afi = AFI_IP6;
+	p->prefixlen = IPV6_MAX_PREFIXLEN;
+        break;
+      default:
+        assert(0);
+    }
 
   /* Lookup table.  */
-  table = vrf_table (AFI_IP6, SAFI_UNICAST, 0);
-  if (! table)
-    return 0;
-
-  rn = route_node_match (table, (struct prefix *) &p);
-  while (rn)
-    {
-      route_unlock_node (rn);
-      
-      /* If lookup self prefix return immidiately. */
-      if (rn == top)
-	return 0;
-
-      /* Pick up selected route. */
-      for (match = rn->info; match; match = match->next)
-	if (CHECK_FLAG (match->flags, ZEBRA_FLAG_SELECTED))
-	  break;
-
-      /* If there is no selected route or matched route is EGP, go up
-         tree. */
-      if (! match
-	  || match->type == ZEBRA_ROUTE_BGP)
-	{
-	  do {
-	    rn = rn->parent;
-	  } while (rn && rn->info == NULL);
-	  if (rn)
-	    route_lock_node (rn);
-	}
-      else
-	{
-	  if (match->type == ZEBRA_ROUTE_CONNECT)
-	    {
-	      /* Directly point connected route. */
-	      newhop = match->nexthop;
-
-	      if (newhop && nexthop->type == NEXTHOP_TYPE_IPV6)
-		nexthop->ifindex = newhop->ifindex;
-	      
-	      return 1;
-	    }
-	  else if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_INTERNAL))
-	    {
-	      for (newhop = match->nexthop; newhop; newhop = newhop->next)
-		if (CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_FIB)
-		    && ! CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_RECURSIVE))
-		  {
-		    if (set)
-		      {
-			SET_FLAG (nexthop->flags, NEXTHOP_FLAG_RECURSIVE);
-			nexthop->rtype = newhop->type;
-			if (newhop->type == NEXTHOP_TYPE_IPV6
-			    || newhop->type == NEXTHOP_TYPE_IPV6_IFINDEX
-			    || newhop->type == NEXTHOP_TYPE_IPV6_IFNAME)
-			  nexthop->rgate.ipv6 = newhop->gate.ipv6;
-			if (newhop->type == NEXTHOP_TYPE_IFINDEX
-			    || newhop->type == NEXTHOP_TYPE_IFNAME
-			    || newhop->type == NEXTHOP_TYPE_IPV6_IFINDEX
-			    || newhop->type == NEXTHOP_TYPE_IPV6_IFNAME)
-			  nexthop->rifindex = newhop->ifindex;
-		      }
-		    return 1;
-		  }
-	      return 0;
-	    }
-	  else
-	    {
-	      return 0;
-	    }
-	}
-    }
-  return 0;
-}
-#endif /* HAVE_IPV6 */
-
-struct rib *
-rib_match_ipv4 (struct in_addr addr)
-{
-  struct prefix_ipv4 p;
-  struct route_table *table;
-  struct route_node *rn;
-  struct rib *match;
-  struct nexthop *newhop;
-
-  /* Lookup table.  */
-  table = vrf_table (AFI_IP, SAFI_UNICAST, 0);
+  table = vrf_table (afi, SAFI_UNICAST, 0);
   if (! table)
     return 0;
 
-  memset (&p, 0, sizeof (struct prefix_ipv4));
-  p.family = AF_INET;
-  p.prefixlen = IPV4_MAX_PREFIXLEN;
-  p.prefix = addr;
-
-  rn = route_node_match (table, (struct prefix *) &p);
+  rn = route_node_match (table, p);
 
   while (rn)
     {
@@ -582,7 +826,8 @@ rib_match_ipv4 (struct in_addr addr)
 	  else
 	    {
 	      for (newhop = match->nexthop; newhop; newhop = newhop->next)
-		if (CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_FIB))
+		if (CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_FIB)
+		    && ! CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_IGNORE))
 		  return match;
 	      return NULL;
 	    }
@@ -592,19 +837,32 @@ rib_match_ipv4 (struct in_addr addr)
 }
 
 struct rib *
-rib_lookup_ipv4 (struct prefix_ipv4 *p)
+rib_lookup_route (struct prefix *p)
 {
   struct route_table *table;
   struct route_node *rn;
   struct rib *match;
   struct nexthop *nexthop;
+  int afi;
+
+  switch (p->family)
+    {
+      case AF_INET:
+        afi = AFI_IP;
+        break;
+      case AF_INET6:
+        afi = AFI_IP6;
+        break;
+      default:
+        assert(0);
+    }
 
   /* Lookup table.  */
-  table = vrf_table (AFI_IP, SAFI_UNICAST, 0);
+  table = vrf_table (afi, SAFI_UNICAST, 0);
   if (! table)
     return 0;
 
-  rn = route_node_lookup (table, (struct prefix *) p);
+  rn = route_node_lookup (table, p);
 
   /* No route for this prefix. */
   if (! rn)
@@ -625,15 +883,16 @@ rib_lookup_ipv4 (struct prefix_ipv4 *p)
     return match;
   
   for (nexthop = match->nexthop; nexthop; nexthop = nexthop->next)
-    if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))
+    if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB)
+	&& ! CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_IGNORE))
       return match;
 
   return NULL;
 }
 
 /*
- * This clone function, unlike its original rib_lookup_ipv4(), checks
- * if specified IPv4 route record (prefix/mask -> gate) exists in
+ * This clone function, unlike its original rib_lookup_route(), checks
+ * if specified route record (prefix/mask -> gate) exists in
  * the whole RIB and has ZEBRA_FLAG_SELECTED set.
  *
  * Return values:
@@ -644,20 +903,33 @@ rib_lookup_ipv4 (struct prefix_ipv4 *p)
  * 3: no matches found
  */
 int
-rib_lookup_ipv4_route (struct prefix_ipv4 *p, union sockunion * qgate)
+rib_lookup_route_nexthop (struct prefix *p, struct zapi_nexthop *znh)
 {
   struct route_table *table;
   struct route_node *rn;
   struct rib *match;
   struct nexthop *nexthop;
+  int afi;
+
+  switch (p->family)
+    {
+      case AF_INET:
+        afi = AFI_IP;
+        break;
+      case AF_INET6:
+        afi = AFI_IP6;
+        break;
+      default:
+	assert(0);
+    }
 
   /* Lookup table.  */
-  table = vrf_table (AFI_IP, SAFI_UNICAST, 0);
+  table = vrf_table (afi, SAFI_UNICAST, 0);
   if (! table)
     return ZEBRA_RIB_LOOKUP_ERROR;
 
   /* Scan the RIB table for exactly matching RIB entry. */
-  rn = route_node_lookup (table, (struct prefix *) p);
+  rn = route_node_lookup (table, p);
 
   /* No route for this prefix. */
   if (! rn)
@@ -687,17 +959,17 @@ rib_lookup_ipv4_route (struct prefix_ipv4 *p, union sockunion * qgate)
     if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))
     {
       /* We are happy with either direct or recursive hexthop */
-      if (nexthop->gate.ipv4.s_addr == qgate->sin.sin_addr.s_addr ||
-          nexthop->rgate.ipv4.s_addr == qgate->sin.sin_addr.s_addr)
+      if (zapi_nexthop_match_nexthop(znh, nexthop,
+	ZEBRA_NEXTHOP_IPV4|ZEBRA_NEXTHOP_IPV6))
         return ZEBRA_RIB_FOUND_EXACT;
       else
       {
         if (IS_ZEBRA_DEBUG_RIB)
         {
           char gate_buf[INET_ADDRSTRLEN], rgate_buf[INET_ADDRSTRLEN], qgate_buf[INET_ADDRSTRLEN];
-          inet_ntop (AF_INET, &nexthop->gate.ipv4.s_addr, gate_buf, INET_ADDRSTRLEN);
-          inet_ntop (AF_INET, &nexthop->rgate.ipv4.s_addr, rgate_buf, INET_ADDRSTRLEN);
-          inet_ntop (AF_INET, &qgate->sin.sin_addr.s_addr, qgate_buf, INET_ADDRSTRLEN);
+          inet_ntop (p->family, &nexthop->gate, gate_buf, INET_ADDRSTRLEN);
+          inet_ntop (p->family, &nexthop->rgate, rgate_buf, INET_ADDRSTRLEN);
+          inet_ntop (p->family, &znh->gw, qgate_buf, INET_ADDRSTRLEN);
           zlog_debug ("%s: qgate == %s, gate == %s, rgate == %s", __func__, qgate_buf, gate_buf, rgate_buf);
         }
         return ZEBRA_RIB_FOUND_NOGATE;
@@ -707,66 +979,6 @@ rib_lookup_ipv4_route (struct prefix_ipv4 *p, union sockunion * qgate)
   return ZEBRA_RIB_NOTFOUND;
 }
 
-#ifdef HAVE_IPV6
-struct rib *
-rib_match_ipv6 (struct in6_addr *addr)
-{
-  struct prefix_ipv6 p;
-  struct route_table *table;
-  struct route_node *rn;
-  struct rib *match;
-  struct nexthop *newhop;
-
-  /* Lookup table.  */
-  table = vrf_table (AFI_IP6, SAFI_UNICAST, 0);
-  if (! table)
-    return 0;
-
-  memset (&p, 0, sizeof (struct prefix_ipv6));
-  p.family = AF_INET6;
-  p.prefixlen = IPV6_MAX_PREFIXLEN;
-  IPV6_ADDR_COPY (&p.prefix, addr);
-
-  rn = route_node_match (table, (struct prefix *) &p);
-
-  while (rn)
-    {
-      route_unlock_node (rn);
-      
-      /* Pick up selected route. */
-      for (match = rn->info; match; match = match->next)
-	if (CHECK_FLAG (match->flags, ZEBRA_FLAG_SELECTED))
-	  break;
-
-      /* If there is no selected route or matched route is EGP, go up
-         tree. */
-      if (! match 
-	  || match->type == ZEBRA_ROUTE_BGP)
-	{
-	  do {
-	    rn = rn->parent;
-	  } while (rn && rn->info == NULL);
-	  if (rn)
-	    route_lock_node (rn);
-	}
-      else
-	{
-	  if (match->type == ZEBRA_ROUTE_CONNECT)
-	    /* Directly point connected route. */
-	    return match;
-	  else
-	    {
-	      for (newhop = match->nexthop; newhop; newhop = newhop->next)
-		if (CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_FIB))
-		  return match;
-	      return NULL;
-	    }
-	}
-    }
-  return NULL;
-}
-#endif /* HAVE_IPV6 */
-
 #define RIB_SYSTEM_ROUTE(R) \
         ((R)->type == ZEBRA_ROUTE_KERNEL || (R)->type == ZEBRA_ROUTE_CONNECT)
 
@@ -789,76 +1001,105 @@ nexthop_active_check (struct route_node *rn, struct rib *rib,
   extern char *proto_rm[AFI_MAX][ZEBRA_ROUTE_MAX+1];
   struct route_map *rmap;
   int family;
+  int try = 0;
+  int match = 0;
 
   family = 0;
-  switch (nexthop->type)
+  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
     {
-    case NEXTHOP_TYPE_IFINDEX:
-      ifp = if_lookup_by_index (nexthop->ifindex);
-      if (ifp && if_is_operative(ifp))
-	SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
-      else
-	UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
-      break;
-    case NEXTHOP_TYPE_IPV6_IFNAME:
-      family = AFI_IP6;
-    case NEXTHOP_TYPE_IFNAME:
+      try++;
       ifp = if_lookup_by_name (nexthop->ifname);
       if (ifp && if_is_operative(ifp))
 	{
 	  if (set)
-	    nexthop->ifindex = ifp->ifindex;
-	  SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+	    {
+	      nexthop->ifindex = ifp->ifindex;
+	      SET_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX);
+	      UNSET_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME);
+	    }
+          match++;
 	}
       else
 	{
 	  if (set)
-	    nexthop->ifindex = 0;
-	  UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+	    {
+	      nexthop->ifindex = 0;
+	      UNSET_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX);
+	      SET_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME);
+	    }
 	}
-      break;
-    case NEXTHOP_TYPE_IPV4:
-    case NEXTHOP_TYPE_IPV4_IFINDEX:
+    }
+  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
+    {
+      try++;
+      ifp = if_lookup_by_index (nexthop->ifindex);
+      if (ifp && if_is_up (ifp)) {
+        match++;
+      }
+    }
+
+#ifdef HAVE_MPLS
+  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_MPLS))
+    {
+      try++;
+      if (mpls_out_segment_find(nexthop->mpls))
+	match++;
+    }
+#endif
+
+  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
+    {
       family = AFI_IP;
-      if (nexthop_active_ipv4 (rib, nexthop, set, rn))
-	SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
-      else
-	UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
-      break;
+      try++;
+      if (nexthop_active_route (rib, nexthop, set, rn)) {
+        match++;
+      }
+    }
 #ifdef HAVE_IPV6
-    case NEXTHOP_TYPE_IPV6:
-      family = AFI_IP6;
-      if (nexthop_active_ipv6 (rib, nexthop, set, rn))
-	SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
-      else
-	UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
-      break;
-    case NEXTHOP_TYPE_IPV6_IFINDEX:
+  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
+    {
       family = AFI_IP6;
-      if (IN6_IS_ADDR_LINKLOCAL (&nexthop->gate.ipv6))
-	{
-	  ifp = if_lookup_by_index (nexthop->ifindex);
-	  if (ifp && if_is_operative(ifp))
-	    SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
-	  else
-	    UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
-	}
+      try++;
+      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
+        {
+          if (IN6_IS_ADDR_LINKLOCAL (&nexthop->gate.ipv6))
+            {
+              ifp = if_lookup_by_index (nexthop->ifindex);
+              if (ifp && if_is_operative(ifp)) {
+                match++;
+              }
+            }
+          else
+            {
+              if (nexthop_active_route (rib, nexthop, set, rn)) {
+                match++;
+              }
+            }
+        }
       else
-	{
-	  if (nexthop_active_ipv6 (rib, nexthop, set, rn))
-	    SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
-	  else
-	    UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
-	}
-      break;
+        {
+          if (nexthop_active_route (rib, nexthop, set, rn)) {
+            match++;
+          }
+        }
+    }
 #endif /* HAVE_IPV6 */
-    case NEXTHOP_TYPE_BLACKHOLE:
-      SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
-      break;
-    default:
-      break;
+  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_DROP))
+    {
+      try++;
+      match++;
     }
-  if (! CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE))
+
+  try++;
+  if (!CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_IGNORE))
+    match++;
+
+  if (try && (try == match))
+    SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+  else
+    UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+
+  if (!CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE))
     return 0;
 
   if (RIB_SYSTEM_ROUTE(rib) ||
@@ -898,15 +1139,27 @@ nexthop_active_update (struct route_node *rn, struct rib *rib, int set)
 
   rib->nexthop_active_num = 0;
   UNSET_FLAG (rib->flags, ZEBRA_FLAG_CHANGED);
+  UNSET_FLAG (rib->flags, ZEBRA_FLAG_BLACKHOLE|ZEBRA_FLAG_REJECT);
 
   for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
   {
+    /*
+     * we want to process all nexthops even IGNORED ones incase
+     * a newly ignored nexthop was active, that should trigger
+     * a route change.  So nexthop_active_check is responsible
+     * for checking IGNORED and handling accordingly
+     */
     prev_active = CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
     if ((new_active = nexthop_active_check (rn, rib, nexthop, set)))
       rib->nexthop_active_num++;
     if (prev_active != new_active)
       SET_FLAG (rib->flags, ZEBRA_FLAG_CHANGED);
   }
+#ifdef HAVE_MPLS
+  if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_CHANGED_MPLS))
+    SET_FLAG (rib->flags, ZEBRA_FLAG_CHANGED);
+#endif
+  SET_FLAG (rib->flags, rib_check_drop(rib));
   return rib->nexthop_active_num;
 }
 
@@ -939,7 +1192,7 @@ rib_install_kernel (struct route_node *rn, struct rib *rib)
 }
 
 /* Uninstall the route from kernel. */
-static int
+int
 rib_uninstall_kernel (struct route_node *rn, struct rib *rib)
 {
   int ret = 0;
@@ -1096,7 +1349,11 @@ rib_process (struct route_node *rn)
                      __func__, buf, rn->p.prefixlen, select, fib);
       if (CHECK_FLAG (select->flags, ZEBRA_FLAG_CHANGED))
         {
-          redistribute_delete (&rn->p, select);
+#ifdef HAVE_MPLS
+	  if (!CHECK_FLAG (select->flags, ZEBRA_FLAG_CHANGED_MPLS))
+#endif
+	    redistribute_delete (&rn->p, select);
+
           if (! RIB_SYSTEM_ROUTE (select))
             rib_uninstall_kernel (rn, select);
 
@@ -1105,7 +1362,11 @@ rib_process (struct route_node *rn)
   
           if (! RIB_SYSTEM_ROUTE (select))
             rib_install_kernel (rn, select);
-          redistribute_add (&rn->p, select);
+
+#ifdef HAVE_MPLS
+	  if (!CHECK_FLAG (select->flags, ZEBRA_FLAG_CHANGED_MPLS))
+#endif
+	    redistribute_add (&rn->p, select);
         }
       else if (! RIB_SYSTEM_ROUTE (select))
         {
@@ -1125,6 +1386,9 @@ rib_process (struct route_node *rn)
           if (! installed) 
             rib_install_kernel (rn, select);
         }
+#ifdef HAVE_MPLS
+      UNSET_FLAG (select->flags, ZEBRA_FLAG_CHANGED_MPLS);
+#endif
       goto end;
     }
 
@@ -1161,7 +1425,13 @@ rib_process (struct route_node *rn)
       if (! RIB_SYSTEM_ROUTE (select))
         rib_install_kernel (rn, select);
       SET_FLAG (select->flags, ZEBRA_FLAG_SELECTED);
-      redistribute_add (&rn->p, select);
+#ifdef HAVE_MPLS
+      if (!CHECK_FLAG (select->flags, ZEBRA_FLAG_CHANGED_MPLS))
+#endif
+        redistribute_add (&rn->p, select);
+#ifdef HAVE_MPLS
+      UNSET_FLAG (select->flags, ZEBRA_FLAG_CHANGED_MPLS);
+#endif
     }
 
   /* FIB route was removed, should be deleted */
@@ -1268,7 +1538,7 @@ void rib_meta_queue_add (struct meta_queue *mq, struct route_node *rn)
 }
 
 /* Add route_node to work queue and schedule processing */
-static void
+void
 rib_queue_add (struct zebra_t *zebra, struct route_node *rn)
 {
   char buf[INET_ADDRSTRLEN];
@@ -1519,24 +1789,97 @@ rib_delnode (struct route_node *rn, struct rib *rib)
 }
 
 int
-rib_add_ipv4 (int type, int flags, struct prefix_ipv4 *p, 
-	      struct in_addr *gate, struct in_addr *src,
-	      unsigned int ifindex, u_int32_t vrf_id,
-	      u_int32_t metric, u_char distance)
+rib_find_nexthop2 (int owner, struct rib *rib_in, struct nexthop *nh_in,
+  struct rib **rib_out, struct nexthop **nh_out)
+{
+  struct nexthop *nh = NULL;
+  struct rib *rib = NULL;
+
+  for (rib = rib_in; rib; rib = rib->next)
+    {
+      if ((owner >= 0) && (rib->type != owner))
+        continue;
+
+      for (nh = rib->nexthop; nh; nh = nh->next)
+        {
+          if (nexthop_match(nh_in, nh,
+	      (ZEBRA_NEXTHOP_ALL & (~ZEBRA_NEXTHOP_MPLS))))
+            {
+	      *rib_out = rib;
+	      *nh_out = nh;
+	      return 0;
+            }
+        }
+    }
+  return 1;
+}
+
+int
+rib_find_nexthop (int owner, struct prefix *p_in, struct nexthop *nh_in,
+  struct route_node **rn_out, struct rib **rib_out, struct nexthop **nh_out)
+{
+  struct route_table *table = NULL;
+  struct route_node *rn = NULL;
+
+  *rn_out = NULL;
+  *rib_out = NULL;
+  *nh_out = NULL;
+
+  switch (p_in->family)
+    {
+      case AF_INET:
+        table = vrf_table (AFI_IP, SAFI_UNICAST, 0);
+        break;
+      case AF_INET6:
+        table = vrf_table (AFI_IP6, SAFI_UNICAST, 0);
+        break;
+      default:
+        assert(0);
+    }
+
+  if ((!table) || (!(rn = route_node_lookup (table, p_in))))
+    return 1;
+ 
+  if (!rib_find_nexthop2(owner, rn->info, nh_in, rib_out, nh_out))
+    {
+      *rn_out = rn;
+      return 0;
+    }
+  route_unlock_node (rn);
+  return 1;
+}
+
+int
+rib_add_route (int type, int flags, struct prefix *p, 
+	       struct zapi_nexthop *nh, u_int32_t vrf_id,
+	       u_int32_t metric, u_char distance)
 {
   struct rib *rib;
   struct rib *same = NULL;
   struct route_table *table;
   struct route_node *rn;
   struct nexthop *nexthop;
+  int afi;
+
+  switch (p->family)
+    {
+      case AF_INET:
+        afi = AFI_IP;
+        break;
+      case AF_INET6:
+        afi = AFI_IP6;
+        break;
+      default:
+        assert(0);
+    }
 
   /* Lookup table.  */
-  table = vrf_table (AFI_IP, SAFI_UNICAST, 0);
+  table = vrf_table (afi, SAFI_UNICAST, 0);
   if (! table)
     return 0;
 
   /* Make it sure prefixlen is applied to the prefix. */
-  apply_mask_ipv4 (p);
+  apply_mask (p);
 
   /* Set default distance by route type. */
   if (distance == 0)
@@ -1548,8 +1891,16 @@ rib_add_ipv4 (int type, int flags, struct prefix_ipv4 *p,
 	distance = 200;
     }
 
+#ifdef HAVE_IPV6
+  /* Filter bogus route. */
+  if (afi == AFI_IP6 &&
+      rib_bogus_ipv6 (type, (struct prefix_ipv6*)p, &nh->gw.ipv6,
+                      nh->intf.index, 0))
+    return 0;
+#endif
+
   /* Lookup route node.*/
-  rn = route_node_get (table, (struct prefix *) p);
+  rn = route_node_get (table, p);
 
   /* If same type of route are installed, treat it as a implicit
      withdraw. */
@@ -1567,8 +1918,8 @@ rib_add_ipv4 (int type, int flags, struct prefix_ipv4 *p,
         }
       /* Duplicate connected route comes in. */
       else if ((nexthop = rib->nexthop) &&
-	       nexthop->type == NEXTHOP_TYPE_IFINDEX &&
-	       nexthop->ifindex == ifindex &&
+	       zapi_nexthop_match_nexthop(nh, nexthop,
+               ZEBRA_NEXTHOP_IPV4|ZEBRA_NEXTHOP_IPV6) &&
 	       !CHECK_FLAG (rib->status, RIB_ENTRY_REMOVED))
 	{
 	  rib->refcnt++;
@@ -1587,21 +1938,17 @@ rib_add_ipv4 (int type, int flags, struct prefix_ipv4 *p,
   rib->uptime = time (NULL);
 
   /* Nexthop settings. */
-  if (gate)
-    {
-      if (ifindex)
-	nexthop_ipv4_ifindex_add (rib, gate, src, ifindex);
-      else
-	nexthop_ipv4_add (rib, gate, src);
-    }
-  else
-    nexthop_ifindex_add (rib, ifindex);
+  nexthop_zapi_nexthop_add(rib, nh);
 
   /* If this route is kernel route, set FIB flag to the route. */
   if (type == ZEBRA_ROUTE_KERNEL || type == ZEBRA_ROUTE_CONNECT)
     for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
-      SET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
-
+      {
+        if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_IGNORE))
+	  continue;
+        SET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
+      }
+
   /* Link new rib to node.*/
   if (IS_ZEBRA_DEBUG_RIB)
     zlog_debug ("%s: calling rib_addnode (%p, %p)", __func__, rn, rib);
@@ -1676,7 +2023,7 @@ void rib_dump (const char * func, const struct prefix_ipv4 * p, const struct rib
 }
 
 /* This is an exported helper to rtm_read() to dump the strange
- * RIB entry found by rib_lookup_ipv4_route()
+ * RIB entry found by rib_lookup_route_nexthop()
  */
 
 void rib_lookup_and_dump (struct prefix_ipv4 * p)
@@ -1777,716 +2124,187 @@ void rib_lookup_and_pushup (struct prefix_ipv4 * p)
 }
 
 int
-rib_add_ipv4_multipath (struct prefix_ipv4 *p, struct rib *rib)
+rib_add_multipath (struct prefix *p, struct rib *rib)
 {
   struct route_table *table;
   struct route_node *rn;
   struct rib *same;
   struct nexthop *nexthop;
-  
-  /* Lookup table.  */
-  table = vrf_table (AFI_IP, SAFI_UNICAST, 0);
-  if (! table)
-    return 0;
-  /* Make it sure prefixlen is applied to the prefix. */
-  apply_mask_ipv4 (p);
+  int afi;
 
-  /* Set default distance by route type. */
-  if (rib->distance == 0)
-    {
-      rib->distance = route_info[rib->type].distance;
-
-      /* iBGP distance is 200. */
-      if (rib->type == ZEBRA_ROUTE_BGP 
-	  && CHECK_FLAG (rib->flags, ZEBRA_FLAG_IBGP))
-	rib->distance = 200;
-    }
-
-  /* Lookup route node.*/
-  rn = route_node_get (table, (struct prefix *) p);
-
-  /* If same type of route are installed, treat it as a implicit
-     withdraw. */
-  for (same = rn->info; same; same = same->next)
+  switch (p->family)
     {
-      if (CHECK_FLAG (same->status, RIB_ENTRY_REMOVED))
-        continue;
-      
-      if (same->type == rib->type && same->table == rib->table
-	  && same->type != ZEBRA_ROUTE_CONNECT)
+      case AF_INET:
+        afi = AFI_IP;
         break;
-    }
-  
-  /* If this route is kernel route, set FIB flag to the route. */
-  if (rib->type == ZEBRA_ROUTE_KERNEL || rib->type == ZEBRA_ROUTE_CONNECT)
-    for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
-      SET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
-
-  /* Link new rib to node.*/
-  rib_addnode (rn, rib);
-  if (IS_ZEBRA_DEBUG_RIB)
-  {
-    zlog_debug ("%s: called rib_addnode (%p, %p) on new RIB entry",
-      __func__, rn, rib);
-    rib_dump (__func__, p, rib);
-  }
-
-  /* Free implicit route.*/
-  if (same)
-  {
-    if (IS_ZEBRA_DEBUG_RIB)
-    {
-      zlog_debug ("%s: calling rib_delnode (%p, %p) on existing RIB entry",
-        __func__, rn, same);
-      rib_dump (__func__, p, same);
-    }
-    rib_delnode (rn, same);
-  }
-  
-  route_unlock_node (rn);
-  return 0;
-}
-
-/* XXX factor with rib_delete_ipv6 */
-int
-rib_delete_ipv4 (int type, int flags, struct prefix_ipv4 *p,
-		 struct in_addr *gate, unsigned int ifindex, u_int32_t vrf_id)
-{
-  struct route_table *table;
-  struct route_node *rn;
-  struct rib *rib;
-  struct rib *fib = NULL;
-  struct rib *same = NULL;
-  struct nexthop *nexthop;
-  char buf1[BUFSIZ];
-  char buf2[BUFSIZ];
-
-  /* Lookup table.  */
-  table = vrf_table (AFI_IP, SAFI_UNICAST, 0);
-  if (! table)
-    return 0;
-
-  /* Apply mask. */
-  apply_mask_ipv4 (p);
-
-  if (IS_ZEBRA_DEBUG_KERNEL && gate)
-    zlog_debug ("rib_delete_ipv4(): route delete %s/%d via %s ifindex %d",
-		       inet_ntop (AF_INET, &p->prefix, buf1, BUFSIZ),
-		       p->prefixlen, 
-		       inet_ntoa (*gate), 
-		       ifindex);
-
-  /* Lookup route node. */
-  rn = route_node_lookup (table, (struct prefix *) p);
-  if (! rn)
-    {
-      if (IS_ZEBRA_DEBUG_KERNEL)
-	{
-	  if (gate)
-	    zlog_debug ("route %s/%d via %s ifindex %d doesn't exist in rib",
-		       inet_ntop (AF_INET, &p->prefix, buf1, BUFSIZ),
-		       p->prefixlen,
-		       inet_ntop (AF_INET, gate, buf2, BUFSIZ),
-		       ifindex);
-	  else
-	    zlog_debug ("route %s/%d ifindex %d doesn't exist in rib",
-		       inet_ntop (AF_INET, &p->prefix, buf1, BUFSIZ),
-		       p->prefixlen,
-		       ifindex);
-	}
-      return ZEBRA_ERR_RTNOEXIST;
-    }
-
-  /* Lookup same type route. */
-  for (rib = rn->info; rib; rib = rib->next)
-    {
-      if (CHECK_FLAG (rib->status, RIB_ENTRY_REMOVED))
-        continue;
-
-      if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_SELECTED))
-	fib = rib;
-
-      if (rib->type != type)
-	continue;
-      if (rib->type == ZEBRA_ROUTE_CONNECT && (nexthop = rib->nexthop) &&
-	  nexthop->type == NEXTHOP_TYPE_IFINDEX && nexthop->ifindex == ifindex)
-	{
-	  if (rib->refcnt)
-	    {
-	      rib->refcnt--;
-	      route_unlock_node (rn);
-	      route_unlock_node (rn);
-	      return 0;
-	    }
-	  same = rib;
-	  break;
-	}
-      /* Make sure that the route found has the same gateway. */
-      else if (gate == NULL ||
-	       ((nexthop = rib->nexthop) &&
-	        (IPV4_ADDR_SAME (&nexthop->gate.ipv4, gate) ||
-		 IPV4_ADDR_SAME (&nexthop->rgate.ipv4, gate)))) 
-        {
-	  same = rib;
-	  break;
-	}
-    }
-
-  /* If same type of route can't be found and this message is from
-     kernel. */
-  if (! same)
-    {
-      if (fib && type == ZEBRA_ROUTE_KERNEL)
-	{
-	  /* Unset flags. */
-	  for (nexthop = fib->nexthop; nexthop; nexthop = nexthop->next)
-	    UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
-
-	  UNSET_FLAG (fib->flags, ZEBRA_FLAG_SELECTED);
-	}
-      else
-	{
-	  if (IS_ZEBRA_DEBUG_KERNEL)
-	    {
-	      if (gate)
-		zlog_debug ("route %s/%d via %s ifindex %d type %d doesn't exist in rib",
-			   inet_ntop (AF_INET, &p->prefix, buf1, BUFSIZ),
-			   p->prefixlen,
-			   inet_ntop (AF_INET, gate, buf2, BUFSIZ),
-			   ifindex,
-			   type);
-	      else
-		zlog_debug ("route %s/%d ifindex %d type %d doesn't exist in rib",
-			   inet_ntop (AF_INET, &p->prefix, buf1, BUFSIZ),
-			   p->prefixlen,
-			   ifindex,
-			   type);
-	    }
-	  route_unlock_node (rn);
-	  return ZEBRA_ERR_RTNOEXIST;
-	}
-    }
-  
-  if (same)
-    rib_delnode (rn, same);
-  
-  route_unlock_node (rn);
-  return 0;
-}
-
-/* Install static route into rib. */
-static void
-static_install_ipv4 (struct prefix *p, struct static_ipv4 *si)
-{
-  struct rib *rib;
-  struct route_node *rn;
-  struct route_table *table;
-
-  /* Lookup table.  */
-  table = vrf_table (AFI_IP, SAFI_UNICAST, 0);
-  if (! table)
-    return;
-
-  /* Lookup existing route */
-  rn = route_node_get (table, p);
-  for (rib = rn->info; rib; rib = rib->next)
-    {
-       if (CHECK_FLAG (rib->status, RIB_ENTRY_REMOVED))
-         continue;
-        
-       if (rib->type == ZEBRA_ROUTE_STATIC && rib->distance == si->distance)
-         break;
-    }
-
-  if (rib)
-    {
-      /* Same distance static route is there.  Update it with new
-         nexthop. */
-      route_unlock_node (rn);
-      switch (si->type)
-        {
-          case STATIC_IPV4_GATEWAY:
-            nexthop_ipv4_add (rib, &si->gate.ipv4, NULL);
-            break;
-          case STATIC_IPV4_IFNAME:
-            nexthop_ifname_add (rib, si->gate.ifname);
-            break;
-          case STATIC_IPV4_BLACKHOLE:
-            nexthop_blackhole_add (rib);
-            break;
-        }
-      rib_queue_add (&zebrad, rn);
-    }
-  else
-    {
-      /* This is new static route. */
-      rib = XCALLOC (MTYPE_RIB, sizeof (struct rib));
-      
-      rib->type = ZEBRA_ROUTE_STATIC;
-      rib->distance = si->distance;
-      rib->metric = 0;
-      rib->nexthop_num = 0;
-
-      switch (si->type)
-        {
-          case STATIC_IPV4_GATEWAY:
-            nexthop_ipv4_add (rib, &si->gate.ipv4, NULL);
-            break;
-          case STATIC_IPV4_IFNAME:
-            nexthop_ifname_add (rib, si->gate.ifname);
-            break;
-          case STATIC_IPV4_BLACKHOLE:
-            nexthop_blackhole_add (rib);
-            break;
-        }
-
-      /* Save the flags of this static routes (reject, blackhole) */
-      rib->flags = si->flags;
-
-      /* Link this rib to the tree. */
-      rib_addnode (rn, rib);
-    }
-}
-
-static int
-static_ipv4_nexthop_same (struct nexthop *nexthop, struct static_ipv4 *si)
-{
-  if (nexthop->type == NEXTHOP_TYPE_IPV4
-      && si->type == STATIC_IPV4_GATEWAY
-      && IPV4_ADDR_SAME (&nexthop->gate.ipv4, &si->gate.ipv4))
-    return 1;
-  if (nexthop->type == NEXTHOP_TYPE_IFNAME
-      && si->type == STATIC_IPV4_IFNAME
-      && strcmp (nexthop->ifname, si->gate.ifname) == 0)
-    return 1;
-  if (nexthop->type == NEXTHOP_TYPE_BLACKHOLE
-      && si->type == STATIC_IPV4_BLACKHOLE)
-    return 1;
-  return 0;
-}
-
-/* Uninstall static route from RIB. */
-static void
-static_uninstall_ipv4 (struct prefix *p, struct static_ipv4 *si)
-{
-  struct route_node *rn;
-  struct rib *rib;
-  struct nexthop *nexthop;
-  struct route_table *table;
-
-  /* Lookup table.  */
-  table = vrf_table (AFI_IP, SAFI_UNICAST, 0);
-  if (! table)
-    return;
-  
-  /* Lookup existing route with type and distance. */
-  rn = route_node_lookup (table, p);
-  if (! rn)
-    return;
-
-  for (rib = rn->info; rib; rib = rib->next)
-    {
-      if (CHECK_FLAG (rib->status, RIB_ENTRY_REMOVED))
-        continue;
-
-      if (rib->type == ZEBRA_ROUTE_STATIC && rib->distance == si->distance)
+      case AF_INET6:
+        afi = AFI_IP6;
         break;
+      default:
+        assert(0);
     }
 
-  if (! rib)
-    {
-      route_unlock_node (rn);
-      return;
-    }
-
-  /* Lookup nexthop. */
-  for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
-    if (static_ipv4_nexthop_same (nexthop, si))
-      break;
-
-  /* Can't find nexthop. */
-  if (! nexthop)
-    {
-      route_unlock_node (rn);
-      return;
-    }
-  
-  /* Check nexthop. */
-  if (rib->nexthop_num == 1)
-    rib_delnode (rn, rib);
-  else
-    {
-      if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))
-        rib_uninstall (rn, rib);
-      nexthop_delete (rib, nexthop);
-      nexthop_free (nexthop);
-      rib_queue_add (&zebrad, rn);
-    }
-  /* Unlock node. */
-  route_unlock_node (rn);
-}
-
-/* Add static route into static route configuration. */
-int
-static_add_ipv4 (struct prefix *p, struct in_addr *gate, const char *ifname,
-		 u_char flags, u_char distance, u_int32_t vrf_id)
-{
-  u_char type = 0;
-  struct route_node *rn;
-  struct static_ipv4 *si;
-  struct static_ipv4 *pp;
-  struct static_ipv4 *cp;
-  struct static_ipv4 *update = NULL;
-  struct route_table *stable;
-
-  /* Lookup table.  */
-  stable = vrf_static_table (AFI_IP, SAFI_UNICAST, vrf_id);
-  if (! stable)
-    return -1;
-  
-  /* Lookup static route prefix. */
-  rn = route_node_get (stable, p);
-
-  /* Make flags. */
-  if (gate)
-    type = STATIC_IPV4_GATEWAY;
-  else if (ifname)
-    type = STATIC_IPV4_IFNAME;
-  else
-    type = STATIC_IPV4_BLACKHOLE;
-
-  /* Do nothing if there is a same static route.  */
-  for (si = rn->info; si; si = si->next)
-    {
-      if (type == si->type
-	  && (! gate || IPV4_ADDR_SAME (gate, &si->gate.ipv4))
-	  && (! ifname || strcmp (ifname, si->gate.ifname) == 0))
-	{
-	  if (distance == si->distance)
-	    {
-	      route_unlock_node (rn);
-	      return 0;
-	    }
-	  else
-	    update = si;
-	}
-    }
-
-  /* Distance changed.  */
-  if (update)
-    static_delete_ipv4 (p, gate, ifname, update->distance, vrf_id);
-
-  /* Make new static route structure. */
-  si = XMALLOC (MTYPE_STATIC_IPV4, sizeof (struct static_ipv4));
-  memset (si, 0, sizeof (struct static_ipv4));
-
-  si->type = type;
-  si->distance = distance;
-  si->flags = flags;
-
-  if (gate)
-    si->gate.ipv4 = *gate;
-  if (ifname)
-    si->gate.ifname = XSTRDUP (0, ifname);
-
-  /* Add new static route information to the tree with sort by
-     distance value and gateway address. */
-  for (pp = NULL, cp = rn->info; cp; pp = cp, cp = cp->next)
-    {
-      if (si->distance < cp->distance)
-	break;
-      if (si->distance > cp->distance)
-	continue;
-      if (si->type == STATIC_IPV4_GATEWAY && cp->type == STATIC_IPV4_GATEWAY)
-	{
-	  if (ntohl (si->gate.ipv4.s_addr) < ntohl (cp->gate.ipv4.s_addr))
-	    break;
-	  if (ntohl (si->gate.ipv4.s_addr) > ntohl (cp->gate.ipv4.s_addr))
-	    continue;
-	}
-    }
-
-  /* Make linked list. */
-  if (pp)
-    pp->next = si;
-  else
-    rn->info = si;
-  if (cp)
-    cp->prev = si;
-  si->prev = pp;
-  si->next = cp;
-
-  /* Install into rib. */
-  static_install_ipv4 (p, si);
-
-  return 1;
-}
-
-/* Delete static route from static route configuration. */
-int
-static_delete_ipv4 (struct prefix *p, struct in_addr *gate, const char *ifname,
-		    u_char distance, u_int32_t vrf_id)
-{
-  u_char type = 0;
-  struct route_node *rn;
-  struct static_ipv4 *si;
-  struct route_table *stable;
-
-  /* Lookup table.  */
-  stable = vrf_static_table (AFI_IP, SAFI_UNICAST, vrf_id);
-  if (! stable)
-    return -1;
-
-  /* Lookup static route prefix. */
-  rn = route_node_lookup (stable, p);
-  if (! rn)
-    return 0;
-
-  /* Make flags. */
-  if (gate)
-    type = STATIC_IPV4_GATEWAY;
-  else if (ifname)
-    type = STATIC_IPV4_IFNAME;
-  else
-    type = STATIC_IPV4_BLACKHOLE;
-
-  /* Find same static route is the tree */
-  for (si = rn->info; si; si = si->next)
-    if (type == si->type
-	&& (! gate || IPV4_ADDR_SAME (gate, &si->gate.ipv4))
-	&& (! ifname || strcmp (ifname, si->gate.ifname) == 0))
-      break;
-
-  /* Can't find static route. */
-  if (! si)
-    {
-      route_unlock_node (rn);
-      return 0;
-    }
-
-  /* Install into rib. */
-  static_uninstall_ipv4 (p, si);
-
-  /* Unlink static route from linked list. */
-  if (si->prev)
-    si->prev->next = si->next;
-  else
-    rn->info = si->next;
-  if (si->next)
-    si->next->prev = si->prev;
-  route_unlock_node (rn);
   
-  /* Free static route configuration. */
-  if (ifname)
-    XFREE (0, si->gate.ifname);
-  XFREE (MTYPE_STATIC_IPV4, si);
-
-  route_unlock_node (rn);
-
-  return 1;
-}
-
-
-#ifdef HAVE_IPV6
-static int
-rib_bogus_ipv6 (int type, struct prefix_ipv6 *p,
-		struct in6_addr *gate, unsigned int ifindex, int table)
-{
-  if (type == ZEBRA_ROUTE_CONNECT && IN6_IS_ADDR_UNSPECIFIED (&p->prefix)) {
-#if defined (MUSICA) || defined (LINUX)
-    /* IN6_IS_ADDR_V4COMPAT(&p->prefix) */
-    if (p->prefixlen == 96)
-      return 0;
-#endif /* MUSICA */
-    return 1;
-  }
-  if (type == ZEBRA_ROUTE_KERNEL && IN6_IS_ADDR_UNSPECIFIED (&p->prefix)
-      && p->prefixlen == 96 && gate && IN6_IS_ADDR_UNSPECIFIED (gate))
-    {
-      kernel_delete_ipv6_old (p, gate, ifindex, 0, table);
-      return 1;
-    }
-  return 0;
-}
-
-int
-rib_add_ipv6 (int type, int flags, struct prefix_ipv6 *p,
-	      struct in6_addr *gate, unsigned int ifindex, u_int32_t vrf_id,
-	      u_int32_t metric, u_char distance)
-{
-  struct rib *rib;
-  struct rib *same = NULL;
-  struct route_table *table;
-  struct route_node *rn;
-  struct nexthop *nexthop;
-
   /* Lookup table.  */
-  table = vrf_table (AFI_IP6, SAFI_UNICAST, 0);
+  table = vrf_table (afi, SAFI_UNICAST, 0);
   if (! table)
     return 0;
-
-  /* Make sure mask is applied. */
-  apply_mask_ipv6 (p);
+  /* Make it sure prefixlen is applied to the prefix. */
+  apply_mask (p);
 
   /* Set default distance by route type. */
-  if (!distance)
-    distance = route_info[type].distance;
-  
-  if (type == ZEBRA_ROUTE_BGP && CHECK_FLAG (flags, ZEBRA_FLAG_IBGP))
-    distance = 200;
-
-  /* Filter bogus route. */
-  if (rib_bogus_ipv6 (type, p, gate, ifindex, 0))
-    return 0;
+  if (rib->distance == 0)
+    {
+      rib->distance = route_info[rib->type].distance;
+
+      /* iBGP distance is 200. */
+      if (rib->type == ZEBRA_ROUTE_BGP 
+	  && CHECK_FLAG (rib->flags, ZEBRA_FLAG_IBGP))
+	rib->distance = 200;
+    }
 
   /* Lookup route node.*/
-  rn = route_node_get (table, (struct prefix *) p);
+  rn = route_node_get (table, p);
 
   /* If same type of route are installed, treat it as a implicit
      withdraw. */
-  for (rib = rn->info; rib; rib = rib->next)
+  for (same = rn->info; same; same = same->next)
     {
-      if (CHECK_FLAG (rib->status, RIB_ENTRY_REMOVED))
+      if (CHECK_FLAG (same->status, RIB_ENTRY_REMOVED))
         continue;
-
-      if (rib->type != type)
-	continue;
-      if (rib->type != ZEBRA_ROUTE_CONNECT)
-	{
-	  same = rib;
-	  break;
-	}
-      else if ((nexthop = rib->nexthop) &&
-	       nexthop->type == NEXTHOP_TYPE_IFINDEX &&
-	       nexthop->ifindex == ifindex)
-	{
-	  rib->refcnt++;
-	  return 0;
-	}
+      
+      if (same->type == rib->type && same->table == rib->table
+	  && same->type != ZEBRA_ROUTE_CONNECT)
+        break;
     }
-
-  /* Allocate new rib structure. */
-  rib = XCALLOC (MTYPE_RIB, sizeof (struct rib));
   
-  rib->type = type;
-  rib->distance = distance;
-  rib->flags = flags;
-  rib->metric = metric;
-  rib->table = vrf_id;
-  rib->nexthop_num = 0;
-  rib->uptime = time (NULL);
-
-  /* Nexthop settings. */
-  if (gate)
-    {
-      if (ifindex)
-	nexthop_ipv6_ifindex_add (rib, gate, ifindex);
-      else
-	nexthop_ipv6_add (rib, gate);
-    }
-  else
-    nexthop_ifindex_add (rib, ifindex);
-
   /* If this route is kernel route, set FIB flag to the route. */
-  if (type == ZEBRA_ROUTE_KERNEL || type == ZEBRA_ROUTE_CONNECT)
+  if (rib->type == ZEBRA_ROUTE_KERNEL || rib->type == ZEBRA_ROUTE_CONNECT)
     for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
-      SET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
+      {
+        if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_IGNORE))
+	  continue;
+        SET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
+      }
 
   /* Link new rib to node.*/
   rib_addnode (rn, rib);
+  if (IS_ZEBRA_DEBUG_RIB)
+  {
+    zlog_debug ("%s: called rib_addnode (%p, %p) on new RIB entry",
+      __func__, rn, rib);
+    rib_dump (__func__, p, rib);
+  }
 
   /* Free implicit route.*/
   if (same)
+  {
+    if (IS_ZEBRA_DEBUG_RIB)
+    {
+      zlog_debug ("%s: calling rib_delnode (%p, %p) on existing RIB entry",
+        __func__, rn, same);
+      rib_dump (__func__, p, same);
+    }
     rib_delnode (rn, same);
+  }
   
   route_unlock_node (rn);
   return 0;
 }
 
-/* XXX factor with rib_delete_ipv6 */
 int
-rib_delete_ipv6 (int type, int flags, struct prefix_ipv6 *p,
-		 struct in6_addr *gate, unsigned int ifindex, u_int32_t vrf_id)
+rib_delete_route (int type, int flags, struct prefix *p,
+                  struct zapi_nexthop *nh, u_int32_t vrf_id)
 {
   struct route_table *table;
   struct route_node *rn;
   struct rib *rib;
   struct rib *fib = NULL;
   struct rib *same = NULL;
-  struct nexthop *nexthop;
-  char buf1[BUFSIZ];
-  char buf2[BUFSIZ];
+  char prefix_str[BUFSIZ];
+  int afi;
 
-  /* Apply mask. */
-  apply_mask_ipv6 (p);
+  switch (p->family)
+    {
+      case AF_INET:
+        afi = AFI_IP;
+        break;
+      case AF_INET6:
+        afi = AFI_IP6;
+        break;
+      default:
+        assert(0);
+    }
 
   /* Lookup table.  */
-  table = vrf_table (AFI_IP6, SAFI_UNICAST, 0);
+  table = vrf_table (afi, SAFI_UNICAST, 0);
   if (! table)
     return 0;
-  
+
+  /* Apply mask. */
+  apply_mask (p);
+
+  if (IS_ZEBRA_DEBUG_KERNEL)
+    {
+      inet_ntop (p->family, &p->u.prefix, prefix_str, BUFSIZ),
+      snprintf(&prefix_str[strlen(prefix_str)], BUFSIZ - strlen(prefix_str),
+               "/%d", p->prefixlen);
+      zapi_nexthop_str(nh, &prefix_str[strlen(prefix_str)],
+                         BUFSIZ - strlen(prefix_str));
+
+      zlog_debug ("rib_delete_route(): route delete %s", prefix_str);
+    }
+
   /* Lookup route node. */
-  rn = route_node_lookup (table, (struct prefix *) p);
+  rn = route_node_lookup (table, p);
   if (! rn)
     {
       if (IS_ZEBRA_DEBUG_KERNEL)
-	{
-	  if (gate)
-	    zlog_debug ("route %s/%d via %s ifindex %d doesn't exist in rib",
-		       inet_ntop (AF_INET6, &p->prefix, buf1, BUFSIZ),
-		       p->prefixlen,
-		       inet_ntop (AF_INET6, gate, buf2, BUFSIZ),
-		       ifindex);
-	  else
-	    zlog_debug ("route %s/%d ifindex %d doesn't exist in rib",
-		       inet_ntop (AF_INET6, &p->prefix, buf1, BUFSIZ),
-		       p->prefixlen,
-		       ifindex);
-	}
+        zlog_debug ("route %s doesn't exist in rib", prefix_str);
       return ZEBRA_ERR_RTNOEXIST;
     }
 
   /* Lookup same type route. */
   for (rib = rn->info; rib; rib = rib->next)
     {
-      if (CHECK_FLAG(rib->status, RIB_ENTRY_REMOVED))
+      if (CHECK_FLAG (rib->status, RIB_ENTRY_REMOVED))
         continue;
 
       if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_SELECTED))
 	fib = rib;
 
       if (rib->type != type)
-        continue;
-      if (rib->type == ZEBRA_ROUTE_CONNECT && (nexthop = rib->nexthop) &&
-	  nexthop->type == NEXTHOP_TYPE_IFINDEX && nexthop->ifindex == ifindex)
-	{
-	  if (rib->refcnt)
+	continue;
+
+      /* Make sure that the route found matched */
+      if (zapi_nexthop_match_nexthop(nh, rib->nexthop, ZEBRA_NEXTHOP_ALL))
+        {
+          if (rib->type == ZEBRA_ROUTE_CONNECT)
 	    {
-	      rib->refcnt--;
-	      route_unlock_node (rn);
-	      route_unlock_node (rn);
-	      return 0;
+	      if (rib->refcnt)
+	        {
+	          rib->refcnt--;
+	          route_unlock_node (rn);
+	          route_unlock_node (rn);
+	          return 0;
+	        }
+	      same = rib;
+	      break;
 	    }
-	  same = rib;
-	  break;
-	}
-      /* Make sure that the route found has the same gateway. */
-      else if (gate == NULL ||
-	       ((nexthop = rib->nexthop) &&
-	        (IPV6_ADDR_SAME (&nexthop->gate.ipv6, gate) ||
-		 IPV6_ADDR_SAME (&nexthop->rgate.ipv6, gate))))
-	{
-	  same = rib;
-	  break;
-	}
+          else
+            {
+	      same = rib;
+	      break;
+	    }
+        }
     }
 
-  /* If same type of route can't be found and this message is from
-     kernel. */
+  /* If same type of route can't be found and this message is from kernel. */
   if (! same)
     {
       if (fib && type == ZEBRA_ROUTE_KERNEL)
 	{
+          struct nexthop *nexthop = NULL;
 	  /* Unset flags. */
 	  for (nexthop = fib->nexthop; nexthop; nexthop = nexthop->next)
 	    UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB);
@@ -2496,43 +2314,97 @@ rib_delete_ipv6 (int type, int flags, struct prefix_ipv6 *p,
       else
 	{
 	  if (IS_ZEBRA_DEBUG_KERNEL)
-	    {
-	      if (gate)
-		zlog_debug ("route %s/%d via %s ifindex %d type %d doesn't exist in rib",
-			   inet_ntop (AF_INET6, &p->prefix, buf1, BUFSIZ),
-			   p->prefixlen,
-			   inet_ntop (AF_INET6, gate, buf2, BUFSIZ),
-			   ifindex,
-			   type);
-	      else
-		zlog_debug ("route %s/%d ifindex %d type %d doesn't exist in rib",
-			   inet_ntop (AF_INET6, &p->prefix, buf1, BUFSIZ),
-			   p->prefixlen,
-			   ifindex,
-			   type);
-	    }
+	    zlog_debug ("route %s type %d doesn't exist in rib",
+                        prefix_str, type);
 	  route_unlock_node (rn);
 	  return ZEBRA_ERR_RTNOEXIST;
 	}
     }
-
+  
   if (same)
     rib_delnode (rn, same);
   
   route_unlock_node (rn);
   return 0;
 }
+
+static int
+static_route_compare(struct static_route *a, struct static_route *b, int mask)
+{
+  int both = (a->nh.type & b->nh.type) & mask;
+  int ret = 0;
+
+  if (a->distance < b->distance)
+    return -1;
+
+  if (a->distance > b->distance)
+    return 1;
+
+  if (CHECK_FLAG (both, ZEBRA_NEXTHOP_IPV4))
+    {
+      ret = IPV4_ADDR_CMP(&a->nh.gw.ipv4, &b->nh.gw.ipv4);
+      if (ret)
+	return ret;
+    }
+  else if (CHECK_FLAG (both, ZEBRA_NEXTHOP_IPV6))
+    {
+      ret = IPV6_ADDR_CMP(&a->nh.gw.ipv6, &b->nh.gw.ipv6);
+      if (ret)
+	return ret;
+    }
+
+  if (CHECK_FLAG (both, ZEBRA_NEXTHOP_IFNAME))
+    {
+      ret = strncmp(a->nh.intf.name, b->nh.intf.name, IFNAMSIZ);
+      if (ret)
+	return ret;
+    }
+  else if (CHECK_FLAG (both, ZEBRA_NEXTHOP_IFINDEX))
+    {
+      if (a->nh.intf.index < b->nh.intf.index)
+        return -1;
+      if (a->nh.intf.index > b->nh.intf.index)
+        return 1;
+    }
+#ifdef HAVE_MPLS
+  if (CHECK_FLAG (both, ZEBRA_NEXTHOP_MPLS))
+    {
+      int aos = mpls_out_segment_find_index_by_nexthop(&a->nh);
+      int bos = mpls_out_segment_find_index_by_nexthop(&b->nh);
+      if (aos < bos)
+        return -1;
+      if (aos > bos)
+        return 1;
+    }
+#endif
+
+  return 0;
+}
 
 /* Install static route into rib. */
 static void
-static_install_ipv6 (struct prefix *p, struct static_ipv6 *si)
+static_install_route (struct prefix *p, struct zapi_nexthop *nexthop, int distance)
 {
   struct rib *rib;
-  struct route_table *table;
   struct route_node *rn;
+  struct route_table *table;
+  int new = 0;
+  int afi;
 
+  switch (p->family)
+    {
+      case AF_INET:
+        afi = AFI_IP;
+        break;
+      case AF_INET6:
+        afi = AFI_IP6;
+        break;
+      default:
+        assert(0);
+    }
+    
   /* Lookup table.  */
-  table = vrf_table (AFI_IP6, SAFI_UNICAST, 0);
+  table = vrf_table (afi, SAFI_UNICAST, 0);
   if (! table)
     return;
 
@@ -2540,98 +2412,74 @@ static_install_ipv6 (struct prefix *p, struct static_ipv6 *si)
   rn = route_node_get (table, p);
   for (rib = rn->info; rib; rib = rib->next)
     {
-      if (CHECK_FLAG(rib->status, RIB_ENTRY_REMOVED))
-        continue;
-
-      if (rib->type == ZEBRA_ROUTE_STATIC && rib->distance == si->distance)
-        break;
+       if (CHECK_FLAG (rib->status, RIB_ENTRY_REMOVED))
+         continue;
+        
+       if (rib->type == ZEBRA_ROUTE_STATIC && rib->distance == distance)
+         break;
     }
 
-  if (rib)
+  if (!rib)
     {
-      /* Same distance static route is there.  Update it with new
-         nexthop. */
-      route_unlock_node (rn);
+      new = 1;
 
-      switch (si->type)
-	{
-	case STATIC_IPV6_GATEWAY:
-	  nexthop_ipv6_add (rib, &si->ipv6);
-	  break;
-	case STATIC_IPV6_IFNAME:
-	  nexthop_ifname_add (rib, si->ifname);
-	  break;
-	case STATIC_IPV6_GATEWAY_IFNAME:
-	  nexthop_ipv6_ifname_add (rib, &si->ipv6, si->ifname);
-	  break;
-	}
-      rib_queue_add (&zebrad, rn);
-    }
-  else
-    {
       /* This is new static route. */
       rib = XCALLOC (MTYPE_RIB, sizeof (struct rib));
       
       rib->type = ZEBRA_ROUTE_STATIC;
-      rib->distance = si->distance;
+      rib->distance = distance;
       rib->metric = 0;
       rib->nexthop_num = 0;
+    }
+  else
+    {
+      /* Same distance static route is there.  Update it with new
+         nexthop. */
+      route_unlock_node (rn);
+    }
 
-      switch (si->type)
-	{
-	case STATIC_IPV6_GATEWAY:
-	  nexthop_ipv6_add (rib, &si->ipv6);
-	  break;
-	case STATIC_IPV6_IFNAME:
-	  nexthop_ifname_add (rib, si->ifname);
-	  break;
-	case STATIC_IPV6_GATEWAY_IFNAME:
-	  nexthop_ipv6_ifname_add (rib, &si->ipv6, si->ifname);
-	  break;
-	}
-
-      /* Save the flags of this static routes (reject, blackhole) */
-      rib->flags = si->flags;
+  nexthop_zapi_nexthop_add(rib, nexthop);
 
+  if (new)
+    {
       /* Link this rib to the tree. */
       rib_addnode (rn, rib);
     }
+  else
+    {
+      rib_queue_add (&zebrad, rn);
+    }
 }
 
-static int
-static_ipv6_nexthop_same (struct nexthop *nexthop, struct static_ipv6 *si)
-{
-  if (nexthop->type == NEXTHOP_TYPE_IPV6
-      && si->type == STATIC_IPV6_GATEWAY
-      && IPV6_ADDR_SAME (&nexthop->gate.ipv6, &si->ipv6))
-    return 1;
-  if (nexthop->type == NEXTHOP_TYPE_IFNAME
-      && si->type == STATIC_IPV6_IFNAME
-      && strcmp (nexthop->ifname, si->ifname) == 0)
-    return 1;
-  if (nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME
-      && si->type == STATIC_IPV6_GATEWAY_IFNAME
-      && IPV6_ADDR_SAME (&nexthop->gate.ipv6, &si->ipv6)
-      && strcmp (nexthop->ifname, si->ifname) == 0)
-    return 1;
-  return 0;
-}
-
+/* Uninstall static route from RIB. */
 static void
-static_uninstall_ipv6 (struct prefix *p, struct static_ipv6 *si)
+static_uninstall_route (struct prefix *p, struct zapi_nexthop *znexthop, int distance)
 {
-  struct route_table *table;
   struct route_node *rn;
   struct rib *rib;
   struct nexthop *nexthop;
+  struct route_table *table;
+  int afi;
+
+  switch (p->family)
+    {
+      case AF_INET:
+        afi = AFI_IP;
+        break;
+      case AF_INET6:
+        afi = AFI_IP6;
+        break;
+      default:
+        assert(0);
+    }
 
   /* Lookup table.  */
-  table = vrf_table (AFI_IP6, SAFI_UNICAST, 0);
+  table = vrf_table (afi, SAFI_UNICAST, 0);
   if (! table)
     return;
-
+  
   /* Lookup existing route with type and distance. */
-  rn = route_node_lookup (table, (struct prefix *) p);
+  rn = route_node_lookup (table, p);
   if (! rn)
     return;
 
@@ -2639,8 +2487,8 @@ static_uninstall_ipv6 (struct prefix *p, struct static_ipv6 *si)
     {
       if (CHECK_FLAG (rib->status, RIB_ENTRY_REMOVED))
         continue;
-    
-      if (rib->type == ZEBRA_ROUTE_STATIC && rib->distance == si->distance)
+
+      if (rib->type == ZEBRA_ROUTE_STATIC && rib->distance == distance)
         break;
     }
 
@@ -2652,7 +2500,7 @@ static_uninstall_ipv6 (struct prefix *p, struct static_ipv6 *si)
 
   /* Lookup nexthop. */
   for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
-    if (static_ipv6_nexthop_same (nexthop, si))
+    if (zapi_nexthop_match_nexthop (znexthop, nexthop, ZEBRA_NEXTHOP_ALL))
       break;
 
   /* Can't find nexthop. */
@@ -2664,9 +2512,7 @@ static_uninstall_ipv6 (struct prefix *p, struct static_ipv6 *si)
   
   /* Check nexthop. */
   if (rib->nexthop_num == 1)
-    {
-      rib_delnode (rn, rib);
-    }
+    rib_delnode (rn, rib);
   else
     {
       if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))
@@ -2681,74 +2527,66 @@ static_uninstall_ipv6 (struct prefix *p, struct static_ipv6 *si)
 
 /* Add static route into static route configuration. */
 int
-static_add_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
-		 const char *ifname, u_char flags, u_char distance,
-		 u_int32_t vrf_id)
+static_add_route (struct prefix *p, struct zapi_nexthop *nexthop,
+		  u_char distance, u_int32_t vrf_id)
 {
   struct route_node *rn;
-  struct static_ipv6 *si;
-  struct static_ipv6 *pp;
-  struct static_ipv6 *cp;
+  struct static_route *si;
+  struct static_route *pp;
+  struct static_route *cp;
+  struct static_route *update = NULL;
   struct route_table *stable;
+  int afi;
+
+  switch (p->family)
+    {
+      case AF_INET:
+        afi = AFI_IP;
+        break;
+      case AF_INET6:
+        afi = AFI_IP6;
+        break;
+      default:
+        assert(0);
+    }
 
   /* Lookup table.  */
-  stable = vrf_static_table (AFI_IP6, SAFI_UNICAST, vrf_id);
+  stable = vrf_static_table (afi, SAFI_UNICAST, vrf_id);
   if (! stable)
     return -1;
-    
-  if (!gate &&
-      (type == STATIC_IPV6_GATEWAY || type == STATIC_IPV6_GATEWAY_IFNAME))
-    return -1;
   
-  if (!ifname && 
-      (type == STATIC_IPV6_GATEWAY_IFNAME || type == STATIC_IPV6_IFNAME))
-    return -1;
-
   /* Lookup static route prefix. */
   rn = route_node_get (stable, p);
 
   /* Do nothing if there is a same static route.  */
   for (si = rn->info; si; si = si->next)
-    {
-      if (distance == si->distance 
-	  && type == si->type
-	  && (! gate || IPV6_ADDR_SAME (gate, &si->ipv6))
-	  && (! ifname || strcmp (ifname, si->ifname) == 0))
-	{
-	  route_unlock_node (rn);
-	  return 0;
-	}
-    }
+    if (zapi_nexthop_match_static_route(distance, nexthop, si))
+      {
+	route_unlock_node (rn);
+	return 0;
+      }
+    else if (afi == AFI_IP)
+      update = si;
+
+  /* Distance or nexthop changed.  */
+  if (update)
+    static_delete_route (p, nexthop, update->distance, vrf_id);
 
   /* Make new static route structure. */
-  si = XMALLOC (MTYPE_STATIC_IPV6, sizeof (struct static_ipv6));
-  memset (si, 0, sizeof (struct static_ipv6));
+  si = XMALLOC (MTYPE_STATIC_ROUTE, sizeof (struct static_route));
+  memset (si, 0, sizeof (struct static_route));
 
-  si->type = type;
   si->distance = distance;
-  si->flags = flags;
-
-  switch (type)
-    {
-    case STATIC_IPV6_GATEWAY:
-      si->ipv6 = *gate;
-      break;
-    case STATIC_IPV6_IFNAME:
-      si->ifname = XSTRDUP (0, ifname);
-      break;
-    case STATIC_IPV6_GATEWAY_IFNAME:
-      si->ipv6 = *gate;
-      si->ifname = XSTRDUP (0, ifname);
-      break;
-    }
+  memcpy(&si->nh, nexthop, sizeof(struct zapi_nexthop));
 
   /* Add new static route information to the tree with sort by
      distance value and gateway address. */
   for (pp = NULL, cp = rn->info; cp; pp = cp, cp = cp->next)
     {
-      if (si->distance < cp->distance)
+      int cmp = static_route_compare(si, cp, ZEBRA_NEXTHOP_ALL);
+      if (cmp < 0)
 	break;
-      if (si->distance > cp->distance)
+      if (cmp > 0)
 	continue;
     }
 
@@ -2763,22 +2601,35 @@ static_add_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
   si->next = cp;
 
   /* Install into rib. */
-  static_install_ipv6 (p, si);
+  static_install_route (p, nexthop, distance);
 
   return 1;
 }
 
 /* Delete static route from static route configuration. */
 int
-static_delete_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
-		    const char *ifname, u_char distance, u_int32_t vrf_id)
+static_delete_route (struct prefix *p, struct zapi_nexthop *nexthop,
+		     u_char distance, u_int32_t vrf_id)
 {
   struct route_node *rn;
-  struct static_ipv6 *si;
+  struct static_route *si;
   struct route_table *stable;
+  int afi;
+
+  switch (p->family)
+    {
+      case AF_INET:
+        afi = AFI_IP;
+        break;
+      case AF_INET6:
+        afi = AFI_IP6;
+        break;
+      default:
+        assert(0);
+    }
 
   /* Lookup table.  */
-  stable = vrf_static_table (AFI_IP6, SAFI_UNICAST, vrf_id);
+  stable = vrf_static_table (afi, SAFI_UNICAST, vrf_id);
   if (! stable)
     return -1;
 
@@ -2789,10 +2640,7 @@ static_delete_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
 
   /* Find same static route is the tree */
   for (si = rn->info; si; si = si->next)
-    if (distance == si->distance 
-	&& type == si->type
-	&& (! gate || IPV6_ADDR_SAME (gate, &si->ipv6))
-	&& (! ifname || strcmp (ifname, si->ifname) == 0))
+    if (zapi_nexthop_match_static_route(distance, nexthop, si))
       break;
 
   /* Can't find static route. */
@@ -2803,7 +2651,7 @@ static_delete_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
     }
 
   /* Install into rib. */
-  static_uninstall_ipv6 (p, si);
+  static_uninstall_route (p, nexthop, distance);
 
   /* Unlink static route from linked list. */
   if (si->prev)
@@ -2812,14 +2660,37 @@ static_delete_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,
     rn->info = si->next;
   if (si->next)
     si->next->prev = si->prev;
+  route_unlock_node (rn);
   
   /* Free static route configuration. */
-  if (ifname)
-    XFREE (0, si->ifname);
-  XFREE (MTYPE_STATIC_IPV6, si);
+  XFREE (MTYPE_STATIC_ROUTE, si);
+
+  route_unlock_node (rn);
 
   return 1;
 }
+
+#ifdef HAVE_IPV6
+static int
+rib_bogus_ipv6 (int type, struct prefix_ipv6 *p,
+		struct in6_addr *gate, unsigned int ifindex, int table)
+{
+  if (type == ZEBRA_ROUTE_CONNECT && IN6_IS_ADDR_UNSPECIFIED (&p->prefix)) {
+#if defined (MUSICA) || defined (LINUX)
+    /* IN6_IS_ADDR_V4COMPAT(&p->prefix) */
+    if (p->prefixlen == 96)
+      return 0;
+#endif /* MUSICA */
+    return 1;
+  }
+  if (type == ZEBRA_ROUTE_KERNEL && IN6_IS_ADDR_UNSPECIFIED (&p->prefix)
+      && p->prefixlen == 96 && gate && IN6_IS_ADDR_UNSPECIFIED (gate))
+    {
+      kernel_delete_ipv6_old (p, gate, ifindex, 0, table);
+      return 1;
+    }
+  return 0;
+}
 #endif /* HAVE_IPV6 */
 
 /* RIB update function. */
diff --git a/zebra/zebra_routemap.c b/zebra/zebra_routemap.c
index 808dcf7..c0de4bc 100644
--- a/zebra/zebra_routemap.c
+++ b/zebra/zebra_routemap.c
@@ -419,25 +419,24 @@ route_match_ip_next_hop (void *rule, struct prefix *prefix,
   if (type == RMAP_ZEBRA)
     {
       nexthop = object;
-      switch (nexthop->type) {
-      case NEXTHOP_TYPE_IFINDEX:
-      case NEXTHOP_TYPE_IFNAME:
-      case NEXTHOP_TYPE_IPV4_IFINDEX:
-      case NEXTHOP_TYPE_IPV4_IFNAME:
-        if (nexthop->rtype != NEXTHOP_TYPE_IPV4)
-		return RMAP_NOMATCH;
-        p.family = AF_INET;
-        p.prefix = nexthop->rgate.ipv4;
-        p.prefixlen = IPV4_MAX_BITLEN;
-        break;
-      case NEXTHOP_TYPE_IPV4:
-        p.family = AF_INET;
-        p.prefix = nexthop->gate.ipv4;
-        p.prefixlen = IPV4_MAX_BITLEN;
-        break;
-      default:
+      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
+	{
+	  p.family = AF_INET;
+	  p.prefix = nexthop->gate.ipv4;
+	  p.prefixlen = IPV4_MAX_BITLEN;
+	}
+      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX) ||
+	       CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
+	{
+	  if (!CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV4))
+	    return RMAP_NOMATCH;
+	  p.family = AF_INET;
+	  p.prefix = nexthop->rgate.ipv4;
+	  p.prefixlen = IPV4_MAX_BITLEN;
+	}
+      else
         return RMAP_NOMATCH;
-      }
+
       alist = access_list_lookup (AFI_IP, (char *) rule);
       if (alist == NULL)
 	return RMAP_NOMATCH;
@@ -485,25 +484,24 @@ route_match_ip_next_hop_prefix_list (void *rule, struct prefix *prefix,
   if (type == RMAP_ZEBRA)
     {
       nexthop = object;
-      switch (nexthop->type) {
-      case NEXTHOP_TYPE_IFINDEX:
-      case NEXTHOP_TYPE_IFNAME:
-      case NEXTHOP_TYPE_IPV4_IFINDEX:
-      case NEXTHOP_TYPE_IPV4_IFNAME:
-        if (nexthop->rtype != NEXTHOP_TYPE_IPV4)
-		return RMAP_NOMATCH;
-        p.family = AF_INET;
-        p.prefix = nexthop->rgate.ipv4;
-        p.prefixlen = IPV4_MAX_BITLEN;
-        break;
-      case NEXTHOP_TYPE_IPV4:
-        p.family = AF_INET;
-        p.prefix = nexthop->gate.ipv4;
-        p.prefixlen = IPV4_MAX_BITLEN;
-        break;
-      default:
+      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
+	{
+	  p.family = AF_INET;
+	  p.prefix = nexthop->gate.ipv4;
+	  p.prefixlen = IPV4_MAX_BITLEN;
+	}
+      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX) ||
+	       CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
+	{
+	  if (!CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV4))
+	    return RMAP_NOMATCH;
+	  p.family = AF_INET;
+	  p.prefix = nexthop->rgate.ipv4;
+	  p.prefixlen = IPV4_MAX_BITLEN;
+	}
+      else
         return RMAP_NOMATCH;
-      }
+
       plist = prefix_list_lookup (AFI_IP, (char *) rule);
       if (plist == NULL)
         return RMAP_NOMATCH;
diff --git a/zebra/zebra_snmp.c b/zebra/zebra_snmp.c
index 4536026..6c32fad 100644
--- a/zebra/zebra_snmp.c
+++ b/zebra/zebra_snmp.c
@@ -483,8 +483,7 @@ ipFwTable (struct variable *v, oid objid[], size_t *objid_len,
       return (u_char *)&nexthop->ifindex;
       break;
     case IPFORWARDTYPE:
-      if (nexthop->type == NEXTHOP_TYPE_IFINDEX
-	  || nexthop->type == NEXTHOP_TYPE_IFNAME)
+      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
         result = 3;
       else
         result = 4;
diff --git a/zebra/zebra_vty.c b/zebra/zebra_vty.c
index 0c31392..ed35b97 100644
--- a/zebra/zebra_vty.c
+++ b/zebra/zebra_vty.c
@@ -29,20 +29,25 @@
 #include "rib.h"
 
 #include "zebra/zserv.h"
+#ifdef HAVE_MPLS
+#include "mpls_vty.h"
+#endif
 
 /* General fucntion for static route. */
 static int
-zebra_static_ipv4 (struct vty *vty, int add_cmd, const char *dest_str,
-		   const char *mask_str, const char *gate_str,
-		   const char *flag_str, const char *distance_str)
+do_zebra_static_ipv4 (struct vty *vty, int add_cmd, const char *dest_str,
+		     const char *mask_str, const char *gate_str,
+		     const char *flag_str, const char *distance_str,
+		     const char *advmss_str, u_int mpls)
 {
   int ret;
   u_char distance;
   struct prefix p;
+  struct zapi_nexthop nexthop;
   struct in_addr gate;
   struct in_addr mask;
-  const char *ifname;
-  u_char flag = 0;
+
+  memset(&nexthop, 0, sizeof (struct zapi_nexthop));
   
   ret = str2prefix (dest_str, &p);
   if (ret <= 0)
@@ -72,6 +77,33 @@ zebra_static_ipv4 (struct vty *vty, int add_cmd, const char *dest_str,
   else
     distance = ZEBRA_STATIC_DISTANCE_DEFAULT;
 
+  if (advmss_str)
+    nexthop.advmss = atoi (advmss_str);
+
+#ifdef HAVE_MPLS
+  if (mpls)
+  {
+    struct zmpls_out_segment* out = mpls_out_segment_find(mpls);
+    if (out)
+    {
+      /* there needs to be a better way to do this, this is frought with
+       * possible inconsistency issues.  By the time we get here we've
+       * created a out segment which has a full next hop specification,
+       * and we've started to build a whole new next hop in this
+       * function, are we sure they even match?  Maybe static needs to
+       * creating the out segment and pass around a label struct
+       * and then we build a single nexthop which can be used to
+       * build the out segment and the static route entry.
+       *
+       * for now I punt, just copy the label from the out segment, we'll
+       * magically hook this back together someplace down the line ...
+       */
+      SET_FLAG (nexthop.type, ZEBRA_NEXTHOP_MPLS);
+      nexthop.mpls = out->nh.mpls;
+    }
+  }
+#endif
+
   /* Null0 static route.  */
   if ((gate_str != NULL) && (strncasecmp (gate_str, "Null0", strlen (gate_str)) == 0))
     {
@@ -80,10 +112,13 @@ zebra_static_ipv4 (struct vty *vty, int add_cmd, const char *dest_str,
           vty_out (vty, "%% can not have flag %s with Null0%s", flag_str, VTY_NEWLINE);
           return CMD_WARNING;
         }
+      SET_FLAG (nexthop.type, ZEBRA_NEXTHOP_DROP);
+      nexthop.gw.drop = ZEBRA_DROP_NULL;
+
       if (add_cmd)
-        static_add_ipv4 (&p, NULL, NULL, ZEBRA_FLAG_BLACKHOLE, distance, 0);
+        static_add_route (&p, &nexthop, distance, 0);
       else
-        static_delete_ipv4 (&p, NULL, NULL, distance, 0);
+        static_delete_route (&p, &nexthop, distance, 0);
       return CMD_SUCCESS;
     }
 
@@ -92,11 +127,13 @@ zebra_static_ipv4 (struct vty *vty, int add_cmd, const char *dest_str,
     switch(flag_str[0]) {
       case 'r':
       case 'R': /* XXX */
-        SET_FLAG (flag, ZEBRA_FLAG_REJECT);
+        SET_FLAG (nexthop.type, ZEBRA_NEXTHOP_DROP);
+	nexthop.gw.drop = ZEBRA_DROP_REJECT;
         break;
       case 'b':
       case 'B': /* XXX */
-        SET_FLAG (flag, ZEBRA_FLAG_BLACKHOLE);
+        SET_FLAG (nexthop.type, ZEBRA_NEXTHOP_DROP);
+	nexthop.gw.drop = ZEBRA_DROP_BLACKHOLE;
         break;
       default:
         vty_out (vty, "%% Malformed flag %s %s", flag_str, VTY_NEWLINE);
@@ -107,9 +144,9 @@ zebra_static_ipv4 (struct vty *vty, int add_cmd, const char *dest_str,
   if (gate_str == NULL)
   {
     if (add_cmd)
-      static_add_ipv4 (&p, NULL, NULL, flag, distance, 0);
+      static_add_route (&p, &nexthop, distance, 0);
     else
-      static_delete_ipv4 (&p, NULL, NULL, distance, 0);
+      static_delete_route (&p, &nexthop, distance, 0);
 
     return CMD_SUCCESS;
   }
@@ -118,18 +155,34 @@ zebra_static_ipv4 (struct vty *vty, int add_cmd, const char *dest_str,
      address other case gate is treated as interface name. */
   ret = inet_aton (gate_str, &gate);
   if (ret)
-    ifname = NULL;
+    {
+      nexthop.gw.ipv4 = gate;
+      SET_FLAG (nexthop.type, ZEBRA_NEXTHOP_IPV4);
+    }
   else
-    ifname = gate_str;
+    {
+      strncpy(nexthop.intf.name, gate_str, IFNAMSIZ);
+      SET_FLAG (nexthop.type, ZEBRA_NEXTHOP_IFNAME);
+    }
 
   if (add_cmd)
-    static_add_ipv4 (&p, ifname ? NULL : &gate, ifname, flag, distance, 0);
+    static_add_route (&p, &nexthop, distance, 0);
   else
-    static_delete_ipv4 (&p, ifname ? NULL : &gate, ifname, distance, 0);
+    static_delete_route (&p, &nexthop, distance, 0);
 
   return CMD_SUCCESS;
 }
 
+int
+zebra_static_ipv4 (struct vty *vty, int add_cmd, const char *dest_str,
+                  const char *mask_str, const char *gate_str,
+                  const char *flag_str, const char *distance_str,
+                  const char *advmss_str)
+{
+  return do_zebra_static_ipv4(vty, add_cmd, dest_str, mask_str, gate_str,
+    flag_str, distance_str, advmss_str, 0);
+}
+
 /* Static route configuration.  */
 DEFUN (ip_route, 
        ip_route_cmd,
@@ -141,7 +194,22 @@ DEFUN (ip_route,
        "IP gateway interface name\n"
        "Null interface\n")
 {
-  return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], NULL, NULL);
+  return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], NULL, NULL, NULL);
+}
+
+DEFUN (ip_route_advmss, 
+       ip_route_advmss_cmd,
+       "ip route A.B.C.D/M (A.B.C.D|INTERFACE|null0) advmss <0-65495>",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "IP gateway address\n"
+       "IP gateway interface name\n"
+       "Null interface\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], NULL, NULL, argv[2]);
 }
 
 DEFUN (ip_route_flags,
@@ -155,7 +223,7 @@ DEFUN (ip_route_flags,
        "Emit an ICMP unreachable when matched\n"
        "Silently discard pkts when matched\n")
 {
-  return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], argv[2], NULL);
+  return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], argv[2], NULL, NULL);
 }
 
 DEFUN (ip_route_flags2,
@@ -167,7 +235,7 @@ DEFUN (ip_route_flags2,
        "Emit an ICMP unreachable when matched\n"
        "Silently discard pkts when matched\n")
 {
-  return zebra_static_ipv4 (vty, 1, argv[0], NULL, NULL, argv[1], NULL);
+  return zebra_static_ipv4 (vty, 1, argv[0], NULL, NULL, argv[1], NULL, NULL);
 }
 
 /* Mask as A.B.C.D format.  */
@@ -182,7 +250,23 @@ DEFUN (ip_route_mask,
        "IP gateway interface name\n"
        "Null interface\n")
 {
-  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], NULL, NULL);
+  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], NULL, NULL, NULL);
+}
+
+DEFUN (ip_route_mask_advmss,
+       ip_route_mask_advmss_cmd,
+       "ip route A.B.C.D A.B.C.D (A.B.C.D|INTERFACE|null0) advmss <0-65495>",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix\n"
+       "IP destination prefix mask\n"
+       "IP gateway address\n"
+       "IP gateway interface name\n"
+       "Null interface\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], NULL, NULL, argv[3]);
 }
 
 DEFUN (ip_route_mask_flags,
@@ -197,7 +281,7 @@ DEFUN (ip_route_mask_flags,
        "Emit an ICMP unreachable when matched\n"
        "Silently discard pkts when matched\n")
 {
-  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], argv[3], NULL);
+  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], argv[3], NULL, NULL);
 }
 
 DEFUN (ip_route_mask_flags2,
@@ -210,7 +294,7 @@ DEFUN (ip_route_mask_flags2,
        "Emit an ICMP unreachable when matched\n"
        "Silently discard pkts when matched\n")
 {
-  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], NULL, argv[2], NULL);
+  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], NULL, argv[2], NULL, NULL);
 }
 
 /* Distance option value.  */
@@ -225,7 +309,23 @@ DEFUN (ip_route_distance,
        "Null interface\n"
        "Distance value for this route\n")
 {
-  return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], NULL, argv[2]);
+  return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], NULL, argv[2], NULL);
+}
+
+DEFUN (ip_route_distance_advmss,
+       ip_route_distance_advmss_cmd,
+       "ip route A.B.C.D/M (A.B.C.D|INTERFACE|null0) <1-255> advmss <0-65495>",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "IP gateway address\n"
+       "IP gateway interface name\n"
+       "Null interface\n"
+       "Distance value for this route\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], NULL, argv[2], argv[3]);
 }
 
 DEFUN (ip_route_flags_distance,
@@ -240,7 +340,7 @@ DEFUN (ip_route_flags_distance,
        "Silently discard pkts when matched\n"
        "Distance value for this route\n")
 {
-  return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], argv[2], argv[3]);
+  return zebra_static_ipv4 (vty, 1, argv[0], NULL, argv[1], argv[2], argv[3], NULL);
 }
 
 DEFUN (ip_route_flags_distance2,
@@ -253,7 +353,7 @@ DEFUN (ip_route_flags_distance2,
        "Silently discard pkts when matched\n"
        "Distance value for this route\n")
 {
-  return zebra_static_ipv4 (vty, 1, argv[0], NULL, NULL, argv[1], argv[2]);
+  return zebra_static_ipv4 (vty, 1, argv[0], NULL, NULL, argv[1], argv[2], NULL);
 }
 
 DEFUN (ip_route_mask_distance,
@@ -268,7 +368,24 @@ DEFUN (ip_route_mask_distance,
        "Null interface\n"
        "Distance value for this route\n")
 {
-  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], NULL, argv[3]);
+  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], NULL, argv[3], NULL);
+}
+
+DEFUN (ip_route_mask_distance_advmss,
+       ip_route_mask_distance_advmss_cmd,
+       "ip route A.B.C.D A.B.C.D (A.B.C.D|INTERFACE|null0) <1-255> advmss <0-65495>",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix\n"
+       "IP destination prefix mask\n"
+       "IP gateway address\n"
+       "IP gateway interface name\n"
+       "Null interface\n"
+       "Distance value for this route\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], NULL, argv[3], argv[4]);
 }
 
 DEFUN (ip_route_mask_flags_distance,
@@ -284,7 +401,7 @@ DEFUN (ip_route_mask_flags_distance,
        "Emit an ICMP unreachable when matched\n"
        "Silently discard pkts when matched\n")
 {
-  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], argv[3], argv[4]);
+  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], argv[2], argv[3], argv[4], NULL);
 }
 
 DEFUN (ip_route_mask_flags_distance2,
@@ -298,7 +415,7 @@ DEFUN (ip_route_mask_flags_distance2,
        "Emit an ICMP unreachable when matched\n"
        "Silently discard pkts when matched\n")
 {
-  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], NULL, argv[2], argv[3]);
+  return zebra_static_ipv4 (vty, 1, argv[0], argv[1], NULL, argv[2], argv[3], NULL);
 }
 
 DEFUN (no_ip_route, 
@@ -312,7 +429,23 @@ DEFUN (no_ip_route,
        "IP gateway interface name\n"
        "Null interface\n")
 {
-  return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], NULL, NULL);
+  return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], NULL, NULL, NULL);
+}
+
+DEFUN (no_ip_route_advmss, 
+       no_ip_route_advmss_cmd,
+       "no ip route A.B.C.D/M (A.B.C.D|INTERFACE|null0) advmss <0-65495>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "IP gateway address\n"
+       "IP gateway interface name\n"
+       "Null interface\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], NULL, NULL, argv[2]);
 }
 
 ALIAS (no_ip_route,
@@ -337,7 +470,7 @@ DEFUN (no_ip_route_flags2,
        "Emit an ICMP unreachable when matched\n"
        "Silently discard pkts when matched\n")
 {
-  return zebra_static_ipv4 (vty, 0, argv[0], NULL, NULL, NULL, NULL);
+  return zebra_static_ipv4 (vty, 0, argv[0], NULL, NULL, NULL, NULL, NULL);
 }
 
 DEFUN (no_ip_route_mask,
@@ -352,7 +485,24 @@ DEFUN (no_ip_route_mask,
        "IP gateway interface name\n"
        "Null interface\n")
 {
-  return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], NULL, NULL);
+  return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], NULL, NULL, NULL);
+}
+
+DEFUN (no_ip_route_mask_advmss,
+       no_ip_route_mask_advmss_cmd,
+       "no ip route A.B.C.D A.B.C.D (A.B.C.D|INTERFACE|null0) advmss <0-65495>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix\n"
+       "IP destination prefix mask\n"
+       "IP gateway address\n"
+       "IP gateway interface name\n"
+       "Null interface\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], NULL, NULL, argv[3]);
 }
 
 ALIAS (no_ip_route_mask,
@@ -379,7 +529,7 @@ DEFUN (no_ip_route_mask_flags2,
        "Emit an ICMP unreachable when matched\n"
        "Silently discard pkts when matched\n")
 {
-  return zebra_static_ipv4 (vty, 0, argv[0], argv[1], NULL, NULL, NULL);
+  return zebra_static_ipv4 (vty, 0, argv[0], argv[1], NULL, NULL, NULL, NULL);
 }
 
 DEFUN (no_ip_route_distance,
@@ -394,7 +544,24 @@ DEFUN (no_ip_route_distance,
        "Null interface\n"
        "Distance value for this route\n")
 {
-  return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], NULL, argv[2]);
+  return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], NULL, argv[2], NULL);
+}
+
+DEFUN (no_ip_route_distance_advmss,
+       no_ip_route_distance_advmss_cmd,
+       "no ip route A.B.C.D/M (A.B.C.D|INTERFACE|null0) <1-255> advmss <0-65495>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "IP gateway address\n"
+       "IP gateway interface name\n"
+       "Null interface\n"
+       "Distance value for this route\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], NULL, argv[2], argv[3]);
 }
 
 DEFUN (no_ip_route_flags_distance,
@@ -410,7 +577,7 @@ DEFUN (no_ip_route_flags_distance,
        "Silently discard pkts when matched\n"
        "Distance value for this route\n")
 {
-  return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], argv[2], argv[3]);
+  return zebra_static_ipv4 (vty, 0, argv[0], NULL, argv[1], argv[2], argv[3], NULL);
 }
 
 DEFUN (no_ip_route_flags_distance2,
@@ -424,7 +591,7 @@ DEFUN (no_ip_route_flags_distance2,
        "Silently discard pkts when matched\n"
        "Distance value for this route\n")
 {
-  return zebra_static_ipv4 (vty, 0, argv[0], NULL, NULL, argv[1], argv[2]);
+  return zebra_static_ipv4 (vty, 0, argv[0], NULL, NULL, argv[1], argv[2], NULL);
 }
 
 DEFUN (no_ip_route_mask_distance,
@@ -440,7 +607,25 @@ DEFUN (no_ip_route_mask_distance,
        "Null interface\n"
        "Distance value for this route\n")
 {
-  return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], NULL, argv[3]);
+  return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], NULL, argv[3], NULL);
+}
+
+DEFUN (no_ip_route_mask_distance_advmss,
+       no_ip_route_mask_distance_advmss_cmd,
+       "no ip route A.B.C.D A.B.C.D (A.B.C.D|INTERFACE|null0) <1-255> advmss <0-65495>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix\n"
+       "IP destination prefix mask\n"
+       "IP gateway address\n"
+       "IP gateway interface name\n"
+       "Null interface\n"
+       "Distance value for this route\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], NULL, argv[3], argv[4]);
 }
 
 DEFUN (no_ip_route_mask_flags_distance,
@@ -457,7 +642,7 @@ DEFUN (no_ip_route_mask_flags_distance,
        "Silently discard pkts when matched\n"
        "Distance value for this route\n")
 {
-  return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], argv[3], argv[4]);
+  return zebra_static_ipv4 (vty, 0, argv[0], argv[1], argv[2], argv[3], argv[4], NULL);
 }
 
 DEFUN (no_ip_route_mask_flags_distance2,
@@ -472,7 +657,7 @@ DEFUN (no_ip_route_mask_flags_distance2,
        "Silently discard pkts when matched\n"
        "Distance value for this route\n")
 {
-  return zebra_static_ipv4 (vty, 0, argv[0], argv[1], NULL, argv[2], argv[3]);
+  return zebra_static_ipv4 (vty, 0, argv[0], argv[1], NULL, argv[2], argv[3], NULL);
 }
 
 char *proto_rm[AFI_MAX][ZEBRA_ROUTE_MAX+1];	/* "any" == ZEBRA_ROUTE_MAX */
@@ -527,6 +712,474 @@ DEFUN (no_ip_protocol,
   proto_rm[AFI_IP][i] = NULL;
   return CMD_SUCCESS;
 }
+#ifdef HAVE_MPLS
+/* Static route + MPLS configuration.  */
+static int
+zebra_static_ipv4_mpls (struct vty *vty, int add_cmd, const char *dest_str,
+  const char *addr, const char *mask_str, const char *distance,
+  const char *advmss, const char **argv)
+{
+  struct zmpls_out_segment out;
+  struct zmpls_ftn *old;
+  struct zmpls_ftn ftn;
+  struct prefix p;
+  int result;
+
+  if (str2prefix (dest_str, &p) <= 0)
+    {
+      vty_out (vty, "%% Malformed address%s", VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+  /* Cisco like mask notation. */
+  if (mask_str)
+    {
+      struct in_addr mask;
+      if (inet_aton (mask_str, &mask) == 0)
+        {
+          vty_out (vty, "%% Malformed address%s", VTY_NEWLINE);
+          return CMD_WARNING;
+        }
+      p.prefixlen = ip_masklen (mask);
+    }
+
+  /* Apply mask for given prefix. */
+  apply_mask (&p);
+
+  memcpy(&ftn.fec.u.p, &p, sizeof(p));
+  ftn.fec.type = ZEBRA_MPLS_FEC_IPV4;
+  ftn.fec.owner = ZEBRA_ROUTE_STATIC;
+  old = mpls_ftn_find_by_fec(&ftn.fec);
+
+  memset (&out, 0, sizeof (out));
+  out.owner = ZEBRA_ROUTE_STATIC;
+  result = nhlfe_parse (vty, argv, &out, addr);
+  if (result != CMD_SUCCESS)
+    return result;
+
+  out.index = mpls_out_segment_find_index_by_nhlfe(&out);
+
+  if (add_cmd)
+  {
+    if (old)
+    {
+      vty_out(vty, "FTN already exists%s",VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+    if (out.index)
+    {
+      vty_out(vty, "NHLFE already exists%s",VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+    if ((result = mpls_out_segment_register (&out)))
+    {
+      vty_out(vty, "Unable to register NHLFE(%d)%s", result, VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+    ftn.out_index = out.index;
+
+  } else {
+    if (!out.index)
+    {
+      vty_out(vty, "No such NHLFE%s",VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+    if (!old)
+    {
+      vty_out(vty, "No such FEC%s",VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+    mpls_ftn_unregister(old, 0);
+  }
+
+  result = do_zebra_static_ipv4 (vty, add_cmd, dest_str, mask_str, addr, NULL,
+    distance, advmss, out.index);
+
+  if (add_cmd)
+  {
+    if (result != CMD_SUCCESS)
+    {
+      mpls_out_segment_unregister_by_index (out.index);
+      return CMD_WARNING;
+    }
+    mpls_ftn_register(&ftn, 0);
+  }
+  else
+  {
+    mpls_out_segment_unregister_by_index (out.index);
+  }
+  return CMD_SUCCESS;
+}
+
+DEFUN (ip_route_mpls, 
+       ip_route_mpls_cmd,
+       "ip route A.B.C.D/M (gen|atm|fr) VALUE nexthop INTERFACE",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n")
+{
+  return zebra_static_ipv4_mpls (vty, 1, argv[0], NULL, NULL, NULL, NULL, &argv[1]);
+}
+
+DEFUN (ip_route_mpls_advmss, 
+       ip_route_mpls_advmss_cmd,
+       "ip route A.B.C.D/M (gen|atm|fr) VALUE nexthop INTERFACE advmss <0-65495>",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return zebra_static_ipv4_mpls (vty, 1, argv[0], NULL, NULL, NULL, argv[4], &argv[1]);
+}
+
+DEFUN (ip_route_mpls_addr,
+       ip_route_mpls_addr_cmd,
+       "ip route A.B.C.D/M (gen|atm|fr) VALUE nexthop INTERFACE ADDR",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "IP gateway address\n")
+{
+  return zebra_static_ipv4_mpls (vty, 1, argv[0], argv[4], NULL, NULL, NULL, &argv[1]);
+}
+
+DEFUN (ip_route_mpls_addr_advmss,
+       ip_route_mpls_addr_advmss_cmd,
+       "ip route A.B.C.D/M (gen|atm|fr) VALUE nexthop INTERFACE ADDR advmss <0-65495>",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "IP gateway address\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return zebra_static_ipv4_mpls (vty, 1, argv[0], argv[4], NULL, NULL, argv[5], &argv[1]);
+}
+
+/* Mask as A.B.C.D format.  */
+DEFUN (ip_route_mpls_mask,
+       ip_route_mpls_mask_cmd,
+       "ip route A.B.C.D A.B.C.D (gen|atm|fr) VALUE nexthop INTERFACE",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix\n"
+       "IP destination prefix mask\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n")
+{
+  return zebra_static_ipv4_mpls (vty, 1, argv[0], argv[1], NULL, NULL, NULL, &argv[2]);
+}
+
+DEFUN (ip_route_mpls_mask_addr,
+       ip_route_mpls_mask_addr_cmd,
+       "ip route A.B.C.D A.B.C.D (gen|atm|fr) VALUE nexthop INTERFACE ADDR",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix\n"
+       "IP destination prefix mask\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "IP gateway address\n")
+{
+  return zebra_static_ipv4_mpls (vty, 1, argv[0], argv[1], argv[5], NULL, NULL, &argv[2]);
+}
+
+/* Distance option value.  */
+DEFUN (ip_route_mpls_distance,
+       ip_route_mpls_distance_cmd,
+       "ip route A.B.C.D/M (gen|atm|fr) VALUE nexthop INTERFACE <1-255>",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "Distance value for this route\n")
+{
+  return zebra_static_ipv4_mpls (vty, 1, argv[0], NULL, NULL, argv[4], NULL, &argv[1]);
+}
+
+DEFUN (ip_route_mpls_distance_addr,
+       ip_route_mpls_distance_addr_cmd,
+       "ip route A.B.C.D/M (gen|atm|fr) VALUE nexthop INTERFACE ADDR <1-255>",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "IP gateway address\n"
+       "Distance value for this route\n")
+{
+  return zebra_static_ipv4_mpls (vty, 1, argv[0], NULL, argv[4], argv[5], NULL, &argv[1]);
+}
+
+DEFUN (ip_route_mpls_mask_distance,
+       ip_route_mpls_mask_distance_cmd,
+       "ip route A.B.C.D A.B.C.D (gen|atm|fr) VALUE nexthop INTERFACE <1-255>",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix\n"
+       "IP destination prefix mask\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "Distance value for this route\n")
+{
+  return zebra_static_ipv4_mpls (vty, 1, argv[0], argv[1], NULL, argv[5], NULL, &argv[2]);
+}
+
+DEFUN (ip_route_mpls_mask_distance_addr,
+       ip_route_mpls_mask_distance_addr_cmd,
+       "ip route A.B.C.D A.B.C.D (gen|atm|fr) VALUE nexthop INTERFACE ADDR <1-255>",
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix\n"
+       "IP destination prefix mask\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "IP gateway address\n"
+       "Distance value for this route\n")
+{
+  return zebra_static_ipv4_mpls (vty, 1, argv[0], argv[1], argv[5], argv[6], NULL, &argv[2]);
+}
+
+DEFUN (no_ip_route_mpls,
+       no_ip_route_mpls_cmd,
+       "no ip route A.B.C.D/M (gen|atm|fr) VALUE nexthop INTERFACE",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n")
+{
+  return zebra_static_ipv4_mpls (vty, 0, argv[0], NULL, NULL, NULL, NULL, &argv[1]);
+}
+
+DEFUN (no_ip_route_mpls_advmss,
+       no_ip_route_mpls_advmss_cmd,
+       "no ip route A.B.C.D/M (gen|atm|fr) VALUE nexthop INTERFACE advmss <0-65495>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return zebra_static_ipv4_mpls (vty, 0, argv[0], NULL, NULL, NULL, argv[4], &argv[1]);
+}
+DEFUN (no_ip_route_mpls_addr,
+       no_ip_route_mpls_addr_cmd,
+       "no ip route A.B.C.D/M (gen|atm|fr) VALUE nexthop INTERFACE ADDR",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "IP gateway address\n")
+{
+  return zebra_static_ipv4_mpls (vty, 0, argv[0], argv[4], NULL, NULL, NULL, &argv[1]);
+}
+
+DEFUN (no_ip_route_mpls_addr_advmss,
+       no_ip_route_mpls_addr_advmss_cmd,
+       "no ip route A.B.C.D/M (gen|atm|fr) VALUE nexthop INTERFACE ADDR advmss <0-65495>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "IP gateway address\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return zebra_static_ipv4_mpls (vty, 0, argv[0], argv[4], NULL, NULL, argv[5], &argv[1]);
+}
+
+DEFUN (no_ip_route_mpls_mask,
+       no_ip_route_mpls_mask_cmd,
+       "no ip route A.B.C.D A.B.C.D (gen|atm|fr) VALUE nexthop INTERFACE",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix\n"
+       "IP destination prefix mask\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n")
+{
+  return zebra_static_ipv4_mpls (vty, 0, argv[0], argv[1], NULL, NULL, NULL, &argv[2]);
+}
+
+DEFUN (no_ip_route_mpls_mask_addr,
+       no_ip_route_mpls_mask_addr_cmd,
+       "no ip route A.B.C.D A.B.C.D (gen|atm|fr) VALUE nexthop INTERFACE ADDR",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix\n"
+       "IP destination prefix mask\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "IP gateway address\n")
+{
+  return zebra_static_ipv4_mpls (vty, 0, argv[0], argv[1], argv[5], NULL, NULL, &argv[2]);
+}
+
+DEFUN (no_ip_route_mpls_distance,
+       no_ip_route_mpls_distance_cmd,
+       "no ip route A.B.C.D/M (gen|atm|fr) VALUE nexthop INTERFACE <1-255>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "Distance value for this route\n")
+{
+  return zebra_static_ipv4_mpls (vty, 0, argv[0], NULL, NULL, argv[4], NULL, &argv[1]);
+}
+
+DEFUN (no_ip_route_mpls_distance_addr,
+       no_ip_route_mpls_distance_addr_cmd,
+       "no ip route A.B.C.D/M (gen|atm|fr) VALUE nexthop INTERFACE ADDR <1-255>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix (e.g. 10.0.0.0/8)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "IP gateway address\n"
+       "Distance value for this route\n")
+{
+  return zebra_static_ipv4_mpls (vty, 0, argv[0], NULL, argv[4], argv[5], NULL, &argv[1]);
+}
+
+DEFUN (no_ip_route_mpls_mask_distance,
+       no_ip_route_mpls_mask_distance_cmd,
+       "no ip route A.B.C.D A.B.C.D (gen|atm|fr) VALUE nexthop INTERFACE <1-255>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix\n"
+       "IP destination prefix mask\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "Distance value for this route\n")
+{
+  return zebra_static_ipv4_mpls (vty, 0, argv[0], argv[1], NULL, argv[5], NULL, &argv[2]);
+}
+
+DEFUN (no_ip_route_mpls_mask_distance_addr,
+       no_ip_route_mpls_mask_distance_addr_cmd,
+       "no ip route A.B.C.D A.B.C.D (gen|atm|fr) VALUE nexthop INTERFACE ADDR <1-255>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IP destination prefix\n"
+       "IP destination prefix mask\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IP gateway interface name\n"
+       "IP gateway address\n"
+       "Distance value for this route\n")
+{
+  return zebra_static_ipv4_mpls (vty, 0, argv[0], argv[1], argv[5], argv[6], NULL, &argv[2]);
+}
+#endif /* HAVE_MPLS */
 
 /* New RIB.  Detailed information for IPv4 route. */
 static void
@@ -584,31 +1237,83 @@ vty_show_ip_route_detail (struct vty *vty, struct route_node *rn)
       for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
 	{
           char addrstr[32];
+	  if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_IGNORE))
+	    continue;
+
+          if (nexthop->advmss)
+            vty_out (vty, " advmss %d", nexthop->advmss);
 
 	  vty_out (vty, "  %c",
 		   CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB) ? '*' : ' ');
 
-	  switch (nexthop->type)
+#ifdef HAVE_IPV6
+	  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
+            {
+              if (!IPV6_ADDR_SAME(&nexthop->src.ipv6, &in6addr_any))
+                {
+		  if (inet_ntop(AF_INET6, &nexthop->src.ipv6, addrstr,
+		      sizeof addrstr))
+                    vty_out (vty, ", src %s", addrstr);
+                }
+            }
+	  else
+#endif /* HAVE_IPV6 */
+          if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
 	    {
-	    case NEXTHOP_TYPE_IPV4:
-	    case NEXTHOP_TYPE_IPV4_IFINDEX:
 	      vty_out (vty, " %s", inet_ntoa (nexthop->gate.ipv4));
-	      if (nexthop->ifindex)
-		vty_out (vty, ", via %s", ifindex2ifname (nexthop->ifindex));
-	      break;
-	    case NEXTHOP_TYPE_IFINDEX:
+	      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
+		vty_out (vty, ", via %s", nexthop->ifname);
+	      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
+	        if (if_lookup_by_index(nexthop->ifindex))
+		  vty_out (vty, ", via %s", ifindex2ifname(nexthop->ifindex));
+
+              if (nexthop->src.ipv4.s_addr)
+                {
+		  if (inet_ntop(AF_INET, &nexthop->src.ipv4, addrstr,
+		      sizeof addrstr))
+                    vty_out (vty, ", src %s", addrstr);
+                }
+	    }
+	  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
+	    {
+	      vty_out (vty, " directly connected, %s", nexthop->ifname);
+	    }
+	  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
+	    {
 	      vty_out (vty, " directly connected, %s",
 		       ifindex2ifname (nexthop->ifindex));
-	      break;
-	    case NEXTHOP_TYPE_IFNAME:
-	      vty_out (vty, " directly connected, %s", nexthop->ifname);
-	      break;
-      case NEXTHOP_TYPE_BLACKHOLE:
-        vty_out (vty, " directly connected, Null0");
-        break;
-      default:
-	      break;
 	    }
+	  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_DROP))
+	    {
+	      switch (nexthop->drop)
+		{
+		  case ZEBRA_DROP_NULL:
+		    vty_out (vty, " directly connected, Null0");
+		    break;
+		  case ZEBRA_DROP_REJECT:
+		    vty_out (vty, ", reject");
+		    break;
+		  case ZEBRA_DROP_BLACKHOLE:
+		    vty_out (vty, ", blackhole");
+		    break;
+		  default:
+		    assert(0);
+		}
+	    }
+#ifdef HAVE_MPLS
+	  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_MPLS))
+	    {
+	      struct zmpls_out_segment *out;
+	      char buf[16];
+
+	      out = mpls_out_segment_find(nexthop->mpls);
+	      if (out)
+		mpls_print_label(&out->nh.mpls, buf);
+	      else
+		strcpy(buf, "not found");
+	      vty_out (vty, " (label %s)", buf);
+	    }
+#endif
 	  if (! CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE))
 	    vty_out (vty, " inactive");
 
@@ -616,48 +1321,48 @@ vty_show_ip_route_detail (struct vty *vty, struct route_node *rn)
 	    {
 	      vty_out (vty, " (recursive");
 		
-	      switch (nexthop->rtype)
+#ifdef HAVE_IPV6
+	      if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV6))
+                {
+                  if (!IPV6_ADDR_SAME(&nexthop->src.ipv6, &in6addr_any))
+                    {
+		      if (inet_ntop(AF_INET6, &nexthop->src.ipv6, addrstr,
+		          sizeof addrstr))
+                        vty_out (vty, ", src %s", addrstr);
+                    }
+                }
+	      else
+#endif /* HAVE_IPV6 */
+	      if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV4))
 		{
-		case NEXTHOP_TYPE_IPV4:
-		case NEXTHOP_TYPE_IPV4_IFINDEX:
 		  vty_out (vty, " via %s)", inet_ntoa (nexthop->rgate.ipv4));
-		  break;
-		case NEXTHOP_TYPE_IFINDEX:
-		case NEXTHOP_TYPE_IFNAME:
+                  if (nexthop->src.ipv4.s_addr)
+                    {
+		      if (inet_ntop(AF_INET, &nexthop->src.ipv4, addrstr,
+		          sizeof addrstr))
+                        vty_out (vty, ", src %s", addrstr);
+                    }
+		}
+	      else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IFINDEX))
+		{
 		  vty_out (vty, " is directly connected, %s)",
 			   ifindex2ifname (nexthop->rifindex));
-		  break;
-		default:
-		  break;
 		}
+#ifdef HAVE_MPLS
+	      if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_MPLS))
+		{
+		  struct zmpls_out_segment *out;
+		  char buf[16];
+
+		  out = mpls_out_segment_find(nexthop->rmpls);
+		  if (out)
+		    mpls_print_label(&out->nh.mpls, buf);
+		  else
+		    strcpy(buf, "not found");
+		  vty_out (vty, " (label %s)", buf);
+		}
+#endif
 	    }
-	  switch (nexthop->type)
-            {
-            case NEXTHOP_TYPE_IPV4:
-            case NEXTHOP_TYPE_IPV4_IFINDEX:
-            case NEXTHOP_TYPE_IPV4_IFNAME:
-              if (nexthop->src.ipv4.s_addr)
-                {
-		  if (inet_ntop(AF_INET, &nexthop->src.ipv4, addrstr,
-		      sizeof addrstr))
-                    vty_out (vty, ", src %s", addrstr);
-                }
-              break;
-#ifdef HAVE_IPV6
-            case NEXTHOP_TYPE_IPV6:
-            case NEXTHOP_TYPE_IPV6_IFINDEX:
-            case NEXTHOP_TYPE_IPV6_IFNAME:
-              if (!IPV6_ADDR_SAME(&nexthop->src.ipv6, &in6addr_any))
-                {
-		  if (inet_ntop(AF_INET6, &nexthop->src.ipv6, addrstr,
-		      sizeof addrstr))
-                    vty_out (vty, ", src %s", addrstr);
-                }
-              break;
-#endif /* HAVE_IPV6 */
-            default:
-	       break;
-            }
 	  vty_out (vty, "%s", VTY_NEWLINE);
 	}
       vty_out (vty, "%s", VTY_NEWLINE);
@@ -674,6 +1379,9 @@ vty_show_ip_route (struct vty *vty, struct route_node *rn, struct rib *rib)
   /* Nexthop information. */
   for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
     {
+      if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_IGNORE))
+         continue;
+
       if (nexthop == rib->nexthop)
 	{
 	  /* Prefix information. */
@@ -698,27 +1406,72 @@ vty_show_ip_route (struct vty *vty, struct route_node *rn, struct rib *rib)
 		 ? '*' : ' ',
 		 len - 3, ' ');
 
-      switch (nexthop->type)
+#ifdef HAVE_IPV6
+      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
+        {
+          if (!IPV6_ADDR_SAME(&nexthop->src.ipv6, &in6addr_any))
+            {
+	      if (inet_ntop(AF_INET6, &nexthop->src.ipv6, buf, sizeof buf))
+                vty_out (vty, ", src %s", buf);
+            }
+        }
+      else
+#endif /* HAVE_IPV6 */
+      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
 	{
-	case NEXTHOP_TYPE_IPV4:
-	case NEXTHOP_TYPE_IPV4_IFINDEX:
 	  vty_out (vty, " via %s", inet_ntoa (nexthop->gate.ipv4));
-	  if (nexthop->ifindex)
-	    vty_out (vty, ", %s", ifindex2ifname (nexthop->ifindex));
-	  break;
-	case NEXTHOP_TYPE_IFINDEX:
+          if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
+	    vty_out (vty, ", %s", nexthop->ifname);
+          else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
+	    if (if_lookup_by_index(nexthop->ifindex))
+	      vty_out (vty, ", %s", ifindex2ifname (nexthop->ifindex));
+
+          if (nexthop->src.ipv4.s_addr)
+            {
+	      if (inet_ntop(AF_INET, &nexthop->src.ipv4, buf, sizeof buf))
+                vty_out (vty, ", src %s", buf);
+            }
+	}
+      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
+	{
+	  vty_out (vty, " is directly connected, %s", nexthop->ifname);
+	}
+      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
+	{
 	  vty_out (vty, " is directly connected, %s",
 		   ifindex2ifname (nexthop->ifindex));
-	  break;
-	case NEXTHOP_TYPE_IFNAME:
-	  vty_out (vty, " is directly connected, %s", nexthop->ifname);
-	  break;
-  case NEXTHOP_TYPE_BLACKHOLE:
-    vty_out (vty, " is directly connected, Null0");
-    break;
-  default:
-	  break;
 	}
+      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_DROP))
+	{
+	  switch (nexthop->drop)
+	    {
+	      case ZEBRA_DROP_NULL:
+		vty_out (vty, " directly connected, Null0");
+		break;
+	      case ZEBRA_DROP_REJECT:
+		vty_out (vty, ", reject");
+		break;
+	      case ZEBRA_DROP_BLACKHOLE:
+		vty_out (vty, ", blackhole");
+		break;
+	      default:
+		assert(0);
+	    }
+	}
+#ifdef HAVE_MPLS
+      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_MPLS))
+	{
+	  struct zmpls_out_segment *out;
+	  char buf[16];
+
+	  out = mpls_out_segment_find(nexthop->mpls);
+	  if (out)
+	    mpls_print_label(&out->nh.mpls, buf);
+	  else
+	    strcpy(buf, "not found");
+	  vty_out (vty, " (label %s)", buf);
+	}
+#endif
       if (! CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE))
 	vty_out (vty, " inactive");
 
@@ -726,46 +1479,53 @@ vty_show_ip_route (struct vty *vty, struct route_node *rn, struct rib *rib)
 	{
 	  vty_out (vty, " (recursive");
 		
-	  switch (nexthop->rtype)
+#ifdef HAVE_IPV6
+	  if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV6))
+            {
+              if (!IPV6_ADDR_SAME(&nexthop->src.ipv6, &in6addr_any))
+                {
+		  if (inet_ntop(AF_INET6, &nexthop->src.ipv6, buf, sizeof buf))
+                    vty_out (vty, ", src %s", buf);
+                }
+            }
+          else
+#endif /* HAVE_IPV6 */
+	  if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV4))
+	    {
+	      vty_out (vty, " via %s", inet_ntoa (nexthop->rgate.ipv4));
+	      if (nexthop->rifindex)
+		vty_out (vty, ", %s", ifindex2ifname (nexthop->rifindex));
+	      vty_out (vty, ")");
+
+              if (nexthop->src.ipv4.s_addr)
+                {
+	          if (inet_ntop(AF_INET, &nexthop->src.ipv4, buf, sizeof buf))
+                    vty_out (vty, ", src %s", buf);
+                }
+	    }
+	  else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IFINDEX))
 	    {
-	    case NEXTHOP_TYPE_IPV4:
-	    case NEXTHOP_TYPE_IPV4_IFINDEX:
-	      vty_out (vty, " via %s)", inet_ntoa (nexthop->rgate.ipv4));
-	      break;
-	    case NEXTHOP_TYPE_IFINDEX:
-	    case NEXTHOP_TYPE_IFNAME:
 	      vty_out (vty, " is directly connected, %s)",
 		       ifindex2ifname (nexthop->rifindex));
-	      break;
-	    default:
-	      break;
 	    }
+#ifdef HAVE_MPLS
+	  if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_MPLS))
+	    {
+	      struct zmpls_out_segment *out;
+	      char buf[16];
+
+	      out = mpls_out_segment_find(nexthop->rmpls);
+	      if (out)
+		mpls_print_label(&out->nh.mpls, buf);
+	      else
+		strcpy(buf, "not found");
+	      vty_out (vty, " (label %s)", buf);
+	    }
+#endif
 	}
-      switch (nexthop->type)
-        {
-          case NEXTHOP_TYPE_IPV4:
-          case NEXTHOP_TYPE_IPV4_IFINDEX:
-          case NEXTHOP_TYPE_IPV4_IFNAME:
-            if (nexthop->src.ipv4.s_addr)
-              {
-		if (inet_ntop(AF_INET, &nexthop->src.ipv4, buf, sizeof buf))
-                  vty_out (vty, ", src %s", buf);
-              }
-            break;
-#ifdef HAVE_IPV6
-          case NEXTHOP_TYPE_IPV6:
-          case NEXTHOP_TYPE_IPV6_IFINDEX:
-          case NEXTHOP_TYPE_IPV6_IFNAME:
-            if (!IPV6_ADDR_SAME(&nexthop->src.ipv6, &in6addr_any))
-              {
-		if (inet_ntop(AF_INET6, &nexthop->src.ipv6, buf, sizeof buf))
-                  vty_out (vty, ", src %s", buf);
-              }
-            break;
-#endif /* HAVE_IPV6 */
-          default:
-	    break;
-        }
+
+      if (nexthop->advmss)
+        vty_out (vty, " advmss %d", nexthop->advmss);
 
       if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_BLACKHOLE))
                vty_out (vty, ", bh");
@@ -954,6 +1714,8 @@ DEFUN (show_ip_route_protocol,
     type = ZEBRA_ROUTE_RIP;
   else if (strncmp (argv[0], "s", 1) == 0)
     type = ZEBRA_ROUTE_STATIC;
+  else if (strncmp (argv[0], "l", 1) == 0)
+    type = ZEBRA_ROUTE_LDP;
   else 
     {
       vty_out (vty, "Unknown route type%s", VTY_NEWLINE);
@@ -1111,7 +1873,7 @@ static int
 static_config_ipv4 (struct vty *vty)
 {
   struct route_node *rn;
-  struct static_ipv4 *si;  
+  struct static_route *si;  
   struct route_table *stable;
   int write;
 
@@ -1128,32 +1890,51 @@ static_config_ipv4 (struct vty *vty)
         vty_out (vty, "ip route %s/%d", inet_ntoa (rn->p.u.prefix4),
                  rn->p.prefixlen);
 
-        switch (si->type)
-          {
-            case STATIC_IPV4_GATEWAY:
-              vty_out (vty, " %s", inet_ntoa (si->gate.ipv4));
-              break;
-            case STATIC_IPV4_IFNAME:
-              vty_out (vty, " %s", si->gate.ifname);
-              break;
-            case STATIC_IPV4_BLACKHOLE:
-              vty_out (vty, " Null0");
-              break;
-          }
+        if (CHECK_FLAG(si->nh.type, ZEBRA_NEXTHOP_DROP))
+	  switch(si->nh.gw.drop)
+	    {
+	      case ZEBRA_DROP_NULL:
+		vty_out (vty, " Null0");
+		break;
+	      case ZEBRA_DROP_REJECT:
+		vty_out (vty, " %s", "reject");
+		break;
+	      case ZEBRA_DROP_BLACKHOLE:
+		vty_out (vty, " %s", "blackhole");
+		break;
+	      default:
+		assert(0);
+	    }
+	else
+	  {
+	    if (CHECK_FLAG(si->nh.type, ZEBRA_NEXTHOP_IPV4))
+	      vty_out (vty, " %s", inet_ntoa (si->nh.gw.ipv4));
+	    if (CHECK_FLAG(si->nh.type, ZEBRA_NEXTHOP_IFNAME))
+	      vty_out (vty, " %s", si->nh.intf.name);
+#ifdef HAVE_MPLS
+	    if (CHECK_FLAG(si->nh.type, ZEBRA_NEXTHOP_MPLS))
+	      {
+		int index = mpls_out_segment_find_index_by_nexthop(&si->nh);
+		vty_out (vty, " ");
+		if (index)
+		  {
+		    mpls_out_segment_config_write (vty,
+		      mpls_out_segment_find(index));
+		  }
+		else
+		  {
+		    vty_out (vty, "(unknown)");
+		  }
+	      }
+#endif
+	  }
         
-        /* flags are incompatible with STATIC_IPV4_BLACKHOLE */
-        if (si->type != STATIC_IPV4_BLACKHOLE)
-          {
-            if (CHECK_FLAG(si->flags, ZEBRA_FLAG_REJECT))
-              vty_out (vty, " %s", "reject");
-
-            if (CHECK_FLAG(si->flags, ZEBRA_FLAG_BLACKHOLE))
-              vty_out (vty, " %s", "blackhole");
-          }
-
         if (si->distance != ZEBRA_STATIC_DISTANCE_DEFAULT)
           vty_out (vty, " %d", si->distance);
 
+        if (si->nh.advmss)
+	  vty_out (vty, " advmss %d", si->nh.advmss);
+
         vty_out (vty, "%s", VTY_NEWLINE);
 
         write = 1;
@@ -1201,11 +1982,11 @@ static_ipv6_func (struct vty *vty, int add_cmd, const char *dest_str,
   int ret;
   u_char distance;
   struct prefix p;
-  struct in6_addr *gate = NULL;
   struct in6_addr gate_addr;
-  u_char type = 0;
+  struct zapi_nexthop nh;
   int table = 0;
-  u_char flag = 0;
+
+  memset(&nh, 0, sizeof(struct zapi_nexthop));
   
   ret = str2prefix (dest_str, &p);
   if (ret <= 0)
@@ -1222,11 +2003,13 @@ static_ipv6_func (struct vty *vty, int add_cmd, const char *dest_str,
     switch(flag_str[0]) {
       case 'r':
       case 'R': /* XXX */
-        SET_FLAG (flag, ZEBRA_FLAG_REJECT);
+        SET_FLAG (nh.type, ZEBRA_NEXTHOP_DROP);
+	nh.gw.drop = ZEBRA_DROP_REJECT;
         break;
       case 'b':
       case 'B': /* XXX */
-        SET_FLAG (flag, ZEBRA_FLAG_BLACKHOLE);
+        SET_FLAG (nh.type, ZEBRA_NEXTHOP_DROP);
+	nh.gw.drop = ZEBRA_DROP_BLACKHOLE;
         break;
       default:
         vty_out (vty, "%% Malformed flag %s %s", flag_str, VTY_NEWLINE);
@@ -1253,27 +2036,30 @@ static_ipv6_func (struct vty *vty, int add_cmd, const char *dest_str,
 	  vty_out (vty, "%% Malformed address%s", VTY_NEWLINE);
 	  return CMD_WARNING;
 	}
-      type = STATIC_IPV6_GATEWAY_IFNAME;
-      gate = &gate_addr;
+
+      SET_FLAG (nh.type, ZEBRA_NEXTHOP_IPV6);
+      SET_FLAG (nh.type, ZEBRA_NEXTHOP_IFNAME);
+      nh.gw.ipv6 = gate_addr;
+      strncpy(nh.intf.name, ifname, IFNAMSIZ);
     }
   else
     {
       if (ret == 1)
 	{
-	  type = STATIC_IPV6_GATEWAY;
-	  gate = &gate_addr;
+	  SET_FLAG (nh.type, ZEBRA_NEXTHOP_IPV6);
+	  nh.gw.ipv6 = gate_addr;
 	}
       else
 	{
-	  type = STATIC_IPV6_IFNAME;
-	  ifname = gate_str;
+	  SET_FLAG (nh.type, ZEBRA_NEXTHOP_IFNAME);
+	  strncpy(nh.intf.name, gate_str, IFNAMSIZ);
 	}
     }
 
   if (add_cmd)
-    static_add_ipv6 (&p, type, gate, ifname, flag, distance, table);
+    static_add_route (&p, &nh, distance, table);
   else
-    static_delete_ipv6 (&p, type, gate, ifname, distance, table);
+    static_delete_route (&p, &nh, distance, table);
 
   return CMD_SUCCESS;
 }
@@ -1290,6 +2076,20 @@ DEFUN (ipv6_route,
   return static_ipv6_func (vty, 1, argv[0], argv[1], NULL, NULL, NULL);
 }
 
+DEFUN (ipv6_route_advmss,
+       ipv6_route_advmss_cmd,
+       "ipv6 route X:X::X:X/M (X:X::X:X|INTERFACE) advmss <0-65495>",
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "IPv6 gateway address\n"
+       "IPv6 gateway interface name\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return static_ipv6_func (vty, 1, argv[0], argv[1], NULL, NULL, NULL);
+}
+
 DEFUN (ipv6_route_flags,
        ipv6_route_flags_cmd,
        "ipv6 route X:X::X:X/M (X:X::X:X|INTERFACE) (reject|blackhole)",
@@ -1316,6 +2116,20 @@ DEFUN (ipv6_route_ifname,
   return static_ipv6_func (vty, 1, argv[0], argv[1], argv[2], NULL, NULL);
 }
 
+DEFUN (ipv6_route_ifname_advmss,
+       ipv6_route_ifname_advmss_cmd,
+       "ipv6 route X:X::X:X/M X:X::X:X INTERFACE advmss <0-65495>",
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "IPv6 gateway address\n"
+       "IPv6 gateway interface name\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return static_ipv6_func (vty, 1, argv[0], argv[1], argv[2], NULL, NULL);
+}
+
 DEFUN (ipv6_route_ifname_flags,
        ipv6_route_ifname_flags_cmd,
        "ipv6 route X:X::X:X/M X:X::X:X INTERFACE (reject|blackhole)",
@@ -1343,6 +2157,21 @@ DEFUN (ipv6_route_pref,
   return static_ipv6_func (vty, 1, argv[0], argv[1], NULL, NULL, argv[2]);
 }
 
+DEFUN (ipv6_route_pref_advmss,
+       ipv6_route_pref_advmss_cmd,
+       "ipv6 route X:X::X:X/M (X:X::X:X|INTERFACE) <1-255> advmss <0-65495>",
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "IPv6 gateway address\n"
+       "IPv6 gateway interface name\n"
+       "Distance value for this prefix\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return static_ipv6_func (vty, 1, argv[0], argv[1], NULL, NULL, argv[2]);
+}
+
 DEFUN (ipv6_route_flags_pref,
        ipv6_route_flags_pref_cmd,
        "ipv6 route X:X::X:X/M (X:X::X:X|INTERFACE) (reject|blackhole) <1-255>",
@@ -1371,6 +2200,21 @@ DEFUN (ipv6_route_ifname_pref,
   return static_ipv6_func (vty, 1, argv[0], argv[1], argv[2], NULL, argv[3]);
 }
 
+DEFUN (ipv6_route_ifname_pref_advmss,
+       ipv6_route_ifname_pref_advmss_cmd,
+       "ipv6 route X:X::X:X/M X:X::X:X INTERFACE <1-255> advmss <0-65495>",
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "IPv6 gateway address\n"
+       "IPv6 gateway interface name\n"
+       "Distance value for this prefix\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return static_ipv6_func (vty, 1, argv[0], argv[1], argv[2], NULL, argv[3]);
+}
+
 DEFUN (ipv6_route_ifname_flags_pref,
        ipv6_route_ifname_flags_pref_cmd,
        "ipv6 route X:X::X:X/M X:X::X:X INTERFACE (reject|blackhole) <1-255>",
@@ -1399,6 +2243,21 @@ DEFUN (no_ipv6_route,
   return static_ipv6_func (vty, 0, argv[0], argv[1], NULL, NULL, NULL);
 }
 
+DEFUN (no_ipv6_route_advmss,
+       no_ipv6_route_advmss_cmd,
+       "no ipv6 route X:X::X:X/M (X:X::X:X|INTERFACE) advmss <0-65495>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "IPv6 gateway address\n"
+       "IPv6 gateway interface name\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return static_ipv6_func (vty, 0, argv[0], argv[1], NULL, NULL, NULL);
+}
+
 ALIAS (no_ipv6_route,
        no_ipv6_route_flags_cmd,
        "no ipv6 route X:X::X:X/M (X:X::X:X|INTERFACE) (reject|blackhole)",
@@ -1424,6 +2283,21 @@ DEFUN (no_ipv6_route_ifname,
   return static_ipv6_func (vty, 0, argv[0], argv[1], argv[2], NULL, NULL);
 }
 
+DEFUN (no_ipv6_route_ifname_advmss,
+       no_ipv6_route_ifname_advmss_cmd,
+       "no ipv6 route X:X::X:X/M X:X::X:X INTERFACE advmss <0-65495>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "IPv6 gateway address\n"
+       "IPv6 gateway interface name\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return static_ipv6_func (vty, 0, argv[0], argv[1], argv[2], NULL, NULL);
+}
+
 ALIAS (no_ipv6_route_ifname,
        no_ipv6_route_ifname_flags_cmd,
        "no ipv6 route X:X::X:X/M X:X::X:X INTERFACE (reject|blackhole)",
@@ -1450,6 +2324,22 @@ DEFUN (no_ipv6_route_pref,
   return static_ipv6_func (vty, 0, argv[0], argv[1], NULL, NULL, argv[2]);
 }
 
+DEFUN (no_ipv6_route_pref_advmss,
+       no_ipv6_route_pref_advmss_cmd,
+       "no ipv6 route X:X::X:X/M (X:X::X:X|INTERFACE) <1-255> advmss <0-65495>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "IPv6 gateway address\n"
+       "IPv6 gateway interface name\n"
+       "Distance value for this prefix\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return static_ipv6_func (vty, 0, argv[0], argv[1], NULL, NULL, argv[2]);
+}
+
 DEFUN (no_ipv6_route_flags_pref,
        no_ipv6_route_flags_pref_cmd,
        "no ipv6 route X:X::X:X/M (X:X::X:X|INTERFACE) (reject|blackhole) <1-255>",
@@ -1481,6 +2371,22 @@ DEFUN (no_ipv6_route_ifname_pref,
   return static_ipv6_func (vty, 0, argv[0], argv[1], argv[2], NULL, argv[3]);
 }
 
+DEFUN (no_ipv6_route_ifname_pref_advmss,
+       no_ipv6_route_ifname_pref_advmss_cmd,
+       "no ipv6 route X:X::X:X/M X:X::X:X INTERFACE <1-255> advmss <0-65495>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "IPv6 gateway address\n"
+       "IPv6 gateway interface name\n"
+       "Distance value for this prefix\n"
+       "Advertised MSS\n"
+       "Maximum TCP Segment Size\n")
+{
+  return static_ipv6_func (vty, 0, argv[0], argv[1], argv[2], NULL, argv[3]);
+}
+
 DEFUN (no_ipv6_route_ifname_flags_pref,
        no_ipv6_route_ifname_flags_pref_cmd,
        "no ipv6 route X:X::X:X/M X:X::X:X INTERFACE (reject|blackhole) <1-255>",
@@ -1497,6 +2403,195 @@ DEFUN (no_ipv6_route_ifname_flags_pref,
   return static_ipv6_func (vty, 0, argv[0], argv[1], argv[2], argv[3], argv[4]);
 }
 
+#ifdef HAVE_MPLS
+static int
+static_ipv6_func_mpls (struct vty *vty, int add_cmd, const char *dest,
+  const char *addr, const char *distance, const char **argv)
+{
+  struct zmpls_out_segment out;
+  int result;
+
+  memset (&out, 0, sizeof (out));
+  out.owner = ZEBRA_ROUTE_STATIC;
+  result = nhlfe_parse (vty, argv, &out, addr);
+  if (result != CMD_SUCCESS)
+    return result;
+
+  out.index = mpls_out_segment_find_index_by_nhlfe(&out);
+
+  if (add_cmd)
+  {
+    if (out.index)
+    {
+      vty_out(vty, "NHLFE already exists%s",VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+
+    if ((result = mpls_out_segment_register (&out)))
+    {
+      vty_out(vty, "Unable to register NHLFE(%d)%s",result, VTY_NEWLINE);
+      return CMD_WARNING;
+    }
+  }
+
+  result = static_ipv6_func (vty, add_cmd, dest, NULL, NULL, NULL, distance);
+
+  if (add_cmd)
+  {
+    if (result != CMD_SUCCESS)
+    {
+      mpls_out_segment_unregister_by_index (out.index);
+      return CMD_WARNING;
+    }
+  }
+  else
+  {
+    mpls_out_segment_unregister_by_index (out.index);
+  }
+  return CMD_SUCCESS;
+}
+
+DEFUN (ipv6_route_mpls,
+       ipv6_route_mpls_cmd,
+       "ipv6 route X:X::X:X/M (gen|atm|fr) VALUE nexthop INTERFACE",
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IPv6 gateway interface name\n")
+{
+  return static_ipv6_func_mpls (vty, 1, argv[0], NULL, NULL, &argv[1]);
+}
+
+DEFUN (ipv6_route_mpls_addr,
+       ipv6_route_mpls_addr_cmd,
+       "ipv6 route X:X::X:X/M (gen|atm|fr) VALUE nexthop INTERFACE ADDR",
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IPv6 gateway interface name\n"
+       "IPv6 gateway address\n")
+{
+  return static_ipv6_func_mpls (vty, 1, argv[0], argv[4], NULL, &argv[1]);
+}
+
+DEFUN (ipv6_route_mpls_pref,
+       ipv6_route_mpls_pref_cmd,
+       "ipv6 route X:X::X:X/M (gen|atm|fr) VALUE nexthop INTERFACE <1-255>",
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IPv6 gateway interface name\n"
+       "Distance value for this prefix\n")
+{
+  return static_ipv6_func_mpls (vty, 1, argv[0], NULL, argv[4], &argv[1]);
+}
+
+DEFUN (ipv6_route_mpls_pref_addr,
+       ipv6_route_mpls_pref_addr_cmd,
+       "ipv6 route X:X::X:X/M (gen|atm|fr) VALUE nexthop INTERFACE ADDR <1-255>",
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IPv6 gateway interface name\n"
+       "IPv6 gateway address\n"
+       "Distance value for this prefix\n")
+{
+  return static_ipv6_func_mpls (vty, 1, argv[0], argv[4], argv[5], &argv[1]);
+}
+
+DEFUN (no_ipv6_route_mpls,
+       no_ipv6_route_mpls_cmd,
+       "no ipv6 route X:X::X:X/M (gen|atm|fr) VALUE nexthop INTERFACE",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IPv6 gateway interface name\n")
+{
+  return static_ipv6_func_mpls (vty, 0, argv[0], NULL, NULL, &argv[1]);
+}
+
+DEFUN (no_ipv6_route_mpls_addr,
+       no_ipv6_route_mpls_addr_cmd,
+       "no ipv6 route X:X::X:X/M (gen|atm|fr) VALUE nexthop INTERFACE ADDR",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IPv6 gateway interface name\n"
+       "IPv6 gateway address\n")
+{
+  return static_ipv6_func_mpls (vty, 0, argv[0], argv[4], NULL, &argv[1]);
+}
+
+DEFUN (no_ipv6_route_mpls_pref,
+       no_ipv6_route_mpls_pref_cmd,
+       "no ipv6 route X:X::X:X/M (gen|atm|fr) VALUE nexthop INTERFACE <1-255>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IPv6 gateway interface name\n"
+       "Distance value for this prefix\n")
+{
+  return static_ipv6_func_mpls (vty, 0, argv[0], NULL, argv[4], &argv[1]);
+}
+
+DEFUN (no_ipv6_route_mpls_pref_addr,
+       no_ipv6_route_mpls_pref_addr_cmd,
+       "no ipv6 route X:X::X:X/M (gen|atm|fr) VALUE nexthop INTERFACE ADDR <1-255>",
+       NO_STR
+       IP_STR
+       "Establish static routes\n"
+       "IPv6 destination prefix (e.g. 3ffe:506::/32)\n"
+       "Out-going generic MPLS label (16 - 2^20-1)\n"
+       "Out-going ATM MPLS label (VPI/VCI)\n"
+       "Out-going Frame Relay MPLS label (16 - 2^17-1)\n"
+       "Out-going label value\n"
+       "Nexthop\n"
+       "IPv6 gateway interface name\n"
+       "IPv6 gateway address\n"
+       "Distance value for this prefix\n")
+{
+  return static_ipv6_func_mpls (vty, 0, argv[0], argv[4], argv[5], &argv[1]);
+}
+#endif /* HAVE_MPLS */
+
 /* New RIB.  Detailed information for IPv6 route. */
 static void
 vty_show_ipv6_route_detail (struct vty *vty, struct route_node *rn)
@@ -1554,32 +2649,63 @@ vty_show_ipv6_route_detail (struct vty *vty, struct route_node *rn)
 
       for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
 	{
+           if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_IGNORE))
+              continue;
+
 	  vty_out (vty, "  %c",
 		   CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB) ? '*' : ' ');
 
-	  switch (nexthop->type)
+	  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
 	    {
-	    case NEXTHOP_TYPE_IPV6:
-	    case NEXTHOP_TYPE_IPV6_IFINDEX:
-	    case NEXTHOP_TYPE_IPV6_IFNAME:
 	      vty_out (vty, " %s",
 		       inet_ntop (AF_INET6, &nexthop->gate.ipv6, buf, BUFSIZ));
-	      if (nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME)
+	      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
 		vty_out (vty, ", %s", nexthop->ifname);
 	      else if (nexthop->ifindex)
 		vty_out (vty, ", via %s", ifindex2ifname (nexthop->ifindex));
-	      break;
-	    case NEXTHOP_TYPE_IFINDEX:
+	    }
+	  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
+	    {
 	      vty_out (vty, " directly connected, %s",
 		       ifindex2ifname (nexthop->ifindex));
-	      break;
-	    case NEXTHOP_TYPE_IFNAME:
+	    }
+	  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
+	    {
 	      vty_out (vty, " directly connected, %s",
 		       nexthop->ifname);
-	      break;
-	    default:
-	      break;
 	    }
+	  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_DROP))
+	    {
+	      switch (nexthop->drop)
+		{
+		  case ZEBRA_DROP_NULL:
+		    vty_out (vty, " directly connected, Null0");
+		    break;
+		  case ZEBRA_DROP_REJECT:
+		    vty_out (vty, ", reject");
+		    break;
+		  case ZEBRA_DROP_BLACKHOLE:
+		    vty_out (vty, ", blackhole");
+		    break;
+		  default:
+		    assert(0);
+		}
+	    }
+#ifdef HAVE_MPLS
+          if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_MPLS))
+            {
+              struct zmpls_out_segment *out;
+              char buf[16];
+
+              out = mpls_out_segment_find(nexthop->mpls);
+              if (out)
+                mpls_print_label(&out->nh.mpls, buf);
+              else
+                strcpy(buf, "not found");
+              vty_out (vty, " (label %s)", buf);
+           }
+#endif
+
 	  if (! CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE))
 	    vty_out (vty, " inactive");
 
@@ -1587,26 +2713,38 @@ vty_show_ipv6_route_detail (struct vty *vty, struct route_node *rn)
 	    {
 	      vty_out (vty, " (recursive");
 		
-	      switch (nexthop->rtype)
+	      if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV6))
 		{
-		case NEXTHOP_TYPE_IPV6:
-		case NEXTHOP_TYPE_IPV6_IFINDEX:
-		case NEXTHOP_TYPE_IPV6_IFNAME:
-		  vty_out (vty, " via %s)",
+		  vty_out (vty, " via %s",
 			   inet_ntop (AF_INET6, &nexthop->rgate.ipv6,
 				      buf, BUFSIZ));
 		  if (nexthop->rifindex)
 		    vty_out (vty, ", %s", ifindex2ifname (nexthop->rifindex));
-		  break;
-		case NEXTHOP_TYPE_IFINDEX:
-		case NEXTHOP_TYPE_IFNAME:
+		  vty_out (vty, ")");
+		}
+	      else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV6))
+		{
 		  vty_out (vty, " is directly connected, %s)",
 			   ifindex2ifname (nexthop->rifindex));
-		  break;
-		default:
-		  break;
 		}
+#ifdef HAVE_MPLS
+              if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_MPLS))
+                {
+                  struct zmpls_out_segment *out;
+                  char buf[16];
+
+                  out = mpls_out_segment_find(nexthop->rmpls);
+                  if (out)
+                    mpls_print_label(&out->nh.mpls, buf);
+                  else
+                    strcpy(buf, "not found");
+                  vty_out (vty, " (label %s)", buf);
+                }
+#endif
 	    }
+          if (nexthop->advmss)
+            vty_out (vty, " advmss %d", nexthop->advmss);
+
 	  vty_out (vty, "%s", VTY_NEWLINE);
 	}
       vty_out (vty, "%s", VTY_NEWLINE);
@@ -1624,8 +2762,12 @@ vty_show_ipv6_route (struct vty *vty, struct route_node *rn,
   /* Nexthop information. */
   for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
     {
+      if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_IGNORE))
+         continue;
+
       if (nexthop == rib->nexthop)
 	{
+
 	  /* Prefix information. */
 	  len = vty_out (vty, "%c%c%c %s/%d",
 			 zebra_route_char (rib->type),
@@ -1648,29 +2790,40 @@ vty_show_ipv6_route (struct vty *vty, struct route_node *rn,
 		 ? '*' : ' ',
 		 len - 3, ' ');
 
-      switch (nexthop->type)
+      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
 	{
-	case NEXTHOP_TYPE_IPV6:
-	case NEXTHOP_TYPE_IPV6_IFINDEX:
-	case NEXTHOP_TYPE_IPV6_IFNAME:
 	  vty_out (vty, " via %s",
 		   inet_ntop (AF_INET6, &nexthop->gate.ipv6, buf, BUFSIZ));
-	  if (nexthop->type == NEXTHOP_TYPE_IPV6_IFNAME)
+	  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
 	    vty_out (vty, ", %s", nexthop->ifname);
 	  else if (nexthop->ifindex)
 	    vty_out (vty, ", %s", ifindex2ifname (nexthop->ifindex));
-	  break;
-	case NEXTHOP_TYPE_IFINDEX:
+	}
+      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
+	{
 	  vty_out (vty, " is directly connected, %s",
 		   ifindex2ifname (nexthop->ifindex));
-	  break;
-	case NEXTHOP_TYPE_IFNAME:
+	}
+      else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
+	{
 	  vty_out (vty, " is directly connected, %s",
 		   nexthop->ifname);
-	  break;
-	default:
-	  break;
 	}
+#ifdef HAVE_MPLS
+      if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_MPLS))
+        {
+          struct zmpls_out_segment *out;
+          char buf[16];
+
+          out = mpls_out_segment_find(nexthop->mpls);
+          if (out)
+            mpls_print_label(&out->nh.mpls, buf);
+          else
+            strcpy(buf, "not found");
+          vty_out (vty, " (label %s)", buf);
+       }
+#endif
+
       if (! CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE))
 	vty_out (vty, " inactive");
 
@@ -1678,32 +2831,57 @@ vty_show_ipv6_route (struct vty *vty, struct route_node *rn,
 	{
 	  vty_out (vty, " (recursive");
 		
-	  switch (nexthop->rtype)
+	  if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IPV6))
 	    {
-	    case NEXTHOP_TYPE_IPV6:
-	    case NEXTHOP_TYPE_IPV6_IFINDEX:
-	    case NEXTHOP_TYPE_IPV6_IFNAME:
-	      vty_out (vty, " via %s)",
+	      vty_out (vty, " via %s",
 		       inet_ntop (AF_INET6, &nexthop->rgate.ipv6,
 				  buf, BUFSIZ));
 	      if (nexthop->rifindex)
 		vty_out (vty, ", %s", ifindex2ifname (nexthop->rifindex));
-	      break;
-	    case NEXTHOP_TYPE_IFINDEX:
-	    case NEXTHOP_TYPE_IFNAME:
+	      vty_out (vty, ")");
+	    }
+	  else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_IFINDEX))
+	    {
 	      vty_out (vty, " is directly connected, %s)",
 		       ifindex2ifname (nexthop->rifindex));
-	      break;
-	    default:
-	      break;
 	    }
+	  else if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_DROP))
+	    {
+	      switch (nexthop->drop)
+		{
+		  case ZEBRA_DROP_NULL:
+		    vty_out (vty, " directly connected, Null0");
+		    break;
+		  case ZEBRA_DROP_REJECT:
+		    vty_out (vty, ", reject");
+		    break;
+		  case ZEBRA_DROP_BLACKHOLE:
+		    vty_out (vty, ", blackhole");
+		    break;
+		  default:
+		    assert(0);
+		}
+	    }
+#ifdef HAVE_MPLS
+	  if (CHECK_FLAG (nexthop->rtype, ZEBRA_NEXTHOP_MPLS))
+            {
+              struct zmpls_out_segment *out;
+              char buf[16];
+
+              out = mpls_out_segment_find(nexthop->rmpls);
+              if (out)
+                mpls_print_label(&out->nh.mpls, buf);
+              else
+                strcpy(buf, "not found");
+              vty_out (vty, " (label %s)", buf);
+           }
+#endif
 	}
 
-      if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_BLACKHOLE))
-       vty_out (vty, ", bh");
-      if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_REJECT))
-       vty_out (vty, ", rej");
-      
+
+      if (nexthop->advmss)
+	vty_out (vty, " advmss %d", nexthop->advmss);
+
       if (rib->type == ZEBRA_ROUTE_RIPNG
 	  || rib->type == ZEBRA_ROUTE_OSPF6
 	  || rib->type == ZEBRA_ROUTE_ISIS
@@ -1730,6 +2908,7 @@ vty_show_ipv6_route (struct vty *vty, struct route_node *rn,
 		     tm->tm_yday/7,
 		     tm->tm_yday - ((tm->tm_yday/7) * 7), tm->tm_hour);
 	}
+
       vty_out (vty, "%s", VTY_NEWLINE);
     }
 }
@@ -1842,6 +3021,8 @@ DEFUN (show_ipv6_route_protocol,
     type = ZEBRA_ROUTE_RIPNG;
   else if (strncmp (argv[0], "s", 1) == 0)
     type = ZEBRA_ROUTE_STATIC;
+  else if (strncmp (argv[0], "l", 1) == 0)
+    type = ZEBRA_ROUTE_LDP;
   else 
     {
       vty_out (vty, "Unknown route type%s", VTY_NEWLINE);
@@ -1948,7 +3129,7 @@ static int
 static_config_ipv6 (struct vty *vty)
 {
   struct route_node *rn;
-  struct static_ipv6 *si;  
+  struct static_route *si;  
   int write;
   char buf[BUFSIZ];
   struct route_table *stable;
@@ -1967,28 +3148,39 @@ static_config_ipv6 (struct vty *vty)
 		 inet_ntop (AF_INET6, &rn->p.u.prefix6, buf, BUFSIZ),
 		 rn->p.prefixlen);
 
-	switch (si->type)
+        if (CHECK_FLAG(si->nh.type, ZEBRA_NEXTHOP_DROP))
+	  switch(si->nh.gw.drop)
+	    {
+	      case ZEBRA_DROP_NULL:
+		vty_out (vty, " Null0");
+		break;
+	      case ZEBRA_DROP_REJECT:
+		vty_out (vty, " %s", "reject");
+		break;
+	      case ZEBRA_DROP_BLACKHOLE:
+		vty_out (vty, " %s", "blackhole");
+		break;
+	      default:
+		assert(0);
+	    }
+	else
 	  {
-	  case STATIC_IPV6_GATEWAY:
-	    vty_out (vty, " %s", inet_ntop (AF_INET6, &si->ipv6, buf, BUFSIZ));
-	    break;
-	  case STATIC_IPV6_IFNAME:
-	    vty_out (vty, " %s", si->ifname);
-	    break;
-	  case STATIC_IPV6_GATEWAY_IFNAME:
-	    vty_out (vty, " %s %s",
-		     inet_ntop (AF_INET6, &si->ipv6, buf, BUFSIZ), si->ifname);
-	    break;
+	    if (CHECK_FLAG(si->nh.type, ZEBRA_NEXTHOP_IPV6))
+	      vty_out (vty, " %s", inet_ntop (AF_INET6, &si->nh.gw.ipv6,buf,BUFSIZ));
+	    if (CHECK_FLAG(si->nh.type, ZEBRA_NEXTHOP_IFNAME))
+	      vty_out (vty, " %s", si->nh.intf.name);
+#ifdef HAVE_MPLS
+	    if (CHECK_FLAG(si->nh.type, ZEBRA_NEXTHOP_MPLS))
+	      vty_out (vty, " 0x%08x", si->nh.mpls);
+#endif
 	  }
 
-       if (CHECK_FLAG(si->flags, ZEBRA_FLAG_REJECT))
-               vty_out (vty, " %s", "reject");
-
-       if (CHECK_FLAG(si->flags, ZEBRA_FLAG_BLACKHOLE))
-               vty_out (vty, " %s", "blackhole");
-
 	if (si->distance != ZEBRA_STATIC_DISTANCE_DEFAULT)
 	  vty_out (vty, " %d", si->distance);
+
+        if (si->nh.advmss)
+	  vty_out (vty, " advmss %d", si->nh.advmss);
+
 	vty_out (vty, "%s", VTY_NEWLINE);
 
 	write = 1;
@@ -2070,6 +3262,37 @@ zebra_vty_init (void)
   install_element (CONFIG_NODE, &no_ip_route_mask_flags_distance_cmd);
   install_element (CONFIG_NODE, &no_ip_route_mask_flags_distance2_cmd);
 
+  install_element (CONFIG_NODE, &ip_route_advmss_cmd);
+  install_element (CONFIG_NODE, &ip_route_mask_advmss_cmd);
+  install_element (CONFIG_NODE, &ip_route_distance_advmss_cmd);
+  install_element (CONFIG_NODE, &ip_route_mask_distance_advmss_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_advmss_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_mask_advmss_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_distance_advmss_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_mask_distance_advmss_cmd);
+#ifdef HAVE_MPLS
+  install_element (CONFIG_NODE, &ip_route_mpls_cmd);
+  install_element (CONFIG_NODE, &ip_route_mpls_addr_cmd);
+  install_element (CONFIG_NODE, &ip_route_mpls_mask_cmd);
+  install_element (CONFIG_NODE, &ip_route_mpls_mask_addr_cmd);
+  install_element (CONFIG_NODE, &ip_route_mpls_distance_cmd);
+  install_element (CONFIG_NODE, &ip_route_mpls_distance_addr_cmd);
+  install_element (CONFIG_NODE, &ip_route_mpls_mask_distance_cmd);
+  install_element (CONFIG_NODE, &ip_route_mpls_mask_distance_addr_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_mpls_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_mpls_addr_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_mpls_mask_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_mpls_mask_addr_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_mpls_distance_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_mpls_distance_addr_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_mpls_mask_distance_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_mpls_mask_distance_addr_cmd);
+
+  install_element (CONFIG_NODE, &ip_route_mpls_advmss_cmd);
+  install_element (CONFIG_NODE, &ip_route_mpls_addr_advmss_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_mpls_advmss_cmd);
+  install_element (CONFIG_NODE, &no_ip_route_mpls_addr_advmss_cmd);
+#endif /* HAVE_MPLS */
   install_element (VIEW_NODE, &show_ip_route_cmd);
   install_element (VIEW_NODE, &show_ip_route_addr_cmd);
   install_element (VIEW_NODE, &show_ip_route_prefix_cmd);
@@ -2105,11 +3328,29 @@ zebra_vty_init (void)
   install_element (CONFIG_NODE, &no_ipv6_route_flags_pref_cmd);
   install_element (CONFIG_NODE, &no_ipv6_route_ifname_pref_cmd);
   install_element (CONFIG_NODE, &no_ipv6_route_ifname_flags_pref_cmd);
+  install_element (CONFIG_NODE, &ipv6_route_advmss_cmd);
+  install_element (CONFIG_NODE, &ipv6_route_ifname_advmss_cmd);
+  install_element (CONFIG_NODE, &ipv6_route_pref_advmss_cmd);
+  install_element (CONFIG_NODE, &ipv6_route_ifname_pref_advmss_cmd);
+  install_element (CONFIG_NODE, &no_ipv6_route_advmss_cmd);
+  install_element (CONFIG_NODE, &no_ipv6_route_ifname_advmss_cmd);
+  install_element (CONFIG_NODE, &no_ipv6_route_pref_advmss_cmd);
+  install_element (CONFIG_NODE, &no_ipv6_route_ifname_pref_advmss_cmd);
   install_element (VIEW_NODE, &show_ipv6_route_cmd);
   install_element (VIEW_NODE, &show_ipv6_route_protocol_cmd);
   install_element (VIEW_NODE, &show_ipv6_route_addr_cmd);
   install_element (VIEW_NODE, &show_ipv6_route_prefix_cmd);
   install_element (VIEW_NODE, &show_ipv6_route_prefix_longer_cmd);
+#ifdef HAVE_MPLS
+  install_element (CONFIG_NODE, &ipv6_route_mpls_cmd);
+  install_element (CONFIG_NODE, &ipv6_route_mpls_addr_cmd);
+  install_element (CONFIG_NODE, &ipv6_route_mpls_pref_cmd);
+  install_element (CONFIG_NODE, &ipv6_route_mpls_pref_addr_cmd);
+  install_element (CONFIG_NODE, &no_ipv6_route_mpls_cmd);
+  install_element (CONFIG_NODE, &no_ipv6_route_mpls_addr_cmd);
+  install_element (CONFIG_NODE, &no_ipv6_route_mpls_pref_cmd);
+  install_element (CONFIG_NODE, &no_ipv6_route_mpls_pref_addr_cmd);
+#endif /* HAVE_MPLS */
   install_element (ENABLE_NODE, &show_ipv6_route_cmd);
   install_element (ENABLE_NODE, &show_ipv6_route_protocol_cmd);
   install_element (ENABLE_NODE, &show_ipv6_route_addr_cmd);
diff --git a/zebra/zserv.c b/zebra/zserv.c
index ef79eaa..0ef8000 100644
--- a/zebra/zserv.c
+++ b/zebra/zserv.c
@@ -336,6 +336,25 @@ zsend_interface_update (int cmd, struct zserv *client, struct interface *ifp)
   return zebra_server_send_message(client);
 }
 
+static void
+zsend_nexthop (struct zapi_nexthop *nh, struct nexthop *nexthop)
+{
+  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_DROP))
+    nh->gw.drop = nexthop->drop;
+  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV4))
+    nh->gw.ipv4 = nexthop->gate.ipv4;
+#ifdef HAVE_IPV6
+  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IPV6))
+    memcpy (&nh->gw.ipv6, &nexthop->gate.ipv6, 16);
+#endif
+  if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFINDEX))
+    nh->intf.index = nexthop->ifindex;
+  else if (CHECK_FLAG (nexthop->type, ZEBRA_NEXTHOP_IFNAME))
+    strncpy (nh->intf.name, nexthop->ifname, IFNAMSIZ);
+
+  nh->type = nexthop->type;
+}
+
 /*
  * The zebra server sends the clients  a ZEBRA_IPV4_ROUTE_ADD or a
  * ZEBRA_IPV6_ROUTE_ADD via zsend_route_multipath in the following
@@ -363,113 +382,103 @@ int
 zsend_route_multipath (int cmd, struct zserv *client, struct prefix *p,
                        struct rib *rib)
 {
-  int psize;
   struct stream *s;
+  int nhnum;
   struct nexthop *nexthop;
-  unsigned long nhnummark = 0, messmark = 0;
-  int nhnum = 0;
   u_char zapi_flags = 0;
-  
   s = client->obuf;
-  stream_reset (s);
-  
-  zserv_create_header (s, cmd);
-  
-  /* Put type and nexthop. */
-  stream_putc (s, rib->type);
-  stream_putc (s, rib->flags);
-  
-  /* marker for message flags field */
-  messmark = stream_get_endp (s);
-  stream_putc (s, 0);
-
-  /* Prefix. */
-  psize = PSIZE (p->prefixlen);
-  stream_putc (s, p->prefixlen);
-  stream_write (s, (u_char *) & p->u.prefix, psize);
 
-  /* 
-   * XXX The message format sent by zebra below does not match the format
-   * of the corresponding message expected by the zebra server
-   * itself (e.g., see zread_ipv4_add). The nexthop_num is not set correctly,
-   * (is there a bug on the client side if more than one segment is sent?)
-   * nexthop ZEBRA_NEXTHOP_IPV4 is never set, ZEBRA_NEXTHOP_IFINDEX 
-   * is hard-coded.
-   */
-  /* Nexthop */
-  
-  for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
+  if (p->family == AF_INET)
     {
-      if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))
+      struct zapi_ipv4 api;
+  
+      memset (&api, 0, sizeof(api));
+      api.type = rib->type;
+      api.flags = rib->flags;
+      nhnum = 0;
+
+      /* Nexthop */
+      for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
         {
-          SET_FLAG (zapi_flags, ZAPI_MESSAGE_NEXTHOP);
-          SET_FLAG (zapi_flags, ZAPI_MESSAGE_IFINDEX);
-          
-          if (nhnummark == 0)
+          if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))
             {
-              nhnummark = stream_get_endp (s);
-              stream_putc (s, 1); /* placeholder */
+              SET_FLAG (zapi_flags, ZAPI_MESSAGE_NEXTHOP);
+              zsend_nexthop(&api.nexthop[nhnum], nexthop);
+              nhnum++;
             }
-          
-          nhnum++;
+        }
+      api.nexthop_num = nhnum;
 
-          switch(nexthop->type) 
-            {
-              case NEXTHOP_TYPE_IPV4:
-              case NEXTHOP_TYPE_IPV4_IFINDEX:
-                stream_put_in_addr (s, &nexthop->gate.ipv4);
-                break;
-#ifdef HAVE_IPV6
-              case NEXTHOP_TYPE_IPV6:
-              case NEXTHOP_TYPE_IPV6_IFINDEX:
-              case NEXTHOP_TYPE_IPV6_IFNAME:
-                stream_write (s, (u_char *) &nexthop->gate.ipv6, 16);
-                break;
-#endif
-              default:
-                if (cmd == ZEBRA_IPV4_ROUTE_ADD 
-                    || cmd == ZEBRA_IPV4_ROUTE_DELETE)
-                  {
-                    struct in_addr empty;
-                    memset (&empty, 0, sizeof (struct in_addr));
-                    stream_write (s, (u_char *) &empty, IPV4_MAX_BYTELEN);
-                  }
-                else
-                  {
-                    struct in6_addr empty;
-                    memset (&empty, 0, sizeof (struct in6_addr));
-                    stream_write (s, (u_char *) &empty, IPV6_MAX_BYTELEN);
-                  }
-              }
-
-          /* Interface index. */
-          stream_putc (s, 1);
-          stream_putl (s, nexthop->ifindex);
-
-          break;
+      /* Distance */
+      if (CHECK_FLAG (zapi_flags, ZAPI_MESSAGE_DISTANCE))
+        api.distance = rib->distance;
+
+      /* Metric */
+      if (cmd == ZEBRA_IPV4_ROUTE_ADD)
+        {
+          SET_FLAG (zapi_flags, ZAPI_MESSAGE_DISTANCE);
+          api.distance = rib->distance;
+          SET_FLAG (zapi_flags, ZAPI_MESSAGE_METRIC);
+          api.metric = rib->metric;
         }
-    }
+  
+      /* write real message flags value */
+      api.message = zapi_flags;
 
-  /* Metric */
-  if (cmd == ZEBRA_IPV4_ROUTE_ADD || ZEBRA_IPV6_ROUTE_ADD)
-    {
-      SET_FLAG (zapi_flags, ZAPI_MESSAGE_DISTANCE);
-      stream_putc (s, rib->distance);
-      SET_FLAG (zapi_flags, ZAPI_MESSAGE_METRIC);
-      stream_putl (s, rib->metric);
+      zapi_ipv4_write (cmd, s, (struct prefix_ipv4*)p, &api);
+
+      /* Write packet length. */
+      stream_putw_at (s, 0, stream_get_endp (s));
+
+      return zebra_server_send_message (client);
     }
+#ifdef HAVE_IPV6
+  else if (p->family == AF_INET6)
+    {
+      struct zapi_ipv6 api;
   
-  /* write real message flags value */
-  stream_putc_at (s, messmark, zapi_flags);
-  
-  /* Write next-hop number */
-  if (nhnummark)
-    stream_putc_at (s, nhnummark, nhnum);
+      memset (&api, 0, sizeof(api));
+      api.type = rib->type;
+      api.flags = rib->flags;
+      nhnum = 0;
+
+      /* Nexthop */
+      for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
+        {
+          if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))
+            {
+              SET_FLAG (zapi_flags, ZAPI_MESSAGE_NEXTHOP);
+              zsend_nexthop(&api.nexthop[nhnum], nexthop);
+              nhnum++;
+            }
+        }
+      api.nexthop_num = nhnum;
+
+      /* Distance */
+      if (CHECK_FLAG (zapi_flags, ZAPI_MESSAGE_DISTANCE))
+        api.distance = rib->distance;
+
+      /* Metric */
+      if (cmd == ZEBRA_IPV6_ROUTE_ADD)
+        {
+          SET_FLAG (zapi_flags, ZAPI_MESSAGE_DISTANCE);
+          api.distance = rib->distance;
+          SET_FLAG (zapi_flags, ZAPI_MESSAGE_METRIC);
+          api.metric = rib->metric;
+        }
   
-  /* Write packet size. */
-  stream_putw_at (s, 0, stream_get_endp (s));
+      /* write real message flags value */
+      api.message = zapi_flags;
 
-  return zebra_server_send_message(client);
+      zapi_ipv6_write (cmd, s, (struct prefix_ipv6*)p, &api);
+
+      /* Write packet length. */
+      stream_putw_at (s, 0, stream_get_endp (s));
+
+      return zebra_server_send_message (client);
+    }
+#endif
+   return 0;
 }
 
 #ifdef HAVE_IPV6
@@ -481,9 +490,16 @@ zsend_ipv6_nexthop_lookup (struct zserv *client, struct in6_addr *addr)
   unsigned long nump;
   u_char num;
   struct nexthop *nexthop;
+  struct zapi_nexthop znh;
+  struct prefix p;
+
+  memset(&p, 0, sizeof(struct prefix));
+  p.family = AF_INET6;
+  p.prefixlen = IPV6_MAX_PREFIXLEN;
+  IPV6_ADDR_COPY (&p.u.prefix6, addr);
 
   /* Lookup nexthop. */
-  rib = rib_match_ipv6 (addr);
+  rib = rib_match_route (&p);
 
   /* Get output stream. */
   s = client->obuf;
@@ -502,25 +518,8 @@ zsend_ipv6_nexthop_lookup (struct zserv *client, struct in6_addr *addr)
       for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
 	if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))
 	  {
-	    stream_putc (s, nexthop->type);
-	    switch (nexthop->type)
-	      {
-	      case ZEBRA_NEXTHOP_IPV6:
-		stream_put (s, &nexthop->gate.ipv6, 16);
-		break;
-	      case ZEBRA_NEXTHOP_IPV6_IFINDEX:
-	      case ZEBRA_NEXTHOP_IPV6_IFNAME:
-		stream_put (s, &nexthop->gate.ipv6, 16);
-		stream_putl (s, nexthop->ifindex);
-		break;
-	      case ZEBRA_NEXTHOP_IFINDEX:
-	      case ZEBRA_NEXTHOP_IFNAME:
-		stream_putl (s, nexthop->ifindex);
-		break;
-	      default:
-                /* do nothing */
-		break;
-	      }
+	    zsend_nexthop(&znh, nexthop);
+	    zapi_nexthop_write(s, &znh);
 	    num++;
 	  }
       stream_putc_at (s, nump, num);
@@ -545,9 +544,16 @@ zsend_ipv4_nexthop_lookup (struct zserv *client, struct in_addr addr)
   unsigned long nump;
   u_char num;
   struct nexthop *nexthop;
+  struct zapi_nexthop znh;
+  struct prefix p;
+
+  memset(&p, 0, sizeof(struct prefix));
+  p.family = AF_INET;
+  p.prefixlen = IPV4_MAX_PREFIXLEN;
+  IPV4_ADDR_COPY (&p.u.prefix4, &addr);
 
   /* Lookup nexthop. */
-  rib = rib_match_ipv4 (addr);
+  rib = rib_match_route (&p);
 
   /* Get output stream. */
   s = client->obuf;
@@ -566,20 +572,8 @@ zsend_ipv4_nexthop_lookup (struct zserv *client, struct in_addr addr)
       for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
 	if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))
 	  {
-	    stream_putc (s, nexthop->type);
-	    switch (nexthop->type)
-	      {
-	      case ZEBRA_NEXTHOP_IPV4:
-		stream_put_in_addr (s, &nexthop->gate.ipv4);
-		break;
-	      case ZEBRA_NEXTHOP_IFINDEX:
-	      case ZEBRA_NEXTHOP_IFNAME:
-		stream_putl (s, nexthop->ifindex);
-		break;
-	      default:
-                /* do nothing */
-		break;
-	      }
+	    zsend_nexthop(&znh, nexthop);
+	    zapi_nexthop_write(s, &znh);
 	    num++;
 	  }
       stream_putc_at (s, nump, num);
@@ -603,9 +597,10 @@ zsend_ipv4_import_lookup (struct zserv *client, struct prefix_ipv4 *p)
   unsigned long nump;
   u_char num;
   struct nexthop *nexthop;
+  struct zapi_nexthop znh;
 
   /* Lookup nexthop. */
-  rib = rib_lookup_ipv4 (p);
+  rib = rib_lookup_route ((struct prefix*)p);
 
   /* Get output stream. */
   s = client->obuf;
@@ -624,20 +619,8 @@ zsend_ipv4_import_lookup (struct zserv *client, struct prefix_ipv4 *p)
       for (nexthop = rib->nexthop; nexthop; nexthop = nexthop->next)
 	if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))
 	  {
-	    stream_putc (s, nexthop->type);
-	    switch (nexthop->type)
-	      {
-	      case ZEBRA_NEXTHOP_IPV4:
-		stream_put_in_addr (s, &nexthop->gate.ipv4);
-		break;
-	      case ZEBRA_NEXTHOP_IFINDEX:
-	      case ZEBRA_NEXTHOP_IFNAME:
-		stream_putl (s, nexthop->ifindex);
-		break;
-	      default:
-                /* do nothing */
-		break;
-	      }
+	    zsend_nexthop(&znh, nexthop);
+	    zapi_nexthop_write(s, &znh);
 	    num++;
 	  }
       stream_putc_at (s, nump, num);
@@ -734,76 +717,41 @@ zread_ipv4_add (struct zserv *client, u_short length)
   int i;
   struct rib *rib;
   struct prefix_ipv4 p;
-  u_char message;
-  struct in_addr nexthop;
-  u_char nexthop_num;
-  u_char nexthop_type;
   struct stream *s;
-  unsigned int ifindex;
-  u_char ifname_len;
+  struct zapi_ipv4 api;
 
   /* Get input stream.  */
   s = client->ibuf;
+  memset (&api, 0, sizeof (api));
+  memset (&p, 0, sizeof (p));
+  zapi_ipv4_read (s, length, &api, &p);
 
   /* Allocate new rib. */
   rib = XCALLOC (MTYPE_RIB, sizeof (struct rib));
   
   /* Type, flags, message. */
-  rib->type = stream_getc (s);
-  rib->flags = stream_getc (s);
-  message = stream_getc (s); 
+  rib->type = api.type;
+  rib->flags = api.flags;
   rib->uptime = time (NULL);
 
-  /* IPv4 prefix. */
-  memset (&p, 0, sizeof (struct prefix_ipv4));
-  p.family = AF_INET;
-  p.prefixlen = stream_getc (s);
-  stream_get (&p.prefix, s, PSIZE (p.prefixlen));
-
   /* Nexthop parse. */
-  if (CHECK_FLAG (message, ZAPI_MESSAGE_NEXTHOP))
+  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
     {
-      nexthop_num = stream_getc (s);
-
-      for (i = 0; i < nexthop_num; i++)
-	{
-	  nexthop_type = stream_getc (s);
-
-	  switch (nexthop_type)
-	    {
-	    case ZEBRA_NEXTHOP_IFINDEX:
-	      ifindex = stream_getl (s);
-	      nexthop_ifindex_add (rib, ifindex);
-	      break;
-	    case ZEBRA_NEXTHOP_IFNAME:
-	      ifname_len = stream_getc (s);
-	      stream_forward_getp (s, ifname_len);
-	      break;
-	    case ZEBRA_NEXTHOP_IPV4:
-	      nexthop.s_addr = stream_get_ipv4 (s);
-	      nexthop_ipv4_add (rib, &nexthop, NULL);
-	      break;
-	    case ZEBRA_NEXTHOP_IPV6:
-	      stream_forward_getp (s, IPV6_MAX_BYTELEN);
-	      break;
-      case ZEBRA_NEXTHOP_BLACKHOLE:
-        nexthop_blackhole_add (rib);
-        break;
-	    }
-	}
+      for (i = 0; i < api.nexthop_num; i++)
+        nexthop_zapi_nexthop_add(rib, &api.nexthop[i]);
     }
 
   /* Distance. */
-  if (CHECK_FLAG (message, ZAPI_MESSAGE_DISTANCE))
-    rib->distance = stream_getc (s);
+  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))
+    rib->distance = api.distance;
 
   /* Metric. */
-  if (CHECK_FLAG (message, ZAPI_MESSAGE_METRIC))
-    rib->metric = stream_getl (s);
+  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))
+    rib->metric = api.metric;
     
   /* Table */
   rib->table=zebrad.rtm_table_default;
-  rib_add_ipv4_multipath (&p, rib);
+  rib_add_multipath ((struct prefix*)&p, rib);
   return 0;
 }
 
@@ -812,72 +760,22 @@ static int
 zread_ipv4_delete (struct zserv *client, u_short length)
 {
   int i;
+  struct prefix_ipv4 p;
   struct stream *s;
   struct zapi_ipv4 api;
-  struct in_addr nexthop;
-  unsigned long ifindex;
-  struct prefix_ipv4 p;
-  u_char nexthop_num;
-  u_char nexthop_type;
-  u_char ifname_len;
-  
-  s = client->ibuf;
-  ifindex = 0;
-  nexthop.s_addr = 0;
 
-  /* Type, flags, message. */
-  api.type = stream_getc (s);
-  api.flags = stream_getc (s);
-  api.message = stream_getc (s);
-
-  /* IPv4 prefix. */
-  memset (&p, 0, sizeof (struct prefix_ipv4));
-  p.family = AF_INET;
-  p.prefixlen = stream_getc (s);
-  stream_get (&p.prefix, s, PSIZE (p.prefixlen));
+  /* Get input stream.  */
+  s = client->ibuf;
+  memset (&api, 0, sizeof (api));
+  memset (&p, 0, sizeof (p));
+  zapi_ipv4_read (s, length, &api, &p);
 
   /* Nexthop, ifindex, distance, metric. */
   if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
-    {
-      nexthop_num = stream_getc (s);
-
-      for (i = 0; i < nexthop_num; i++)
-	{
-	  nexthop_type = stream_getc (s);
-
-	  switch (nexthop_type)
-	    {
-	    case ZEBRA_NEXTHOP_IFINDEX:
-	      ifindex = stream_getl (s);
-	      break;
-	    case ZEBRA_NEXTHOP_IFNAME:
-	      ifname_len = stream_getc (s);
-	      stream_forward_getp (s, ifname_len);
-	      break;
-	    case ZEBRA_NEXTHOP_IPV4:
-	      nexthop.s_addr = stream_get_ipv4 (s);
-	      break;
-	    case ZEBRA_NEXTHOP_IPV6:
-	      stream_forward_getp (s, IPV6_MAX_BYTELEN);
-	      break;
-	    }
-	}
-    }
+    for (i = 0; i < api.nexthop_num; i++)
+      rib_delete_route (api.type, api.flags, (struct prefix*)&p,
+                        &api.nexthop[i], client->rtm_table);
 
-  /* Distance. */
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))
-    api.distance = stream_getc (s);
-  else
-    api.distance = 0;
-
-  /* Metric. */
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))
-    api.metric = stream_getl (s);
-  else
-    api.metric = 0;
-    
-  rib_delete_ipv4 (api.type, api.flags, &p, &nexthop, ifindex,
-		   client->rtm_table);
   return 0;
 }
 
@@ -910,65 +808,24 @@ static int
 zread_ipv6_add (struct zserv *client, u_short length)
 {
   int i;
+  struct prefix_ipv6 p;
   struct stream *s;
   struct zapi_ipv6 api;
-  struct in6_addr nexthop;
-  unsigned long ifindex;
-  struct prefix_ipv6 p;
-  
-  s = client->ibuf;
-  ifindex = 0;
-  memset (&nexthop, 0, sizeof (struct in6_addr));
-
-  /* Type, flags, message. */
-  api.type = stream_getc (s);
-  api.flags = stream_getc (s);
-  api.message = stream_getc (s);
 
-  /* IPv4 prefix. */
-  memset (&p, 0, sizeof (struct prefix_ipv6));
-  p.family = AF_INET6;
-  p.prefixlen = stream_getc (s);
-  stream_get (&p.prefix, s, PSIZE (p.prefixlen));
+  /* Get input stream.  */
+  s = client->ibuf;
+  memset (&api, 0, sizeof (api));
+  memset (&p, 0, sizeof (p));
+  zapi_ipv6_read (s, length, &api, &p);
 
   /* Nexthop, ifindex, distance, metric. */
   if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
     {
-      u_char nexthop_type;
-
-      api.nexthop_num = stream_getc (s);
       for (i = 0; i < api.nexthop_num; i++)
-	{
-	  nexthop_type = stream_getc (s);
-
-	  switch (nexthop_type)
-	    {
-	    case ZEBRA_NEXTHOP_IPV6:
-	      stream_get (&nexthop, s, 16);
-	      break;
-	    case ZEBRA_NEXTHOP_IFINDEX:
-	      ifindex = stream_getl (s);
-	      break;
-	    }
-	}
+        rib_add_route (api.type, api.flags, (struct prefix*)&p,
+                       &api.nexthop[i], 0, api.metric, api.distance);
     }
 
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))
-    api.distance = stream_getc (s);
-  else
-    api.distance = 0;
-
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))
-    api.metric = stream_getl (s);
-  else
-    api.metric = 0;
-    
-  if (IN6_IS_ADDR_UNSPECIFIED (&nexthop))
-    rib_add_ipv6 (api.type, api.flags, &p, NULL, ifindex, 0, api.metric,
-		  api.distance);
-  else
-    rib_add_ipv6 (api.type, api.flags, &p, &nexthop, ifindex, 0, api.metric,
-		  api.distance);
   return 0;
 }
 
@@ -977,62 +834,24 @@ static int
 zread_ipv6_delete (struct zserv *client, u_short length)
 {
   int i;
+  struct prefix_ipv6 p;
   struct stream *s;
   struct zapi_ipv6 api;
-  struct in6_addr nexthop;
-  unsigned long ifindex;
-  struct prefix_ipv6 p;
-  
-  s = client->ibuf;
-  ifindex = 0;
-  memset (&nexthop, 0, sizeof (struct in6_addr));
 
-  /* Type, flags, message. */
-  api.type = stream_getc (s);
-  api.flags = stream_getc (s);
-  api.message = stream_getc (s);
-
-  /* IPv4 prefix. */
-  memset (&p, 0, sizeof (struct prefix_ipv6));
-  p.family = AF_INET6;
-  p.prefixlen = stream_getc (s);
-  stream_get (&p.prefix, s, PSIZE (p.prefixlen));
+  /* Get input stream.  */
+  s = client->ibuf;
+  memset (&api, 0, sizeof (api));
+  memset (&p, 0, sizeof (p));
+  zapi_ipv6_read (s, length, &api, &p);
 
   /* Nexthop, ifindex, distance, metric. */
   if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))
     {
-      u_char nexthop_type;
-
-      api.nexthop_num = stream_getc (s);
       for (i = 0; i < api.nexthop_num; i++)
-	{
-	  nexthop_type = stream_getc (s);
-
-	  switch (nexthop_type)
-	    {
-	    case ZEBRA_NEXTHOP_IPV6:
-	      stream_get (&nexthop, s, 16);
-	      break;
-	    case ZEBRA_NEXTHOP_IFINDEX:
-	      ifindex = stream_getl (s);
-	      break;
-	    }
-	}
+        rib_delete_route (api.type, api.flags, (struct prefix*)&p,
+                          &api.nexthop[i], 0);
     }
 
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))
-    api.distance = stream_getc (s);
-  else
-    api.distance = 0;
-  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))
-    api.metric = stream_getl (s);
-  else
-    api.metric = 0;
-    
-  if (IN6_IS_ADDR_UNSPECIFIED (&nexthop))
-    rib_delete_ipv6 (api.type, api.flags, &p, NULL, ifindex, 0);
-  else
-    rib_delete_ipv6 (api.type, api.flags, &p, &nexthop, ifindex, 0);
   return 0;
 }
 
@@ -1049,6 +868,416 @@ zread_ipv6_nexthop_lookup (struct zserv *client, u_short length)
 }
 #endif /* HAVE_IPV6 */
 
+#ifdef HAVE_MPLS
+int
+zsend_mpls_xc_add (struct zserv *client, struct zmpls_xc *p)
+{
+  struct zapi_mpls_xc api;
+  struct stream *s;
+
+  s = client->obuf;
+  stream_reset (s);
+
+  api.owner = p->owner;
+  api.index = p->index;
+  api.in_labelspace = p->in_labelspace;
+  memcpy(&api.in_label,&p->in_label, sizeof(struct zmpls_label));
+  api.out_index = p->out_index;
+
+  zserv_create_header (s, ZEBRA_MPLS_XC_ADD);
+  mpls_xc_stream_write (s, &api);
+
+  stream_putw_at (s, 0, stream_get_endp (s));
+  return zebra_server_send_message(client);
+}
+
+int
+zsend_mpls_xc_delete (struct zserv *client, struct zmpls_xc *p)
+{
+  struct zapi_mpls_xc api;
+  struct stream *s;
+
+  s = client->obuf;
+  stream_reset (s);
+
+  api.owner = p->owner;
+  api.index = p->index;
+  api.in_labelspace = p->in_labelspace;
+  memcpy(&api.in_label,&p->in_label, sizeof(struct zmpls_label));
+  api.out_index = p->out_index;
+
+  zserv_create_header (s, ZEBRA_MPLS_XC_DELETE);
+  mpls_xc_stream_write (s, &api);
+
+  stream_putw_at (s, 0, stream_get_endp (s));
+  return zebra_server_send_message(client);
+}
+
+int
+zsend_mpls_in_segment_add (struct zserv *client, struct zmpls_in_segment *in)
+{
+  struct zapi_mpls_in_segment api;
+  struct stream *s;
+
+  s = client->obuf;
+  stream_reset (s);
+
+  zserv_create_header (s, ZEBRA_MPLS_IN_SEGMENT_ADD);
+
+  api.owner = in->owner;
+  api.labelspace = in->labelspace;
+  api.protocol = in->protocol;
+  api.pop = in->pop;
+  memcpy (&api.label, &in->label, sizeof (api.label));
+  
+  mpls_in_segment_stream_write (s, &api);
+
+  stream_putw_at (s, 0, stream_get_endp (s));
+  return zebra_server_send_message(client);
+}
+
+int
+zsend_mpls_in_segment_delete (struct zserv *client, struct zmpls_in_segment *in)
+{
+  struct zapi_mpls_in_segment api;
+  struct stream *s;
+
+  s = client->obuf;
+  stream_reset (s);
+
+  zserv_create_header (s, ZEBRA_MPLS_IN_SEGMENT_DELETE);
+
+  api.owner = in->owner;
+  api.labelspace = in->labelspace;
+  api.protocol = in->protocol;
+  api.pop = in->pop;
+  memcpy (&api.label, &in->label, sizeof (api.label));
+  
+  mpls_in_segment_stream_write (s, &api);
+
+  stream_putw_at (s, 0, stream_get_endp (s));
+  return zebra_server_send_message(client);
+}
+
+int
+zsend_mpls_out_segment_add (struct zserv *client, struct zmpls_out_segment *out)
+{
+  struct zapi_mpls_out_segment api;
+  struct stream *s;
+
+  api.owner = out->owner;
+
+  memcpy(&api.nh, &out->nh, sizeof(struct zapi_nexthop));
+
+  s = client->obuf;
+  stream_reset (s);
+
+  zserv_create_header (s, ZEBRA_MPLS_OUT_SEGMENT_ADD);
+  mpls_out_segment_stream_write (s, &api);
+
+  stream_putw_at (s, 0, stream_get_endp (s));
+  return zebra_server_send_message(client);
+}
+
+int
+zsend_mpls_out_segment_delete (struct zserv *client, struct zmpls_out_segment *out)
+{
+  struct zapi_mpls_out_segment api;
+  struct stream *s;
+
+  api.owner = out->owner;
+
+  memcpy(&api.nh, &out->nh, sizeof(struct zapi_nexthop));
+
+  s = client->obuf;
+  stream_reset (s);
+
+  zserv_create_header (s, ZEBRA_MPLS_OUT_SEGMENT_DELETE);
+  mpls_out_segment_stream_write (s, &api);
+
+  stream_putw_at (s, 0, stream_get_endp (s));
+  return zebra_server_send_message(client);
+}
+
+int
+zsend_mpls_labelspace_add (struct zserv *client, struct interface *ifp)
+{
+  struct zapi_mpls_labelspace api;
+  struct stream *s;
+
+  s = client->obuf;
+  stream_reset (s);
+
+  zserv_create_header (s, ZEBRA_MPLS_LABELSPACE_ADD);
+
+  api.owner = ZEBRA_ROUTE_KERNEL;
+  api.labelspace = ifp->mpls_labelspace;
+  strncpy(api.ifname, ifp->name, INTERFACE_NAMSIZ);
+  mpls_labelspace_stream_write (s, &api);
+
+  stream_putw_at (s, 0, stream_get_endp (s));
+  return zebra_server_send_message(client);
+}
+
+int
+zsend_mpls_labelspace_delete (struct zserv *client, struct interface *ifp)
+{
+  struct zapi_mpls_labelspace api;
+  struct stream *s;
+
+  s = client->obuf;
+  stream_reset (s);
+
+  zserv_create_header (s, ZEBRA_MPLS_LABELSPACE_DELETE);
+
+  api.owner = ZEBRA_ROUTE_KERNEL;
+  api.labelspace = ifp->mpls_labelspace;
+  strncpy(api.ifname, ifp->name, INTERFACE_NAMSIZ);
+  mpls_labelspace_stream_write (s, &api);
+
+  stream_putw_at (s, 0, stream_get_endp (s));
+  return zebra_server_send_message(client);
+}
+
+int
+zsend_mpls_ftn_add (struct zserv *client, struct zmpls_ftn *ftn)
+{
+  struct zapi_mpls_ftn api;
+  struct stream *s;
+
+  s = client->obuf;
+  stream_reset (s);
+
+  zserv_create_header (s, ZEBRA_MPLS_FTN_ADD);
+
+  api.owner = ftn->owner;
+  api.out_index = ftn->out_index;
+  memcpy(&api.fec.u.p, &ftn->fec.u.p, sizeof (struct prefix));
+  if (ftn->fec.u.p.family == AF_INET) {
+    api.fec.type = ZEBRA_MPLS_FEC_IPV4;
+  } else if (ftn->fec.u.p.family == AF_INET6) {
+    api.fec.type = ZEBRA_MPLS_FEC_IPV6;
+  } else {
+    assert (0);
+  }
+  mpls_ftn_stream_write (s, &api);
+
+  stream_putw_at (s, 0, stream_get_endp (s));
+  return zebra_server_send_message(client);
+}
+
+int
+zsend_mpls_ftn_delete (struct zserv *client, struct zmpls_ftn *ftn)
+{
+  struct zapi_mpls_ftn api;
+  struct stream *s;
+
+  s = client->obuf;
+  stream_reset (s);
+
+  zserv_create_header (s, ZEBRA_MPLS_FTN_DELETE);
+
+  api.owner = ftn->owner;
+  api.out_index = ftn->out_index;
+  memcpy(&api.fec.u.p, &ftn->fec.u.p, sizeof (struct prefix));
+  if (ftn->fec.u.p.family == AF_INET) {
+    api.fec.type = ZEBRA_MPLS_FEC_IPV4;
+  } else if (ftn->fec.u.p.family == AF_INET6) {
+    api.fec.type = ZEBRA_MPLS_FEC_IPV6;
+  } else {
+    assert (0);
+  }
+  mpls_ftn_stream_write (s, &api);
+
+  stream_putw_at (s, 0, stream_get_endp (s));
+  return zebra_server_send_message(client);
+}
+
+static void
+zread_mpls_xc_add (struct zserv *client, u_short length)
+{
+  struct zapi_mpls_xc api;
+  struct zmpls_out_segment *out;
+  struct zmpls_in_segment tmp;
+  struct zmpls_in_segment *in;
+  struct zmpls_xc xc;
+
+  memset(&api, 0, sizeof(api));
+  memset(&xc, 0, sizeof(xc));
+  mpls_xc_stream_read (client->ibuf, &api);
+
+  tmp.labelspace = api.in_labelspace;
+  memcpy(&tmp.label, &api.in_label, sizeof(struct zmpls_label));
+
+  out = mpls_out_segment_find (api.out_index);
+  in = mpls_in_segment_find (&tmp);
+
+  xc.in_labelspace = in->labelspace;
+  memcpy(&xc.in_label, &in->label, sizeof(struct zmpls_label));
+  xc.out_index = out->index;
+  xc.owner = api.owner;
+
+  mpls_xc_register (&xc);
+}
+
+static void
+zread_mpls_xc_delete (struct zserv *client, u_short length)
+{
+  struct zapi_mpls_xc api;
+  struct zmpls_in_segment tmp;
+  struct zmpls_in_segment *in;
+  struct zmpls_xc *xc;
+
+  memset(&api, 0, sizeof(api));
+  memset(&tmp, 0, sizeof(tmp));
+  mpls_xc_stream_read (client->ibuf, &api);
+
+  memcpy(&tmp.label, &api.in_label, sizeof(struct zmpls_label));
+  tmp.labelspace = api.in_labelspace;
+  in = mpls_in_segment_find (&tmp);
+  xc = mpls_xc_find (in->xc);
+
+  if (xc)
+    mpls_xc_unregister (xc);
+  else
+    zlog_warn("zread_mpls_xc_delete: xc %d does not exist", in->xc);
+}
+
+static void
+zread_mpls_in_segment_add (struct zserv *client, u_short length)
+{
+  struct zapi_mpls_in_segment api;
+  struct zmpls_in_segment in;
+
+  memset(&api, 0, sizeof(api));
+  memset(&in, 0, sizeof(in));
+  mpls_in_segment_stream_read (client->ibuf, &api);
+
+  in.owner = api.owner;
+  in.labelspace = api.labelspace;
+  in.protocol = api.protocol;
+  in.pop = api.pop;
+  memcpy (&in.label, &api.label, sizeof (api.label));
+
+  mpls_in_segment_register (&in, 1);
+}
+
+static void
+zread_mpls_in_segment_delete (struct zserv *client, u_short length)
+{
+  struct zapi_mpls_in_segment api;
+  struct zmpls_in_segment in;
+
+  memset(&api, 0, sizeof(api));
+  memset(&in, 0, sizeof(in));
+  mpls_in_segment_stream_read (client->ibuf, &api);
+  in.owner = api.owner;
+  in.labelspace = api.labelspace;
+  in.protocol = api.protocol;
+  in.pop = api.pop;
+  memcpy (&in.label, &api.label, sizeof (api.label));
+
+  mpls_in_segment_unregister (&in, 0);
+}
+
+static void
+zread_mpls_out_segment_add (struct zserv *client, u_short length)
+{
+  struct zapi_mpls_out_segment api;
+  struct zmpls_out_segment out;
+  struct stream *s;
+
+  memset(&api, 0, sizeof(api));
+  memset(&out, 0, sizeof(out));
+  mpls_out_segment_stream_read (client->ibuf, &api);
+
+  out.owner = api.owner;
+  memcpy(&out.nh, &api.nh, sizeof(struct zapi_nexthop));
+
+  mpls_out_segment_register (&out);
+  api.index = out.index;
+
+  /* Reset stream. */
+  s = client->obuf;
+  stream_reset (s);
+
+  zserv_create_header (s, ZEBRA_MPLS_OUT_SEGMENT_ADD);
+  mpls_out_segment_stream_write(s, &api);
+
+  /* Put length at the first point of the stream. */
+  stream_putw_at (s, 0, stream_get_endp (s));
+
+  zebra_server_send_message(client);
+}
+
+static void
+zread_mpls_out_segment_delete (struct zserv *client, u_short length)
+{
+  struct zapi_mpls_out_segment api;
+  struct zmpls_out_segment out;
+
+  memset(&api, 0, sizeof(api));
+  memset(&out, 0, sizeof(out));
+  mpls_out_segment_stream_read (client->ibuf, &api);
+
+  out.owner = api.owner;
+  memcpy(&out.nh, &api.nh, sizeof(struct zapi_nexthop));
+
+  mpls_out_segment_unregister (&out);
+}
+
+static void
+zread_mpls_ftn_add (struct zserv *client, u_short length)
+{
+  struct zapi_mpls_ftn api;
+  struct zmpls_ftn ftn;
+
+  memset(&api, 0, sizeof(api));
+  memset(&ftn, 0, sizeof(ftn));
+  mpls_ftn_stream_read (client->ibuf, &api);
+
+  memcpy(&ftn.fec, &api.fec, sizeof(struct zmpls_fec));
+  ftn.owner = api.owner;
+  ftn.out_index = api.out_index;
+  mpls_ftn_register (&ftn, 1);
+}
+
+static void
+zread_mpls_ftn_delete (struct zserv *client, u_short length)
+{
+  struct zapi_mpls_ftn api;
+  struct zmpls_ftn *ftn;
+
+  memset(&api, 0, sizeof(api));
+  mpls_ftn_stream_read (client->ibuf, &api);
+
+  ftn = mpls_ftn_find_by_fec(&api.fec);
+  if (ftn) {
+    mpls_ftn_unregister (ftn, 1);
+  }
+}
+
+static void
+zread_mpls_labelspace_add (struct zserv *client, u_short length)
+{
+  struct zapi_mpls_labelspace api;
+
+  memset(&api, 0, sizeof(api));
+  mpls_labelspace_stream_read (client->ibuf, &api);
+  assert(0);
+}
+
+static void
+zread_mpls_labelspace_delete (struct zserv *client, u_short length)
+{
+  struct zapi_mpls_labelspace api;
+
+  memset(&api, 0, sizeof(api));
+  mpls_labelspace_stream_read (client->ibuf, &api);
+  assert(0);
+}
+#endif /* HAVE_MPLS */
+
 /* Register zebra server router-id information.  Send current router-id */
 static int
 zread_router_id_add (struct zserv *client, u_short length)
@@ -1283,6 +1512,38 @@ zebra_client_read (struct thread *thread)
     case ZEBRA_IPV4_IMPORT_LOOKUP:
       zread_ipv4_import_lookup (client, length);
       break;
+#ifdef HAVE_MPLS
+    case ZEBRA_MPLS_XC_ADD:
+      zread_mpls_xc_add (client, length);
+      break;
+    case ZEBRA_MPLS_XC_DELETE:
+      zread_mpls_xc_delete (client, length);
+      break;
+    case ZEBRA_MPLS_IN_SEGMENT_ADD:
+      zread_mpls_in_segment_add (client, length);
+      break;
+    case ZEBRA_MPLS_IN_SEGMENT_DELETE:
+      zread_mpls_in_segment_delete (client, length);
+      break;
+    case ZEBRA_MPLS_OUT_SEGMENT_ADD:
+      zread_mpls_out_segment_add (client, length);
+      break;
+    case ZEBRA_MPLS_OUT_SEGMENT_DELETE:
+      zread_mpls_out_segment_delete (client, length);
+      break;
+    case ZEBRA_MPLS_LABELSPACE_ADD:
+      zread_mpls_labelspace_add (client, length);
+      break;
+    case ZEBRA_MPLS_LABELSPACE_DELETE:
+      zread_mpls_labelspace_delete (client, length);
+      break;
+    case ZEBRA_MPLS_FTN_ADD:
+      zread_mpls_ftn_add (client, length);
+      break;
+    case ZEBRA_MPLS_FTN_DELETE:
+      zread_mpls_ftn_delete (client, length);
+      break;
+#endif /* HAVE_MPLS */
     default:
       zlog_info ("Zebra received unknown command %d", command);
       break;
diff --git a/zebra/zserv.h b/zebra/zserv.h
index 87a33a4..77bc062 100644
--- a/zebra/zserv.h
+++ b/zebra/zserv.h
@@ -25,6 +25,9 @@
 #include "rib.h"
 #include "if.h"
 #include "workqueue.h"
+#ifdef HAVE_MPLS
+#include "mpls_lib.h"
+#endif
 
 /* Default port information. */
 #define ZEBRA_VTY_PORT                2601
@@ -95,6 +98,10 @@ extern void interface_list (void);
 extern void kernel_init (void);
 extern void route_read (void);
 extern void zebra_route_map_init (void);
+#ifdef HAVE_MPLS
+extern void mpls_kernel_init (void);
+extern void mpls_read (void);
+#endif
 extern void zebra_snmp_init (void);
 extern void zebra_vty_init (void);
 
@@ -107,6 +114,38 @@ extern int zsend_route_multipath (int, struct zserv *, struct prefix *,
                                   struct rib *);
 extern int zsend_router_id_update(struct zserv *, struct prefix *);
 
+#ifdef HAVE_MPLS
+int
+zsend_mpls_xc_add (struct zserv *client, struct zmpls_xc *p);
+
+int
+zsend_mpls_xc_delete (struct zserv *client, struct zmpls_xc *p);
+
+int
+zsend_mpls_in_segment_add (struct zserv *client, struct zmpls_in_segment *p);
+
+int
+zsend_mpls_in_segment_delete (struct zserv *client, struct zmpls_in_segment *p);
+
+int
+zsend_mpls_out_segment_add (struct zserv *client, struct zmpls_out_segment *p);
+
+int
+zsend_mpls_out_segment_delete (struct zserv *client, struct zmpls_out_segment *p);
+
+int
+zsend_mpls_labelspace_add (struct zserv *client, struct interface *ifp);
+
+int
+zsend_mpls_labelspace_delete (struct zserv *client, struct interface *ifp);
+
+int
+zsend_mpls_ftn_add (struct zserv *client, struct zmpls_ftn *ftn);
+
+int
+zsend_mpls_ftn_delete (struct zserv *client, struct zmpls_ftn *ftn);
+#endif
+
 extern pid_t pid;
 
 #endif /* _ZEBRA_ZEBRA_H */
